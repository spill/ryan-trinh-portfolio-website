<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ryan's Arcade | Secret Zone</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-card: #1a1a24;
            --accent: #00ff88;
            --accent-secondary: #ff6b6b;
            --accent-third: #ffd93d;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --border: #2a2a3a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Animated background gradient */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(ellipse at 20% 20%, rgba(0, 255, 136, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(255, 107, 107, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(255, 217, 61, 0.05) 0%, transparent 60%);
            pointer-events: none;
            z-index: 0;
            animation: bgPulse 8s ease-in-out infinite;
        }

        @keyframes bgPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Scanline effect */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15) 0px,
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 3px
            );
            pointer-events: none;
            z-index: 9999;
        }

        /* Floating particles */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--accent);
            border-radius: 50%;
            opacity: 0.3;
            animation: floatParticle 15s infinite linear;
        }

        @keyframes floatParticle {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 0.3; }
            90% { opacity: 0.3; }
            100% { transform: translateY(-100vh) rotate(720deg); opacity: 0; }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 24px;
        }

        /* Header */
        header {
            padding: 20px 0;
            background: rgba(10, 10, 15, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--accent);
            text-decoration: none;
            text-shadow: 0 0 20px var(--accent);
            transition: all 0.3s ease;
            animation: logoGlow 2s ease-in-out infinite;
        }

        .logo:hover {
            text-shadow: 0 0 30px var(--accent), 0 0 60px var(--accent);
            transform: scale(1.05);
        }

        @keyframes logoGlow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .back-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
            transform: translateX(-3px);
        }

        /* Hero */
        .hero {
            text-align: center;
            padding: 80px 0 60px;
            position: relative;
        }

        .hero h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(1.8rem, 5vw, 3rem);
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--accent) 0%, #00ccff 50%, var(--accent-third) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 60px rgba(0, 255, 136, 0.5);
            animation: titleGlow 3s ease-in-out infinite;
            position: relative;
        }

        @keyframes titleGlow {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(0, 255, 136, 0.8)); }
            50% { filter: drop-shadow(0 0 40px rgba(0, 255, 136, 1)); }
        }

        .hero-subtitle {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            color: var(--text-secondary);
            letter-spacing: 4px;
            margin-bottom: 24px;
            opacity: 0.7;
        }

        .hero p {
            color: var(--text-secondary);
            font-size: 1.1rem;
            max-width: 500px;
            margin: 0 auto;
        }

        .hero .secret-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(255, 107, 107, 0.1));
            border: 1px solid var(--accent-secondary);
            border-radius: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.55rem;
            color: var(--accent-secondary);
            margin-bottom: 24px;
            animation: badgePulse 2s ease-in-out infinite;
        }

        @keyframes badgePulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 107, 107, 0.3); }
            50% { box-shadow: 0 0 25px rgba(255, 107, 107, 0.6); }
        }

        .hero-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 30px;
            padding-top: 30px;
            border-top: 1px solid var(--border);
        }

        .hero-stat {
            text-align: center;
        }

        .hero-stat-value {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            color: var(--accent);
            display: block;
        }

        .hero-stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* Games Grid */
        .games-section {
            position: relative;
            z-index: 2;
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 28px;
            padding: 20px 0 100px;
        }

        .game-card {
            background: linear-gradient(145deg, rgba(26, 26, 36, 0.9), rgba(18, 18, 26, 0.95));
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 36px 28px;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        /* Gradient border effect */
        .game-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 20px;
            padding: 2px;
            background: linear-gradient(135deg, var(--accent), transparent 40%, transparent 60%, var(--accent-third));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        /* Glow effect on hover */
        .game-card::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0, 255, 136, 0.1) 0%, transparent 60%);
            opacity: 0;
            transition: opacity 0.4s ease;
            pointer-events: none;
        }

        .game-card:hover {
            transform: translateY(-12px) scale(1.02);
            border-color: transparent;
            box-shadow:
                0 20px 60px rgba(0, 255, 136, 0.15),
                0 8px 25px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .game-card:hover::before {
            opacity: 1;
        }

        .game-card:hover::after {
            opacity: 1;
        }

        .game-card:active {
            transform: translateY(-6px) scale(0.98);
        }

        .game-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            display: block;
            transition: all 0.4s ease;
            filter: drop-shadow(0 4px 15px rgba(0, 0, 0, 0.3));
        }

        .game-card:hover .game-icon {
            transform: scale(1.15) rotate(-5deg);
            filter: drop-shadow(0 8px 25px rgba(0, 255, 136, 0.4));
        }

        .game-card h3 {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            margin-bottom: 12px;
            color: var(--text-primary);
            transition: all 0.3s ease;
            letter-spacing: 1px;
        }

        .game-card:hover h3 {
            color: var(--accent);
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .game-card p {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-bottom: 18px;
            line-height: 1.5;
        }

        .player-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.15), rgba(0, 255, 136, 0.05));
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--accent);
            transition: all 0.3s ease;
        }

        .game-card:hover .player-badge {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.25), rgba(0, 255, 136, 0.1));
            border-color: var(--accent);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }

        /* Game Modal */
        .game-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-y: auto;
        }

        .game-modal.active {
            display: flex;
        }

        .game-container {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 16px;
            padding: 32px;
            max-width: 650px;
            width: 100%;
            text-align: center;
            position: relative;
        }

        .close-game {
            position: absolute;
            top: 16px;
            right: 16px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-game:hover {
            color: var(--accent-secondary);
        }

        .game-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--accent);
            margin-bottom: 24px;
        }

        /* Game Status */
        .game-status {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.75rem;
            color: var(--accent-third);
            margin-bottom: 20px;
            min-height: 20px;
        }

        /* P2 Mode Toggle */
        .p2-mode-toggle {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .p2-mode-toggle.hidden {
            display: none;
        }

        .p2-mode-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            color: var(--text-secondary);
        }

        .p2-toggle-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.45rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .p2-toggle-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-primary);
        }

        .p2-toggle-btn:hover:not(.active) {
            border-color: var(--accent);
            color: var(--accent);
        }

        .restart-btn {
            padding: 12px 24px;
            background: transparent;
            border: 2px solid var(--accent);
            border-radius: 8px;
            color: var(--accent);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .restart-btn:hover {
            background: var(--accent);
            color: var(--bg-primary);
        }

        /* ==================== TIC TAC TOE BOARD ==================== */
        .ttt-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        .ttt-board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            background: linear-gradient(145deg, #2d1810, #1a0f0a);
            padding: 15px;
            border-radius: 12px;
            box-shadow:
                0 10px 30px rgba(0, 0, 0, 0.5),
                inset 0 2px 4px rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .ttt-board::before {
            content: '';
            position: absolute;
            inset: 10px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            pointer-events: none;
        }

        .ttt-cell {
            width: 100px;
            height: 100px;
            background: linear-gradient(145deg, #3d2415, #2a1a10);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: bold;
            transition: all 0.2s ease;
            position: relative;
        }

        .ttt-cell:nth-child(1) { border-radius: 8px 0 0 0; }
        .ttt-cell:nth-child(3) { border-radius: 0 8px 0 0; }
        .ttt-cell:nth-child(7) { border-radius: 0 0 0 8px; }
        .ttt-cell:nth-child(9) { border-radius: 0 0 8px 0; }

        .ttt-cell:nth-child(2),
        .ttt-cell:nth-child(5),
        .ttt-cell:nth-child(8) {
            border-left: 3px solid #5a3d2a;
            border-right: 3px solid #5a3d2a;
        }

        .ttt-cell:nth-child(4),
        .ttt-cell:nth-child(5),
        .ttt-cell:nth-child(6) {
            border-top: 3px solid #5a3d2a;
            border-bottom: 3px solid #5a3d2a;
        }

        .ttt-cell:hover:not(.taken) {
            background: linear-gradient(145deg, #4d3020, #3a2515);
        }

        .ttt-cell.x::after {
            content: '‚úï';
            color: #00ff88;
            text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
            font-size: 3.5rem;
        }

        .ttt-cell.o::after {
            content: '‚óã';
            color: #ff6b6b;
            text-shadow: 0 0 20px #ff6b6b, 0 0 40px #ff6b6b;
            font-size: 4rem;
        }

        /* ==================== CONNECT FOUR BOARD ==================== */
        .c4-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        .c4-frame {
            background: linear-gradient(180deg, #1a5fb4, #0d3a7a);
            padding: 20px;
            border-radius: 16px;
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.5),
                inset 0 2px 4px rgba(255, 255, 255, 0.2),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .c4-frame::before {
            content: 'CONNECT 4';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(180deg, #ffd93d, #f0a000);
            padding: 4px 16px;
            border-radius: 4px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            color: #1a1a24;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .c4-board {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            grid-template-rows: repeat(6, 50px);
            gap: 6px;
            background: linear-gradient(180deg, #1557a0, #0a3060);
            padding: 10px;
            border-radius: 8px;
        }

        .c4-cell {
            width: 50px;
            height: 50px;
            background: linear-gradient(180deg, #0a0a15, #15152a);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow:
                inset 0 4px 8px rgba(0, 0, 0, 0.5),
                0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .c4-cell:hover:not(.taken)::after {
            content: '';
            position: absolute;
            inset: 5px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
        }

        .c4-cell.p1 {
            background: radial-gradient(circle at 30% 30%, #ff8080, #cc0000, #990000);
            box-shadow:
                inset 0 4px 8px rgba(255, 255, 255, 0.3),
                inset 0 -4px 8px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(255, 0, 0, 0.4);
        }

        .c4-cell.p2 {
            background: radial-gradient(circle at 30% 30%, #ffff80, #ffcc00, #cc9900);
            box-shadow:
                inset 0 4px 8px rgba(255, 255, 255, 0.3),
                inset 0 -4px 8px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(255, 200, 0, 0.4);
        }

        .c4-cell.dropping {
            animation: dropPiece 0.5s ease-out;
        }

        @keyframes dropPiece {
            0% { transform: translateY(-300px); }
            60% { transform: translateY(10px); }
            80% { transform: translateY(-5px); }
            100% { transform: translateY(0); }
        }

        /* Column hover indicator */
        .c4-column-indicators {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            gap: 6px;
            padding: 0 10px;
            margin-bottom: 8px;
        }

        .c4-indicator {
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .c4-indicator::after {
            content: '‚ñº';
            font-size: 1rem;
        }

        .c4-indicator.p1::after {
            color: #ff4444;
            text-shadow: 0 0 10px #ff4444;
        }

        .c4-indicator.p2::after {
            color: #ffcc00;
            text-shadow: 0 0 10px #ffcc00;
        }

        .c4-frame:hover .c4-indicator {
            opacity: 1;
        }

        /* ==================== PONG ==================== */
        .pong-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .pong-cabinet {
            background: linear-gradient(180deg, #2a2a3a, #1a1a24);
            padding: 20px;
            border-radius: 16px;
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 2px rgba(255, 255, 255, 0.1);
        }

        .pong-screen {
            background: #000;
            border-radius: 8px;
            padding: 3px;
            box-shadow:
                inset 0 0 20px rgba(0, 255, 136, 0.1),
                0 0 10px rgba(0, 0, 0, 0.5);
        }

        .pong-scores {
            display: flex;
            justify-content: space-around;
            padding: 16px 0;
            font-family: 'Press Start 2P', cursive;
        }

        .pong-score {
            font-size: 1.8rem;
        }

        .pong-score.p1 {
            color: var(--accent);
            text-shadow: 0 0 20px var(--accent);
        }

        .pong-score.p2 {
            color: var(--accent-secondary);
            text-shadow: 0 0 20px var(--accent-secondary);
        }

        #pongCanvas {
            display: block;
            border-radius: 4px;
        }

        .pong-controls {
            margin-top: 16px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .pong-controls span {
            display: inline-block;
            padding: 2px 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin: 0 4px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
        }

        /* ==================== REACTION RACE ==================== */
        .reaction-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .reaction-arena {
            background: linear-gradient(180deg, #1a1a24, #0a0a0f);
            padding: 30px 40px;
            border-radius: 16px;
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 2px rgba(255, 255, 255, 0.05);
        }

        .reaction-status {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9rem;
            color: var(--accent-third);
            min-height: 30px;
            margin-bottom: 24px;
        }

        .reaction-container {
            display: flex;
            gap: 40px;
            justify-content: center;
            margin-bottom: 24px;
        }

        .reaction-btn {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Press Start 2P', cursive;
            position: relative;
            background: linear-gradient(180deg, #3a3a4a, #2a2a3a);
            box-shadow:
                0 8px 0 #1a1a24,
                0 12px 20px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.1);
        }

        .reaction-btn::before {
            content: '';
            position: absolute;
            inset: 8px;
            border-radius: 50%;
            background: linear-gradient(180deg, #4a4a5a, #3a3a4a);
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .reaction-btn .player-label,
        .reaction-btn .key-label {
            position: relative;
            z-index: 1;
        }

        .reaction-btn .player-label {
            font-size: 0.6rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .reaction-btn .key-label {
            font-size: 1.8rem;
            color: var(--text-primary);
        }

        .reaction-btn.p1 {
            box-shadow:
                0 8px 0 #004d29,
                0 12px 20px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.1);
        }

        .reaction-btn.p1::before {
            background: linear-gradient(180deg, #00aa55, #006633);
            border: 4px solid #00ff88;
        }

        .reaction-btn.p2 {
            box-shadow:
                0 8px 0 #661a1a,
                0 12px 20px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.1);
        }

        .reaction-btn.p2::before {
            background: linear-gradient(180deg, #aa3333, #662222);
            border: 4px solid #ff6b6b;
        }

        .reaction-btn:active {
            transform: translateY(4px);
            box-shadow:
                0 4px 0 #1a1a24,
                0 6px 10px rgba(0, 0, 0, 0.4);
        }

        .reaction-btn.ready {
            animation: pulse-glow 0.5s infinite alternate;
        }

        .reaction-btn.p1.ready::before {
            background: linear-gradient(180deg, #00ff88, #00cc66);
            box-shadow:
                inset 0 4px 8px rgba(255, 255, 255, 0.3),
                0 0 30px #00ff88;
        }

        .reaction-btn.p2.ready::before {
            background: linear-gradient(180deg, #ff6b6b, #cc4444);
            box-shadow:
                inset 0 4px 8px rgba(255, 255, 255, 0.3),
                0 0 30px #ff6b6b;
        }

        @keyframes pulse-glow {
            from { filter: brightness(1); }
            to { filter: brightness(1.3); }
        }

        .reaction-scores {
            display: flex;
            justify-content: center;
            gap: 60px;
        }

        .reaction-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }

        .reaction-score.p1 {
            color: var(--accent);
        }

        .reaction-score.p2 {
            color: var(--accent-secondary);
        }

        /* ==================== SNAKE BATTLE ==================== */
        .snake-wrapper {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        #snakeCanvas {
            border: 3px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
        }

        .snake-controls {
            margin-top: 16px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .snake-controls span {
            display: inline-block;
            padding: 2px 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin: 0 2px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
        }

        /* ==================== MEMORY MATCH ==================== */
        .memory-scores {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin-bottom: 20px;
        }

        .memory-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }

        .memory-score.p1 { color: var(--accent); }
        .memory-score.p2 { color: var(--accent-secondary); }

        .memory-board {
            display: grid;
            grid-template-columns: repeat(4, 70px);
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .memory-card {
            width: 70px;
            height: 70px;
            cursor: pointer;
            position: relative;
            perspective: 600px;
        }

        .memory-front, .memory-back {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            backface-visibility: hidden;
            transition: transform 0.4s ease;
            font-size: 2rem;
        }

        .memory-front {
            background: linear-gradient(145deg, #2a2a3a, #1a1a24);
            border: 2px solid var(--border);
            color: var(--text-secondary);
            font-family: 'Press Start 2P', cursive;
        }

        .memory-back {
            background: linear-gradient(145deg, #1a3d1a, #0a2a0a);
            border: 2px solid var(--accent);
            transform: rotateY(180deg);
        }

        .memory-card.flipped .memory-front {
            transform: rotateY(180deg);
        }

        .memory-card.flipped .memory-back {
            transform: rotateY(0);
        }

        /* ==================== ROCK PAPER SCISSORS ==================== */
        .rps-scores {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin-bottom: 20px;
        }

        .rps-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }

        .rps-score.p1 { color: var(--accent); }
        .rps-score.p2 { color: var(--accent-secondary); }

        .rps-arena {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-bottom: 20px;
        }

        .rps-player {
            text-align: center;
        }

        .rps-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .rps-choice {
            width: 80px;
            height: 80px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            margin: 0 auto 15px;
        }

        .rps-vs {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--accent-third);
        }

        .rps-buttons {
            display: flex;
            gap: 8px;
        }

        .rps-buttons button {
            width: 50px;
            height: 50px;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: var(--bg-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .rps-buttons button:hover {
            border-color: var(--accent);
            transform: scale(1.1);
        }

        .rps-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ==================== TYPEWRITER ==================== */
        .typewriter-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 15px;
        }

        .typewriter-stat {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.55rem;
            color: var(--text-secondary);
        }

        .typewriter-stat span {
            color: var(--accent);
        }

        .typewriter-text {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            line-height: 1.8;
            text-align: left;
            min-height: 60px;
            letter-spacing: 1px;
        }

        .typewriter-char.correct {
            color: var(--accent);
        }

        .typewriter-char.incorrect {
            color: var(--accent-secondary);
            background: rgba(255, 107, 107, 0.3);
            border-radius: 2px;
        }

        .typewriter-char.current {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .typewriter-char.pending {
            color: var(--text-secondary);
        }

        .typewriter-input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .keyboard {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-bottom: 15px;
        }

        .keyboard-row {
            display: flex;
            gap: 4px;
        }

        .key {
            width: 28px;
            height: 32px;
            background: linear-gradient(145deg, #3a3a4a, #252530);
            border: 1px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
            font-size: 0.7rem;
            font-weight: bold;
            color: var(--text-secondary);
            transition: all 0.08s ease;
            box-shadow: 0 3px 0 #1a1a22;
        }

        .key.wide {
            width: 42px;
            font-size: 0.5rem;
        }

        .key.space {
            width: 160px;
        }

        .key.active {
            background: var(--accent);
            color: var(--bg-primary);
            box-shadow: 0 1px 0 #006644;
            transform: translateY(2px);
        }

        .key.error {
            background: var(--accent-secondary);
            color: white;
            box-shadow: 0 1px 0 #993333;
            transform: translateY(2px);
        }

        /* ==================== WHACK-A-MOLE ==================== */
        .whack-scores {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            margin-bottom: 20px;
        }

        .whack-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }

        .whack-score.p1 { color: var(--accent); }
        .whack-score.p2 { color: var(--accent-secondary); }

        .whack-timer {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            color: var(--accent-third);
            text-shadow: 0 0 10px var(--accent-third);
        }

        .whack-arena {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 20px;
        }

        .whack-side {
            text-align: center;
        }

        .whack-grid {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            gap: 10px;
            padding: 15px;
            background: linear-gradient(145deg, #3d2415, #2a1a10);
            border-radius: 12px;
        }

        .whack-hole {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at center, #1a0f0a, #0a0505);
            border-radius: 50%;
            cursor: pointer;
            position: relative;
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .whack-hole.mole::after {
            content: 'üêπ';
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            animation: mole-pop 0.2s ease-out;
        }

        .whack-hole.hit {
            background: radial-gradient(circle at center, #004400, #002200);
        }

        @keyframes mole-pop {
            from { transform: translateY(20px) scale(0.5); }
            to { transform: translateY(0) scale(1); }
        }

        /* ==================== AIR HOCKEY ==================== */
        .hockey-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .hockey-cabinet {
            background: linear-gradient(180deg, #2a2a3a, #1a1a24);
            padding: 15px;
            border-radius: 16px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
        }

        .hockey-scores {
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            font-family: 'Press Start 2P', cursive;
        }

        .hockey-score {
            font-size: 1.5rem;
        }

        .hockey-score.p1 {
            color: var(--accent);
            text-shadow: 0 0 15px var(--accent);
        }

        .hockey-score.p2 {
            color: var(--accent-secondary);
            text-shadow: 0 0 15px var(--accent-secondary);
        }

        #hockeyCanvas {
            display: block;
            border-radius: 8px;
        }

        .hockey-controls {
            margin-top: 16px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .hockey-controls span {
            display: inline-block;
            padding: 2px 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin: 0 2px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
        }

        /* ==================== BATTLESHIP ==================== */
        .battleship-arena {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .battleship-side {
            text-align: center;
        }

        .battleship-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .battleship-grid {
            display: grid;
            grid-template-columns: repeat(10, 28px);
            gap: 2px;
            background: #0a1a3a;
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #1a3a6a;
        }

        .bs-cell {
            width: 28px;
            height: 28px;
            background: linear-gradient(145deg, #1a3a6a, #0a2a4a);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .bs-cell:hover {
            background: linear-gradient(145deg, #2a4a7a, #1a3a5a);
        }

        .bs-cell.ship {
            background: linear-gradient(145deg, #4a4a5a, #3a3a4a);
        }

        .bs-cell.hit {
            background: radial-gradient(circle, #ff4444, #aa0000);
            box-shadow: 0 0 10px #ff0000;
        }

        .bs-cell.miss {
            background: linear-gradient(145deg, #1a3a6a, #0a2a4a);
            position: relative;
        }

        .bs-cell.miss::after {
            content: '‚Ä¢';
            color: #fff;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        .battleship-info {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            color: var(--accent-third);
            margin-bottom: 20px;
        }

        /* ==================== SIMON SAYS ==================== */
        .simon-scores {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin-bottom: 20px;
        }

        .simon-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }

        .simon-score.p1 { color: var(--accent); }
        .simon-score.p2 { color: var(--accent-secondary); }

        .simon-board {
            display: grid;
            grid-template-columns: repeat(4, 80px);
            gap: 8px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .simon-btn {
            width: 80px;
            height: 80px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.6;
        }

        .simon-btn[data-color="green"] { background: linear-gradient(145deg, #00aa44, #006622); }
        .simon-btn[data-color="red"] { background: linear-gradient(145deg, #cc3333, #881818); }
        .simon-btn[data-color="yellow"] { background: linear-gradient(145deg, #ccaa00, #886600); }
        .simon-btn[data-color="blue"] { background: linear-gradient(145deg, #3366cc, #1a3388); }
        .simon-btn[data-color="purple"] { background: linear-gradient(145deg, #9944cc, #662288); }
        .simon-btn[data-color="orange"] { background: linear-gradient(145deg, #dd6600, #993300); }
        .simon-btn[data-color="pink"] { background: linear-gradient(145deg, #dd4488, #992255); }
        .simon-btn[data-color="cyan"] { background: linear-gradient(145deg, #00aaaa, #006666); }
        .simon-btn[data-color="lime"] { background: linear-gradient(145deg, #88cc00, #558800); }
        .simon-btn[data-color="coral"] { background: linear-gradient(145deg, #dd5544, #993322); }
        .simon-btn[data-color="teal"] { background: linear-gradient(145deg, #338888, #225555); }
        .simon-btn[data-color="gold"] { background: linear-gradient(145deg, #ccaa33, #886611); }
        .simon-btn[data-color="indigo"] { background: linear-gradient(145deg, #4433aa, #221166); }
        .simon-btn[data-color="mint"] { background: linear-gradient(145deg, #44bb88, #227744); }
        .simon-btn[data-color="salmon"] { background: linear-gradient(145deg, #cc7766, #884433); }
        .simon-btn[data-color="violet"] { background: linear-gradient(145deg, #8844aa, #552266); }

        .simon-btn.active, .simon-btn:hover {
            opacity: 1;
            transform: scale(1.08);
        }

        .simon-btn[data-color="green"].active { box-shadow: 0 0 25px #00ff88; }
        .simon-btn[data-color="red"].active { box-shadow: 0 0 25px #ff6b6b; }
        .simon-btn[data-color="yellow"].active { box-shadow: 0 0 25px #ffd93d; }
        .simon-btn[data-color="blue"].active { box-shadow: 0 0 25px #6699ff; }
        .simon-btn[data-color="purple"].active { box-shadow: 0 0 25px #cc66ff; }
        .simon-btn[data-color="orange"].active { box-shadow: 0 0 25px #ff8833; }
        .simon-btn[data-color="pink"].active { box-shadow: 0 0 25px #ff66aa; }
        .simon-btn[data-color="cyan"].active { box-shadow: 0 0 25px #00ffff; }
        .simon-btn[data-color="lime"].active { box-shadow: 0 0 25px #aaff00; }
        .simon-btn[data-color="coral"].active { box-shadow: 0 0 25px #ff7766; }
        .simon-btn[data-color="teal"].active { box-shadow: 0 0 25px #44aaaa; }
        .simon-btn[data-color="gold"].active { box-shadow: 0 0 25px #ffcc44; }
        .simon-btn[data-color="indigo"].active { box-shadow: 0 0 25px #6655cc; }
        .simon-btn[data-color="mint"].active { box-shadow: 0 0 25px #66ddaa; }
        .simon-btn[data-color="salmon"].active { box-shadow: 0 0 25px #ee9988; }
        .simon-btn[data-color="violet"].active { box-shadow: 0 0 25px #aa66cc; }

        .simon-info {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        /* ==================== TETRIS ==================== */
        .tetris-container {
            max-width: 650px;
        }

        .tetris-wrapper {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .tetris-sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .tetris-next {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .tetris-next canvas {
            display: block;
            margin: 0 auto;
        }

        .tetris-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .tetris-stats {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .tetris-stat {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .tetris-value {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--text-primary);
        }

        .tetris-main {
            position: relative;
        }

        #tetrisCanvas {
            display: block;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--accent);
            border-radius: 4px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.2);
        }

        .tetris-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .tetris-overlay.hidden {
            display: none;
        }

        .tetris-message {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--accent);
            text-align: center;
            line-height: 2;
        }

        .tetris-controls-info {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .tetris-keys {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        /* ==================== HUNGRY HIPPOS ==================== */
        .hippos-container {
            max-width: 600px;
        }

        .hippos-scores {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            gap: 20px;
        }

        .hippos-score {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }

        .hippos-score.p1 {
            color: var(--accent);
            border: 2px solid var(--accent);
        }

        .hippos-score.p2 {
            color: var(--accent-secondary);
            border: 2px solid var(--accent-secondary);
        }

        .hippo-icon {
            font-size: 1.5rem;
        }

        .hippo-icon.flip {
            transform: scaleX(-1);
        }

        .hippos-key {
            font-size: 0.5rem;
            opacity: 0.7;
            margin-left: auto;
        }

        .hippos-arena {
            position: relative;
            margin-bottom: 15px;
        }

        #hipposCanvas {
            display: block;
            margin: 0 auto;
            background: #1a1a2e;
            border: 3px solid var(--accent);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.2);
        }

        .hippos-timer {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 15px;
        }

        /* ==================== HEADER ACTIONS ==================== */
        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .settings-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.3rem;
        }

        .settings-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--accent);
            transform: rotate(45deg);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .multiplayer-btn {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 12px 24px;
            background: linear-gradient(135deg, var(--accent), #00cc6a);
            border: none;
            border-radius: 12px;
            color: #000;
            font-weight: 700;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .multiplayer-btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.6), 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .multiplayer-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        .multiplayer-btn.connected {
            background: linear-gradient(135deg, #ffd93d, #ffaa00);
            box-shadow: 0 0 30px rgba(255, 217, 61, 0.5);
            animation: connectedPulse 2s ease-in-out infinite;
        }

        @keyframes connectedPulse {
            0%, 100% { box-shadow: 0 0 30px rgba(255, 217, 61, 0.5); }
            50% { box-shadow: 0 0 50px rgba(255, 217, 61, 0.8); }
        }

        .mp-icon {
            font-size: 1.2rem;
        }

        /* ==================== SETTINGS MODAL ==================== */
        .settings-container {
            max-width: 400px;
        }

        .settings-group {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .setting-row:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(0, 255, 136, 0.3);
        }

        .setting-label {
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-primary);
            font-weight: 500;
        }

        .setting-icon {
            font-size: 1.3rem;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 52px;
            height: 28px;
            cursor: pointer;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 28px;
            transition: all 0.3s ease;
        }

        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            left: 3px;
            bottom: 3px;
            background: var(--text-secondary);
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: var(--accent);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);
        }

        .toggle-switch input:checked + .toggle-slider::before {
            transform: translateX(24px);
            background: #fff;
        }

        /* Volume Slider */
        .volume-row {
            flex-direction: column;
            align-items: flex-start;
            gap: 12px;
        }

        .volume-control {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .volume-control input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }

        .volume-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.2s ease;
        }

        .volume-control input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        .volume-control input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .volume-value {
            min-width: 45px;
            text-align: right;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            color: var(--accent);
        }

        /* ==================== MULTIPLAYER LOBBY ==================== */
        .lobby-container {
            max-width: 450px;
        }

        .lobby-status {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.65rem;
            color: var(--text-secondary);
            margin-bottom: 20px;
            line-height: 1.6;
        }

        /* Name Input */
        .name-input-section {
            margin-bottom: 20px;
        }

        .name-input-group {
            text-align: center;
        }

        .name-input-group label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .name-input-group input {
            width: 200px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1rem;
            text-align: center;
        }

        .name-input-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .lobby-options {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .lobby-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 24px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .lobby-btn:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .lobby-btn.create:hover {
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.2);
        }

        .lobby-btn.join:hover {
            border-color: var(--accent-third);
            box-shadow: 0 0 30px rgba(255, 217, 61, 0.2);
        }

        .lobby-btn-icon {
            font-size: 2rem;
        }

        .lobby-btn-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: var(--text-primary);
        }

        .lobby-btn-desc {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Room Display */
        .lobby-room {
            text-align: center;
        }

        .room-code-display {
            background: var(--bg-secondary);
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .room-label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .room-code {
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            color: var(--accent);
            letter-spacing: 8px;
            text-shadow: 0 0 20px var(--accent);
        }

        .room-actions {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 24px;
        }

        .room-action-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 10px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .room-action-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .connection-status {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .player-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .player-indicator.p1 {
            border-left: 3px solid var(--accent);
        }

        .player-indicator.p2 {
            border-left: 3px solid var(--accent-secondary);
        }

        .player-role {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            color: var(--text-secondary);
        }

        .player-name {
            flex: 1;
            text-align: right;
            font-weight: 600;
            color: var(--text-primary);
        }

        .player-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--border);
        }

        .player-dot.connected {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Connected Players Display */
        .connected-players {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 12px;
        }

        .connected-player {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .connected-player.p1 .player-badge-small {
            background: var(--accent);
        }

        .connected-player.p2 .player-badge-small {
            background: var(--accent-secondary);
        }

        .player-badge-small {
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            color: #000;
        }

        .vs-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            color: var(--accent-third);
        }

        /* Game invite notification */
        .game-invite {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-card);
            border: 2px solid var(--accent);
            border-radius: 16px;
            padding: 30px;
            text-align: center;
            z-index: 10000;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.3);
            animation: bounceIn 0.3s ease-out;
        }

        .game-invite-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: var(--accent);
            margin-bottom: 16px;
        }

        .game-invite-game {
            font-size: 3rem;
            margin-bottom: 8px;
        }

        .game-invite-name {
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        .game-invite-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .game-invite-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .game-invite-btn.accept {
            background: var(--accent);
            color: #000;
        }

        .game-invite-btn.decline {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .game-invite-btn:hover {
            transform: scale(1.05);
        }

        /* Join Input */
        .lobby-join {
            text-align: center;
        }

        .join-input-group {
            margin-bottom: 20px;
        }

        .join-input-group label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .join-input-group input {
            width: 200px;
            padding: 16px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        .join-input-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .lobby-back-btn {
            display: block;
            margin: 16px auto 0;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .lobby-back-btn:hover {
            color: var(--accent);
        }

        /* Connected State */
        .lobby-connected {
            text-align: center;
        }

        .connected-message {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2rem;
            color: var(--accent);
            margin-bottom: 16px;
        }

        .connected-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: var(--accent);
            color: #000;
            border-radius: 50%;
            font-size: 1.2rem;
        }

        .connected-hint {
            color: var(--text-secondary);
            margin-bottom: 24px;
        }

        /* Connecting Spinner */
        .lobby-connecting {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            color: var(--text-secondary);
        }

        .connecting-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Multiplayer indicator on game cards */
        .game-card.mp-active {
            border-color: var(--accent);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
            animation: mpActivePulse 2s ease-in-out infinite;
        }

        @keyframes mpActivePulse {
            0%, 100% { box-shadow: 0 0 30px rgba(0, 255, 136, 0.3); }
            50% { box-shadow: 0 0 50px rgba(0, 255, 136, 0.5); }
        }

        .game-card .mp-badge {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 4px 8px;
            background: var(--accent);
            color: #000;
            font-size: 0.65rem;
            font-weight: 600;
            border-radius: 4px;
        }

        .game-card.mp-active .mp-badge {
            display: block;
        }

        /* ==================== ENHANCED ANIMATIONS ==================== */
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }

        @keyframes bounceIn {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 20px currentColor; }
            50% { box-shadow: 0 0 40px currentColor, 0 0 60px currentColor; }
        }

        @keyframes shimmer {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }

        @keyframes wobble {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }

        @keyframes scorePopIn {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); color: #ffd93d; }
            100% { transform: scale(1); }
        }

        @keyframes winCelebration {
            0% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.1) rotate(-3deg); }
            50% { transform: scale(1.2) rotate(0deg); }
            75% { transform: scale(1.1) rotate(3deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        /* Enhanced game elements */
        .game-status.winner {
            animation: winCelebration 0.5s ease-in-out;
            color: var(--accent) !important;
        }

        .score-pop {
            animation: scorePopIn 0.3s ease-out;
        }

        .ttt-cell.winning {
            animation: pulseGlow 1s infinite;
            color: var(--accent);
        }

        .c4-cell.winning {
            animation: pulseGlow 1s infinite;
            transform: scale(1.1);
        }

        /* Enhanced hover effects */
        .game-card {
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .game-card:hover {
            transform: translateY(-8px) scale(1.02);
        }

        .game-card:active {
            transform: translateY(-2px) scale(0.98);
        }

        /* Button press effect */
        .restart-btn {
            transition: all 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--accent);
        }

        .restart-btn:active {
            transform: scale(0.95);
        }

        /* Enhanced memory cards */
        .memory-card {
            transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .memory-card.matched .memory-back {
            animation: bounceIn 0.5s ease-out;
            background: linear-gradient(145deg, #00ff88, #00cc66);
        }

        /* RPS animations */
        .rps-choice.revealed {
            animation: bounceIn 0.5s ease-out;
        }

        /* Reaction button glow */
        .reaction-btn.winner {
            animation: pulseGlow 1s infinite;
        }

        /* Footer */
        footer {
            padding: 24px 0;
            border-top: 1px solid var(--border);
            text-align: center;
        }

        footer p {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        footer a {
            color: var(--accent);
            text-decoration: none;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .ttt-board {
                grid-template-columns: repeat(3, 80px);
                grid-template-rows: repeat(3, 80px);
            }

            .ttt-cell {
                width: 80px;
                height: 80px;
            }

            .c4-board {
                grid-template-columns: repeat(7, 38px);
                grid-template-rows: repeat(6, 38px);
            }

            .c4-cell {
                width: 38px;
                height: 38px;
            }

            .c4-column-indicators {
                grid-template-columns: repeat(7, 38px);
            }

            .reaction-container {
                flex-direction: column;
                gap: 24px;
            }

            .reaction-btn {
                width: 120px;
                height: 120px;
            }

            .pong-cabinet {
                padding: 10px;
            }

            #pongCanvas {
                max-width: 100%;
                height: auto;
            }
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        @media (pointer: coarse), (max-width: 768px) {
            .mobile-controls {
                display: flex !important;
            }
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #00ff88;
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            transition: all 0.1s;
        }

        .mobile-btn:active, .mobile-btn.pressed {
            background: rgba(0, 255, 136, 0.5);
            transform: scale(0.95);
        }

        .mobile-btn.red {
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
        }

        .mobile-btn.red:active, .mobile-btn.red.pressed {
            background: rgba(255, 107, 107, 0.5);
        }

        .mobile-btn.blue {
            border-color: #6b9fff;
            background: rgba(107, 159, 255, 0.2);
            color: #6b9fff;
        }

        .mobile-btn.blue:active, .mobile-btn.blue.pressed {
            background: rgba(107, 159, 255, 0.5);
        }

        .mobile-dpad {
            display: grid;
            grid-template-columns: 50px 50px 50px;
            grid-template-rows: 50px 50px 50px;
            gap: 5px;
        }

        .mobile-dpad .mobile-btn {
            width: 50px;
            height: 50px;
            border-radius: 8px;
        }

        .mobile-dpad .up { grid-column: 2; grid-row: 1; }
        .mobile-dpad .down { grid-column: 2; grid-row: 3; }
        .mobile-dpad .left { grid-column: 1; grid-row: 2; }
        .mobile-dpad .right { grid-column: 3; grid-row: 2; }

        .mobile-controls-row {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
        }

        .mobile-action-btn {
            width: 80px;
            height: 80px;
            font-size: 14px;
            border-radius: 12px;
        }

        .touch-slider {
            width: 100%;
            height: 80px;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 10px;
            position: relative;
            touch-action: none;
        }

        .touch-slider.red {
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        .touch-slider-thumb {
            width: 40px;
            height: 70px;
            background: #00ff88;
            border-radius: 8px;
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
        }

        .touch-slider.red .touch-slider-thumb {
            background: #ff6b6b;
        }

        .mobile-paddle-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 300px;
            margin: 0 auto;
        }

        .mobile-paddle-label {
            text-align: center;
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <!-- Floating particles -->
    <div class="particles" id="particles"></div>

    <header>
        <div class="container">
            <a href="index.html" class="logo">ARCADE</a>
            <div class="header-actions">
                <button class="settings-btn" onclick="openSettings()">
                    <span>‚öôÔ∏è</span>
                </button>
                <button class="multiplayer-btn" onclick="openLobby()">
                    <span class="mp-icon">üë•</span>
                    <span>Multiplayer</span>
                </button>
                <a href="index.html" class="back-btn">
                    <span>&larr;</span>
                    <span>Back to Resume</span>
                </a>
            </div>
        </div>
    </header>

    <section class="hero">
        <div class="container">
            <div class="secret-badge">üéÆ SECRET ZONE üéÆ</div>
            <h1>RYAN'S ARCADE</h1>
            <div class="hero-subtitle">PRESS START TO PLAY</div>
            <p>You found the secret games! Grab a friend and have some fun.</p>
            <div class="hero-stats">
                <div class="hero-stat">
                    <span class="hero-stat-value">15</span>
                    <div class="hero-stat-label">Games</div>
                </div>
                <div class="hero-stat">
                    <span class="hero-stat-value">2P</span>
                    <div class="hero-stat-label">Multiplayer</div>
                </div>
                <div class="hero-stat">
                    <span class="hero-stat-value">‚àû</span>
                    <div class="hero-stat-label">Fun</div>
                </div>
            </div>
        </div>
    </section>

    <section class="games-section">
        <div class="container">
            <div class="games-grid">
                <div class="game-card" onclick="openGame('tictactoe')">
                    <div class="game-icon">‚≠ï</div>
                    <h3>TIC TAC TOE</h3>
                    <p>The classic game of X's and O's</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('connect4')">
                    <div class="game-icon">üî¥</div>
                    <h3>CONNECT FOUR</h3>
                    <p>Get four in a row to win</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('pong')">
                    <div class="game-icon">üèì</div>
                    <h3>PONG</h3>
                    <p>Retro paddle battle</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('reaction')">
                    <div class="game-icon">‚ö°</div>
                    <h3>REACTION RACE</h3>
                    <p>Test your reflexes!</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('snake')">
                    <div class="game-icon">üêç</div>
                    <h3>SNAKE BATTLE</h3>
                    <p>Last snake alive wins!</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('memory')">
                    <div class="game-icon">üÉè</div>
                    <h3>MEMORY MATCH</h3>
                    <p>Find the matching pairs</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('rps')">
                    <div class="game-icon">‚úä</div>
                    <h3>ROCK PAPER SCISSORS</h3>
                    <p>Best of 5 showdown</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('typing')">
                    <div class="game-icon">‚å®Ô∏è</div>
                    <h3>TYPEWRITER</h3>
                    <p>Test your typing speed!</p>
                    <span class="player-badge">1 Player</span>
                </div>

                <div class="game-card" onclick="openGame('whack')">
                    <div class="game-icon">üî®</div>
                    <h3>WHACK-A-MOLE</h3>
                    <p>Smash the most moles!</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('airhockey')">
                    <div class="game-icon">üèí</div>
                    <h3>AIR HOCKEY</h3>
                    <p>Fast-paced puck action</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('battleship')">
                    <div class="game-icon">üö¢</div>
                    <h3>BATTLESHIP</h3>
                    <p>Sink the enemy fleet</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('simon')">
                    <div class="game-icon">üéµ</div>
                    <h3>SIMON SAYS</h3>
                    <p>Memory pattern challenge</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('tetris')">
                    <div class="game-icon">üß±</div>
                    <h3>TETRIS</h3>
                    <p>Classic block stacking puzzle</p>
                    <span class="player-badge">1 Player</span>
                </div>

                <div class="game-card" onclick="openGame('hippos')">
                    <div class="game-icon">ü¶õ</div>
                    <h3>HUNGRY HIPPOS</h3>
                    <p>Chomp the most food to win!</p>
                    <span class="player-badge">2 Players</span>
                </div>
            </div>
        </div>
    </section>

    <!-- Tic Tac Toe Modal -->
    <div class="game-modal" id="tictactoeModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('tictactoe')">&times;</button>
            <h2 class="game-title">TIC TAC TOE</h2>
            <div class="p2-mode-toggle" id="tttP2Toggle">
                <span class="p2-mode-label">P2:</span>
                <button class="p2-toggle-btn active" onclick="setP2Mode('tictactoe', 'ai')">AI</button>
                <button class="p2-toggle-btn" onclick="setP2Mode('tictactoe', 'manual')">2P</button>
            </div>
            <div class="game-status" id="tttStatus">Player X's turn</div>
            <div class="ttt-wrapper">
                <div class="ttt-board" id="tttBoard"></div>
            </div>
            <button class="restart-btn" onclick="initTTT()">RESTART</button>
        </div>
    </div>

    <!-- Connect Four Modal -->
    <div class="game-modal" id="connect4Modal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('connect4')">&times;</button>
            <h2 class="game-title">CONNECT FOUR</h2>
            <div class="p2-mode-toggle" id="c4P2Toggle">
                <span class="p2-mode-label">P2:</span>
                <button class="p2-toggle-btn active" onclick="setP2Mode('connect4', 'ai')">AI</button>
                <button class="p2-toggle-btn" onclick="setP2Mode('connect4', 'manual')">2P</button>
            </div>
            <div class="game-status" id="c4Status">üî¥ Player 1's turn</div>
            <div class="c4-wrapper">
                <div class="c4-frame">
                    <div class="c4-column-indicators" id="c4Indicators"></div>
                    <div class="c4-board" id="c4Board"></div>
                </div>
            </div>
            <button class="restart-btn" onclick="initC4()">RESTART</button>
        </div>
    </div>

    <!-- Pong Modal -->
    <div class="game-modal" id="pongModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('pong')">&times;</button>
            <h2 class="game-title">PONG</h2>
            <div class="p2-mode-toggle" id="pongP2Toggle">
                <span class="p2-mode-label">P2:</span>
                <button class="p2-toggle-btn active" onclick="setP2Mode('pong', 'ai')">AI</button>
                <button class="p2-toggle-btn" onclick="setP2Mode('pong', 'manual')">2P</button>
            </div>
            <div class="pong-wrapper">
                <div class="pong-cabinet">
                    <div class="pong-scores">
                        <span class="pong-score p1" id="p1Score">0</span>
                        <span class="pong-score p2" id="p2Score">0</span>
                    </div>
                    <div class="pong-screen">
                        <canvas id="pongCanvas" width="480" height="280"></canvas>
                    </div>
                </div>
                <div class="pong-controls">
                    <p>Player 1: <span>W</span> / <span>S</span> &nbsp;&nbsp; Player 2: <span>‚Üë</span> / <span>‚Üì</span></p>
                </div>
                <div class="mobile-controls" id="pongMobileControls">
                    <div class="mobile-controls-row">
                        <div style="text-align: center;">
                            <div class="mobile-paddle-label">P1</div>
                            <div style="display: flex; flex-direction: column; gap: 5px;">
                                <button class="mobile-btn" id="pongP1Up">‚ñ≤</button>
                                <button class="mobile-btn" id="pongP1Down">‚ñº</button>
                            </div>
                        </div>
                        <div style="text-align: center;">
                            <div class="mobile-paddle-label">P2</div>
                            <div style="display: flex; flex-direction: column; gap: 5px;">
                                <button class="mobile-btn red" id="pongP2Up">‚ñ≤</button>
                                <button class="mobile-btn red" id="pongP2Down">‚ñº</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <button class="restart-btn" onclick="resetPong()">RESTART</button>
        </div>
    </div>

    <!-- Reaction Race Modal -->
    <div class="game-modal" id="reactionModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('reaction')">&times;</button>
            <h2 class="game-title">REACTION RACE</h2>
            <div class="reaction-wrapper">
                <div class="reaction-arena">
                    <div class="reaction-status" id="reactionStatus">Press START to begin!</div>
                    <div class="reaction-container">
                        <button class="reaction-btn p1" id="reactionP1">
                            <span class="player-label">P1</span>
                            <span class="key-label">Q</span>
                        </button>
                        <button class="reaction-btn p2" id="reactionP2">
                            <span class="player-label">P2</span>
                            <span class="key-label">P</span>
                        </button>
                    </div>
                    <div class="reaction-scores">
                        <span class="reaction-score p1">P1: <span id="reactionScore1">0</span></span>
                        <span class="reaction-score p2">P2: <span id="reactionScore2">0</span></span>
                    </div>
                </div>
            </div>
            <button class="restart-btn" onclick="startReaction()">START</button>
        </div>
    </div>

    <!-- Multiplayer Lobby Modal -->
    <div class="game-modal" id="lobbyModal">
        <div class="game-container lobby-container">
            <button class="close-game" onclick="closeLobby()">&times;</button>
            <h2 class="game-title">MULTIPLAYER LOBBY</h2>

            <div class="lobby-status" id="lobbyStatus">Choose an option to play with a friend!</div>

            <!-- Name Input -->
            <div class="name-input-section" id="nameInputSection">
                <div class="name-input-group">
                    <label>Your Name</label>
                    <input type="text" id="playerNameInput" maxlength="12" placeholder="Enter name..." autocomplete="off">
                </div>
            </div>

            <div class="lobby-options" id="lobbyOptions">
                <button class="lobby-btn create" onclick="createRoom()">
                    <span class="lobby-btn-icon">üéÆ</span>
                    <span class="lobby-btn-text">Create Room</span>
                    <span class="lobby-btn-desc">Host a game for your friend to join</span>
                </button>
                <button class="lobby-btn join" onclick="showJoinInput()">
                    <span class="lobby-btn-icon">üîó</span>
                    <span class="lobby-btn-text">Join Room</span>
                    <span class="lobby-btn-desc">Enter a room code to join</span>
                </button>
            </div>

            <div class="lobby-room" id="lobbyRoom" style="display: none;">
                <div class="room-code-display">
                    <span class="room-label">Room Code</span>
                    <span class="room-code" id="roomCode">------</span>
                </div>
                <div class="room-actions">
                    <button class="room-action-btn" onclick="copyRoomCode()">
                        <span>üìã</span> Copy Code
                    </button>
                    <button class="room-action-btn" onclick="copyRoomLink()">
                        <span>üîó</span> Copy Link
                    </button>
                </div>
                <div class="connection-status">
                    <div class="player-indicator p1">
                        <span class="player-dot connected"></span>
                        <span class="player-role">P1 (Host)</span>
                        <span class="player-name" id="hostNameDisplay">You</span>
                    </div>
                    <div class="player-indicator p2" id="guestIndicator">
                        <span class="player-dot" id="guestDot"></span>
                        <span class="player-role">P2</span>
                        <span class="player-name" id="guestLabel">Waiting...</span>
                    </div>
                </div>
            </div>

            <div class="lobby-join" id="lobbyJoin" style="display: none;">
                <div class="join-input-group">
                    <label>Enter Room Code</label>
                    <input type="text" id="joinCodeInput" maxlength="6" placeholder="ABC123" autocomplete="off">
                </div>
                <button class="restart-btn" onclick="joinRoom()">JOIN</button>
                <button class="lobby-back-btn" onclick="showLobbyOptions()">‚Üê Back</button>
            </div>

            <div class="lobby-connected" id="lobbyConnected" style="display: none;">
                <div class="connected-message">
                    <span class="connected-icon">‚úì</span>
                    <span>Connected!</span>
                </div>
                <div class="connected-players">
                    <div class="connected-player p1">
                        <span class="player-badge-small">P1</span>
                        <span id="connectedP1Name">Host</span>
                    </div>
                    <span class="vs-text">VS</span>
                    <div class="connected-player p2">
                        <span class="player-badge-small">P2</span>
                        <span id="connectedP2Name">Guest</span>
                    </div>
                </div>
                <p class="connected-hint">Select a game to play together</p>
                <button class="restart-btn" onclick="closeLobby()">CHOOSE GAME</button>
            </div>

            <div class="lobby-connecting" id="lobbyConnecting" style="display: none;">
                <div class="connecting-spinner"></div>
                <span>Connecting...</span>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="game-modal" id="settingsModal">
        <div class="game-container settings-container">
            <button class="close-game" onclick="closeSettings()">&times;</button>
            <h2 class="game-title">SETTINGS</h2>

            <div class="settings-group">
                <div class="setting-row">
                    <div class="setting-label">
                        <span class="setting-icon">üéµ</span>
                        <span>Background Music</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="musicToggle" onchange="toggleMusicSetting()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>

                <div class="setting-row">
                    <div class="setting-label">
                        <span class="setting-icon">üîä</span>
                        <span>Sound Effects</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="soundToggle" onchange="toggleSoundSetting()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>

                <div class="setting-row volume-row">
                    <div class="setting-label">
                        <span class="setting-icon">üì¢</span>
                        <span>SFX Volume</span>
                    </div>
                    <div class="volume-control">
                        <input type="range" id="sfxVolume" min="0" max="100" value="30" oninput="setSfxVolume(this.value)">
                        <span class="volume-value" id="sfxVolumeValue">30%</span>
                    </div>
                </div>

                <div class="setting-row volume-row">
                    <div class="setting-label">
                        <span class="setting-icon">üé∂</span>
                        <span>Music Volume</span>
                    </div>
                    <div class="volume-control">
                        <input type="range" id="musicVolume" min="0" max="100" value="3" oninput="setMusicVolume(this.value)">
                        <span class="volume-value" id="musicVolumeValue">3%</span>
                    </div>
                </div>
            </div>

            <button class="restart-btn" onclick="closeSettings()">DONE</button>
        </div>
    </div>

    <footer>
        <div class="container">
            <p>Have Fun!</p>
        </div>
    </footer>

    <script>
        // ==================== PARTICLE SYSTEM ====================
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.canvas = null;
                this.ctx = null;
            }

            init(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (this.canvas) {
                    this.ctx = this.canvas.getContext('2d');
                }
            }

            emit(x, y, options = {}) {
                const defaults = {
                    count: 10,
                    speed: 3,
                    size: 4,
                    color: '#00ff88',
                    lifetime: 60,
                    gravity: 0.1,
                    spread: Math.PI * 2,
                    type: 'circle' // circle, square, star
                };
                const opts = { ...defaults, ...options };

                for (let i = 0; i < opts.count; i++) {
                    const angle = (Math.random() - 0.5) * opts.spread;
                    const speed = opts.speed * (0.5 + Math.random() * 0.5);
                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: opts.size * (0.5 + Math.random() * 0.5),
                        color: opts.color,
                        life: opts.lifetime,
                        maxLife: opts.lifetime,
                        gravity: opts.gravity,
                        type: opts.type
                    });
                }
            }

            trail(x, y, color = '#fff', size = 3) {
                this.particles.push({
                    x, y, vx: 0, vy: 0,
                    size, color,
                    life: 15, maxLife: 15,
                    gravity: 0, type: 'circle'
                });
            }

            confetti(x, y, count = 50) {
                const colors = ['#00ff88', '#ff6b6b', '#ffd93d', '#6b9fff', '#ff6bff'];
                for (let i = 0; i < count; i++) {
                    const angle = (Math.random() - 0.5) * Math.PI;
                    const speed = 2 + Math.random() * 4;
                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: -Math.abs(Math.sin(angle) * speed) - 2,
                        size: 4 + Math.random() * 4,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        life: 120,
                        maxLife: 120,
                        gravity: 0.15,
                        type: 'square',
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.3
                    });
                }
            }

            explosion(x, y, color = '#ff6b6b', count = 20) {
                this.emit(x, y, { count, color, speed: 5, lifetime: 40, gravity: 0.05 });
            }

            update() {
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += p.gravity;
                    p.life--;
                    if (p.rotation !== undefined) {
                        p.rotation += p.rotationSpeed;
                    }
                    return p.life > 0;
                });
            }

            draw(ctx) {
                const context = ctx || this.ctx;
                if (!context) return;

                this.particles.forEach(p => {
                    const alpha = p.life / p.maxLife;
                    context.globalAlpha = alpha;
                    context.fillStyle = p.color;

                    if (p.type === 'circle') {
                        context.beginPath();
                        context.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        context.fill();
                    } else if (p.type === 'square') {
                        context.save();
                        context.translate(p.x, p.y);
                        if (p.rotation !== undefined) context.rotate(p.rotation);
                        context.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                        context.restore();
                    } else if (p.type === 'star') {
                        this.drawStar(context, p.x, p.y, 5, p.size, p.size/2);
                    }
                });
                context.globalAlpha = 1;
            }

            drawStar(ctx, x, y, points, outer, inner) {
                ctx.beginPath();
                for (let i = 0; i < points * 2; i++) {
                    const r = i % 2 === 0 ? outer : inner;
                    const angle = (i * Math.PI) / points - Math.PI / 2;
                    const px = x + Math.cos(angle) * r;
                    const py = y + Math.sin(angle) * r;
                    i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
            }

            clear() {
                this.particles = [];
            }
        }

        // Global particle systems for different canvases
        const particles = {
            pong: new ParticleSystem(),
            snake: new ParticleSystem(),
            hockey: new ParticleSystem()
        };

        // ==================== SOUND MANAGER ====================
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.enabled = true;
                this.musicEnabled = true;
                this.volume = 0.3;
                this.musicVolume = 0.03;
                this.sounds = {};
                this.musicNodes = [];
                this.musicPlaying = false;
            }

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    // Auto-start music if enabled
                    if (this.musicEnabled && !this.musicPlaying) {
                        this.startMusic();
                    }
                } catch (e) {
                    console.log('Web Audio not supported');
                    this.enabled = false;
                }
            }

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            // Upbeat but soft arcade music - 3 minute song
            startMusic() {
                if (!this.ctx || this.musicPlaying || !this.musicEnabled) return;
                this.resume();
                this.musicPlaying = true;

                // Master gain node for real-time volume control
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                this.masterGain.gain.value = this.musicVolume;

                const master = this.masterGain;

                // Play a melodic note - soft with smooth envelope
                const playNote = (freq, startTime, duration, type = 'triangle', volume = 0.3) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.connect(gain);
                    gain.connect(master);

                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, startTime);

                    // Soft attack and release
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(volume, startTime + 0.04);
                    gain.gain.setValueAtTime(volume * 0.85, startTime + duration * 0.5);
                    gain.gain.linearRampToValueAtTime(0, startTime + duration);

                    osc.start(startTime);
                    osc.stop(startTime + duration + 0.1);
                };

                // Soft drum sounds
                const playDrum = (startTime, type = 'kick') => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.connect(gain);
                    gain.connect(master);

                    if (type === 'kick') {
                        osc.frequency.setValueAtTime(70, startTime);
                        osc.frequency.exponentialRampToValueAtTime(35, startTime + 0.1);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.35, startTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.1);
                        osc.start(startTime);
                        osc.stop(startTime + 0.1);
                    } else if (type === 'tick') {
                        osc.frequency.setValueAtTime(1000, startTime);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.05, startTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.02);
                        osc.start(startTime);
                        osc.stop(startTime + 0.02);
                    } else if (type === 'snap') {
                        osc.frequency.setValueAtTime(1800, startTime);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.08, startTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.04);
                        osc.start(startTime);
                        osc.stop(startTime + 0.04);
                    }
                };

                const bpm = 132;  // Slightly faster tempo
                const beat = 60 / bpm;
                const bar = beat * 4;

                // ========== SECTION DEFINITIONS ==========

                // Section A - Main Theme (Bright & Hopeful)
                const sectionA = {
                    melody: [
                        { note: 523, time: 0, dur: beat },              // C5
                        { note: 659, time: beat, dur: beat * 0.75 },    // E5
                        { note: 784, time: beat * 2, dur: beat * 1.5 }, // G5
                        { note: 659, time: beat * 3.5, dur: beat * 0.5 },
                        { note: 698, time: bar, dur: beat },            // F5
                        { note: 880, time: bar + beat, dur: beat },     // A5
                        { note: 784, time: bar + beat * 2, dur: beat * 2 },
                        { note: 880, time: bar * 2, dur: beat },
                        { note: 784, time: bar * 2 + beat, dur: beat },
                        { note: 659, time: bar * 2 + beat * 2, dur: beat },
                        { note: 784, time: bar * 2 + beat * 3, dur: beat },
                        { note: 659, time: bar * 3, dur: beat * 1.5 },
                        { note: 523, time: bar * 3 + beat * 2, dur: beat * 2 },
                    ],
                    bass: [
                        { note: 131, time: 0, dur: beat * 3 },
                        { note: 165, time: beat * 3, dur: beat },
                        { note: 175, time: bar, dur: beat * 2 },
                        { note: 131, time: bar + beat * 2, dur: beat * 2 },
                        { note: 175, time: bar * 2, dur: beat * 2 },
                        { note: 196, time: bar * 2 + beat * 2, dur: beat * 2 },
                        { note: 131, time: bar * 3, dur: beat * 4 },
                    ],
                    drums: 'standard'
                };

                // Section B - Rising Energy
                const sectionB = {
                    melody: [
                        { note: 659, time: 0, dur: beat * 0.5 },        // E5
                        { note: 784, time: beat * 0.5, dur: beat * 0.5 },
                        { note: 880, time: beat, dur: beat },           // A5
                        { note: 784, time: beat * 2, dur: beat * 0.5 },
                        { note: 880, time: beat * 2.5, dur: beat * 0.5 },
                        { note: 988, time: beat * 3, dur: beat },       // B5
                        { note: 1047, time: bar, dur: beat * 1.5 },     // C6
                        { note: 988, time: bar + beat * 2, dur: beat },
                        { note: 880, time: bar + beat * 3, dur: beat },
                        { note: 784, time: bar * 2, dur: beat },
                        { note: 880, time: bar * 2 + beat, dur: beat * 0.5 },
                        { note: 784, time: bar * 2 + beat * 1.5, dur: beat * 0.5 },
                        { note: 659, time: bar * 2 + beat * 2, dur: beat * 2 },
                        { note: 784, time: bar * 3, dur: beat * 2 },
                        { note: 659, time: bar * 3 + beat * 2, dur: beat * 2 },
                    ],
                    bass: [
                        { note: 165, time: 0, dur: beat * 2 },          // E3
                        { note: 196, time: beat * 2, dur: beat * 2 },   // G3
                        { note: 220, time: bar, dur: beat * 2 },        // A3
                        { note: 196, time: bar + beat * 2, dur: beat * 2 },
                        { note: 175, time: bar * 2, dur: beat * 2 },    // F3
                        { note: 165, time: bar * 2 + beat * 2, dur: beat * 2 },
                        { note: 131, time: bar * 3, dur: beat * 4 },
                    ],
                    drums: 'upbeat'
                };

                // Section C - Gentle Bridge
                const sectionC = {
                    melody: [
                        { note: 440, time: 0, dur: beat * 2 },          // A4
                        { note: 523, time: beat * 2, dur: beat * 2 },   // C5
                        { note: 587, time: bar, dur: beat * 2 },        // D5
                        { note: 523, time: bar + beat * 2, dur: beat * 2 },
                        { note: 494, time: bar * 2, dur: beat * 2 },    // B4
                        { note: 523, time: bar * 2 + beat * 2, dur: beat },
                        { note: 587, time: bar * 2 + beat * 3, dur: beat },
                        { note: 659, time: bar * 3, dur: beat * 2 },    // E5
                        { note: 523, time: bar * 3 + beat * 2, dur: beat * 2 },
                    ],
                    bass: [
                        { note: 110, time: 0, dur: beat * 4 },          // A2
                        { note: 131, time: bar, dur: beat * 4 },        // C3
                        { note: 147, time: bar * 2, dur: beat * 4 },    // D3
                        { note: 165, time: bar * 3, dur: beat * 4 },    // E3
                    ],
                    drums: 'sparse'
                };

                // Section D - Climax
                const sectionD = {
                    melody: [
                        { note: 784, time: 0, dur: beat * 0.5 },        // G5
                        { note: 880, time: beat * 0.5, dur: beat * 0.5 },
                        { note: 988, time: beat, dur: beat * 0.5 },     // B5
                        { note: 1047, time: beat * 1.5, dur: beat * 1.5 }, // C6
                        { note: 1175, time: beat * 3, dur: beat },      // D6
                        { note: 1047, time: bar, dur: beat },
                        { note: 988, time: bar + beat, dur: beat },
                        { note: 880, time: bar + beat * 2, dur: beat },
                        { note: 784, time: bar + beat * 3, dur: beat },
                        { note: 880, time: bar * 2, dur: beat * 2 },
                        { note: 784, time: bar * 2 + beat * 2, dur: beat * 2 },
                        { note: 659, time: bar * 3, dur: beat * 2 },
                        { note: 523, time: bar * 3 + beat * 2, dur: beat * 2 },
                    ],
                    bass: [
                        { note: 196, time: 0, dur: beat * 2 },          // G3
                        { note: 220, time: beat * 2, dur: beat * 2 },   // A3
                        { note: 175, time: bar, dur: beat * 2 },        // F3
                        { note: 165, time: bar + beat * 2, dur: beat * 2 },
                        { note: 175, time: bar * 2, dur: beat * 2 },
                        { note: 196, time: bar * 2 + beat * 2, dur: beat * 2 },
                        { note: 131, time: bar * 3, dur: beat * 4 },
                    ],
                    drums: 'full'
                };

                // Section E - Outro/Wind Down
                const sectionE = {
                    melody: [
                        { note: 659, time: 0, dur: beat * 2 },          // E5
                        { note: 587, time: beat * 2, dur: beat * 2 },   // D5
                        { note: 523, time: bar, dur: beat * 3 },        // C5
                        { note: 494, time: bar + beat * 3, dur: beat },
                        { note: 440, time: bar * 2, dur: beat * 2 },    // A4
                        { note: 392, time: bar * 2 + beat * 2, dur: beat * 2 }, // G4
                        { note: 523, time: bar * 3, dur: beat * 4 },    // C5 - final hold
                    ],
                    bass: [
                        { note: 165, time: 0, dur: beat * 4 },
                        { note: 131, time: bar, dur: beat * 4 },
                        { note: 110, time: bar * 2, dur: beat * 4 },
                        { note: 131, time: bar * 3, dur: beat * 4 },
                    ],
                    drums: 'minimal'
                };

                // Full song structure (~3 minutes at 120 BPM)
                // Each section is 4 bars = 8 seconds
                // 22 sections √ó 8 sec = 176 seconds ‚âà 3 minutes
                const songStructure = [
                    sectionA, sectionA,           // Intro - establish theme (16s)
                    sectionB, sectionA,           // Build up (16s)
                    sectionC, sectionC,           // Bridge - calm (16s)
                    sectionB, sectionD,           // Energy rise (16s)
                    sectionA, sectionB,           // Theme return (16s)
                    sectionD, sectionD,           // Climax (16s)
                    sectionC, sectionA,           // Cool down (16s)
                    sectionB, sectionD,           // Second climax (16s)
                    sectionA, sectionA,           // Theme return (16s)
                    sectionE, sectionE,           // Outro (16s)
                    sectionC, sectionA,           // Final resolve (16s)
                ];

                const sectionDuration = bar * 4;
                const totalDuration = songStructure.length * sectionDuration;
                let currentSection = 0;

                const playDrums = (startTime, style, numBars = 4) => {
                    for (let b = 0; b < numBars * 4; b++) {
                        const t = startTime + (b * beat);

                        if (style === 'standard') {
                            if (b % 4 === 0 || b % 4 === 2) playDrum(t, 'kick');
                            if (b % 2 === 0) playDrum(t, 'tick');
                            if (b % 4 === 2) playDrum(t + beat * 0.5, 'tick');
                        } else if (style === 'upbeat') {
                            if (b % 4 === 0 || b % 4 === 2) playDrum(t, 'kick');
                            playDrum(t, 'tick');
                            playDrum(t + beat * 0.5, 'tick');
                            if (b % 4 === 2) playDrum(t, 'snap');
                        } else if (style === 'sparse') {
                            if (b % 4 === 0) playDrum(t, 'kick');
                            if (b % 2 === 0) playDrum(t, 'tick');
                        } else if (style === 'full') {
                            if (b % 4 === 0 || b % 4 === 2) playDrum(t, 'kick');
                            playDrum(t, 'tick');
                            playDrum(t + beat * 0.5, 'tick');
                            if (b % 2 === 1) playDrum(t, 'snap');
                        } else if (style === 'minimal') {
                            if (b % 4 === 0) playDrum(t, 'kick');
                        }
                    }
                };

                const scheduleSection = () => {
                    if (!this.musicPlaying || !this.musicEnabled) return;

                    // Make sure audio context is running
                    if (this.ctx.state === 'suspended') {
                        this.ctx.resume();
                    }

                    // Safety check - restart if context was interrupted
                    if (!this.masterGain || !this.ctx) {
                        this.musicPlaying = false;
                        this.startMusic();
                        return;
                    }

                    const section = songStructure[currentSection];
                    const now = this.ctx.currentTime + 0.05;

                    // Play melody
                    section.melody.forEach(({ note, time, dur }) => {
                        playNote(note, now + time, dur * 0.95, 'triangle', 0.25);
                    });

                    // Play bass
                    section.bass.forEach(({ note, time, dur }) => {
                        playNote(note, now + time, dur * 0.9, 'sine', 0.2);
                    });

                    // Play drums
                    playDrums(now, section.drums);

                    // Move to next section, restart from beginning when song ends
                    currentSection++;
                    if (currentSection >= songStructure.length) {
                        currentSection = 0; // Restart song from beginning
                    }

                    this.musicTimeout = setTimeout(() => {
                        try {
                            scheduleSection();
                        } catch (e) {
                            console.log('Music scheduling error, restarting...', e);
                            this.musicPlaying = false;
                            setTimeout(() => this.startMusic(), 100);
                        }
                    }, sectionDuration * 1000 - 50);
                };

                scheduleSection();

                // Keep audio context alive when tab is in background
                this.keepAliveInterval = setInterval(() => {
                    if (this.ctx && this.ctx.state === 'suspended' && this.musicEnabled) {
                        this.ctx.resume();
                    }
                }, 1000);
            }

            stopMusic() {
                this.musicPlaying = false;
                if (this.musicTimeout) {
                    clearTimeout(this.musicTimeout);
                }
                if (this.keepAliveInterval) {
                    clearInterval(this.keepAliveInterval);
                }
                if (this.masterGain) {
                    this.masterGain.disconnect();
                    this.masterGain = null;
                }
            }

            updateMusicVolume() {
                if (this.masterGain) {
                    this.masterGain.gain.value = this.musicVolume;
                }
            }

            toggleMusic() {
                this.musicEnabled = !this.musicEnabled;
                if (this.musicEnabled) {
                    this.startMusic();
                } else {
                    this.stopMusic();
                }
                this.saveSettings();
                return this.musicEnabled;
            }

            toggleSound() {
                this.enabled = !this.enabled;
                this.saveSettings();
                return this.enabled;
            }

            setVolume(vol) {
                this.volume = vol;
                this.saveSettings();
            }

            setMusicVolume(vol) {
                this.musicVolume = vol;
                this.updateMusicVolume();
                this.saveSettings();
            }

            saveSettings() {
                localStorage.setItem('arcadeSettings', JSON.stringify({
                    soundEnabled: this.enabled,
                    musicEnabled: this.musicEnabled,
                    volume: this.volume,
                    musicVolume: this.musicVolume
                }));
            }

            loadSettings() {
                try {
                    const settings = JSON.parse(localStorage.getItem('arcadeSettings'));
                    if (settings) {
                        this.enabled = settings.soundEnabled !== false;
                        this.musicEnabled = settings.musicEnabled !== false;
                        this.volume = settings.volume ?? 0.3;
                        this.musicVolume = settings.musicVolume ?? 0.15;
                    }
                } catch (e) {}
            }

            play(type, options = {}) {
                if (!this.enabled || !this.ctx) return;
                this.resume();

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                const now = this.ctx.currentTime;
                const vol = (options.volume || 1) * this.volume;

                switch (type) {
                    case 'hit':
                        osc.frequency.setValueAtTime(300, now);
                        osc.frequency.exponentialRampToValueAtTime(150, now + 0.1);
                        osc.type = 'square';
                        gain.gain.setValueAtTime(vol, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                        break;

                    case 'score':
                        osc.frequency.setValueAtTime(523, now);
                        osc.frequency.setValueAtTime(659, now + 0.1);
                        osc.frequency.setValueAtTime(784, now + 0.2);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(vol, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;

                    case 'win':
                        const notes = [523, 659, 784, 1047];
                        notes.forEach((freq, i) => {
                            const o = this.ctx.createOscillator();
                            const g = this.ctx.createGain();
                            o.connect(g);
                            g.connect(this.ctx.destination);
                            o.frequency.setValueAtTime(freq, now + i * 0.15);
                            o.type = 'sine';
                            g.gain.setValueAtTime(vol * 0.8, now + i * 0.15);
                            g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.2);
                            o.start(now + i * 0.15);
                            o.stop(now + i * 0.15 + 0.2);
                        });
                        return;

                    case 'lose':
                        osc.frequency.setValueAtTime(400, now);
                        osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                        osc.type = 'sawtooth';
                        gain.gain.setValueAtTime(vol * 0.5, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;

                    case 'click':
                        osc.frequency.setValueAtTime(800, now);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(vol * 0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                        osc.start(now);
                        osc.stop(now + 0.05);
                        break;

                    case 'beep':
                        osc.frequency.setValueAtTime(options.freq || 440, now);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(vol, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                        osc.start(now);
                        osc.stop(now + 0.15);
                        break;

                    case 'explosion':
                        const noise = this.ctx.createBufferSource();
                        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < data.length; i++) {
                            data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
                        }
                        noise.buffer = buffer;
                        const noiseGain = this.ctx.createGain();
                        noise.connect(noiseGain);
                        noiseGain.connect(this.ctx.destination);
                        noiseGain.gain.setValueAtTime(vol, now);
                        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                        noise.start(now);
                        return;

                    case 'whoosh':
                        osc.frequency.setValueAtTime(100, now);
                        osc.frequency.exponentialRampToValueAtTime(500, now + 0.1);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(vol * 0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                        break;

                    case 'pop':
                        osc.frequency.setValueAtTime(600, now);
                        osc.frequency.exponentialRampToValueAtTime(200, now + 0.05);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(vol * 0.5, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                        osc.start(now);
                        osc.stop(now + 0.05);
                        break;

                    case 'simon':
                        const simonFreqs = { green: 392, red: 330, yellow: 262, blue: 208 };
                        osc.frequency.setValueAtTime(simonFreqs[options.color] || 440, now);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(vol, now);
                        gain.gain.setValueAtTime(vol, now + 0.2);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                }
            }
        }

        const sound = new SoundManager();
        sound.loadSettings(); // Load saved settings

        // Initialize sound on first interaction
        document.addEventListener('click', () => sound.init(), { once: true });
        document.addEventListener('keydown', () => sound.init(), { once: true });

        // Settings functions
        function openSettings() {
            document.getElementById('settingsModal').classList.add('active');
            updateSettingsUI();
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }

        function updateSettingsUI() {
            document.getElementById('soundToggle').checked = sound.enabled;
            document.getElementById('musicToggle').checked = sound.musicEnabled;
            document.getElementById('sfxVolume').value = sound.volume * 100;
            document.getElementById('musicVolume').value = sound.musicVolume * 100;
            document.getElementById('sfxVolumeValue').textContent = Math.round(sound.volume * 100) + '%';
            document.getElementById('musicVolumeValue').textContent = Math.round(sound.musicVolume * 100) + '%';
        }

        function toggleSoundSetting() {
            sound.toggleSound();
            updateSettingsUI();
        }

        function toggleMusicSetting() {
            sound.toggleMusic();
            updateSettingsUI();
        }

        function setSfxVolume(val) {
            sound.setVolume(val / 100);
            document.getElementById('sfxVolumeValue').textContent = val + '%';
        }

        function setMusicVolume(val) {
            sound.setMusicVolume(val / 100);
            document.getElementById('musicVolumeValue').textContent = val + '%';
        }

        // ==================== SCREEN EFFECTS ====================
        function screenShake(element, intensity = 5, duration = 200) {
            const el = typeof element === 'string' ? document.querySelector(element) : element;
            if (!el) return;

            const originalTransform = el.style.transform;
            let start = null;

            function shake(timestamp) {
                if (!start) start = timestamp;
                const elapsed = timestamp - start;

                if (elapsed < duration) {
                    const x = (Math.random() - 0.5) * intensity * (1 - elapsed/duration);
                    const y = (Math.random() - 0.5) * intensity * (1 - elapsed/duration);
                    el.style.transform = `translate(${x}px, ${y}px)`;
                    requestAnimationFrame(shake);
                } else {
                    el.style.transform = originalTransform;
                }
            }
            requestAnimationFrame(shake);
        }

        function flashElement(element, color = '#fff', duration = 100) {
            const el = typeof element === 'string' ? document.querySelector(element) : element;
            if (!el) return;

            const original = el.style.boxShadow;
            el.style.boxShadow = `0 0 30px ${color}, inset 0 0 30px ${color}`;
            el.style.transition = 'box-shadow 0.1s ease';
            setTimeout(() => {
                el.style.boxShadow = original;
            }, duration);
        }

        function popAnimation(element) {
            const el = typeof element === 'string' ? document.querySelector(element) : element;
            if (!el) return;

            el.style.transform = 'scale(1.2)';
            el.style.transition = 'transform 0.1s ease';
            setTimeout(() => {
                el.style.transform = 'scale(1)';
            }, 100);
        }

        // ==================== FLOATING TEXT ====================
        function showFloatingText(x, y, text, color = '#fff', container = document.body) {
            const el = document.createElement('div');
            el.className = 'floating-text';
            el.textContent = text;
            el.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y}px;
                color: ${color};
                font-family: 'Press Start 2P', cursive;
                font-size: 1rem;
                pointer-events: none;
                z-index: 1000;
                text-shadow: 0 0 10px ${color};
                animation: floatUp 1s ease-out forwards;
            `;
            container.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        // ==================== MOBILE CONTROLS SYSTEM ====================
        const mobileControls = {
            isTouchDevice: function() {
                return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (window.matchMedia("(pointer: coarse)").matches);
            },

            // Simulate keyboard events
            simulateKey: function(key, type = 'keydown') {
                const event = new KeyboardEvent(type, {
                    key: key,
                    code: 'Key' + key.toUpperCase(),
                    bubbles: true
                });
                document.dispatchEvent(event);
            },

            // Create a button that simulates key presses
            createKeyButton: function(label, key, className = '') {
                const btn = document.createElement('button');
                btn.className = 'mobile-btn ' + className;
                btn.innerHTML = label;
                btn.setAttribute('data-key', key);

                const pressStart = (e) => {
                    e.preventDefault();
                    btn.classList.add('pressed');
                    this.simulateKey(key, 'keydown');
                };

                const pressEnd = (e) => {
                    e.preventDefault();
                    btn.classList.remove('pressed');
                    this.simulateKey(key, 'keyup');
                };

                btn.addEventListener('touchstart', pressStart, { passive: false });
                btn.addEventListener('touchend', pressEnd, { passive: false });
                btn.addEventListener('touchcancel', pressEnd, { passive: false });
                btn.addEventListener('mousedown', pressStart);
                btn.addEventListener('mouseup', pressEnd);
                btn.addEventListener('mouseleave', pressEnd);

                return btn;
            },

            // Create D-pad for directional controls
            createDpad: function(upKey, downKey, leftKey, rightKey, className = '') {
                const dpad = document.createElement('div');
                dpad.className = 'mobile-dpad ' + className;

                const upBtn = this.createKeyButton('‚ñ≤', upKey, 'up');
                const downBtn = this.createKeyButton('‚ñº', downKey, 'down');
                const leftBtn = this.createKeyButton('‚óÄ', leftKey, 'left');
                const rightBtn = this.createKeyButton('‚ñ∂', rightKey, 'right');

                dpad.appendChild(upBtn);
                dpad.appendChild(leftBtn);
                dpad.appendChild(rightBtn);
                dpad.appendChild(downBtn);

                return dpad;
            },

            // Create touch slider for paddle games
            createPaddleSlider: function(canvas, paddleObj, isVertical = true, className = '') {
                const slider = document.createElement('div');
                slider.className = 'touch-slider ' + className;

                const thumb = document.createElement('div');
                thumb.className = 'touch-slider-thumb';
                slider.appendChild(thumb);

                let isDragging = false;

                const updatePosition = (clientX, clientY) => {
                    const rect = slider.getBoundingClientRect();
                    if (isVertical) {
                        const y = clientY - rect.top;
                        const percent = Math.max(0, Math.min(1, y / rect.height));
                        thumb.style.top = (percent * (rect.height - 70) + 5) + 'px';
                        return percent;
                    } else {
                        const x = clientX - rect.left;
                        const percent = Math.max(0, Math.min(1, x / rect.width));
                        thumb.style.left = (percent * (rect.width - 40)) + 'px';
                        return percent;
                    }
                };

                slider.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    isDragging = true;
                    const touch = e.touches[0];
                    updatePosition(touch.clientX, touch.clientY);
                }, { passive: false });

                slider.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    const percent = updatePosition(touch.clientX, touch.clientY);
                    if (paddleObj && canvas) {
                        if (isVertical) {
                            paddleObj.y = percent * (canvas.height - paddleObj.height);
                        } else {
                            paddleObj.x = percent * (canvas.width - paddleObj.width);
                        }
                    }
                }, { passive: false });

                slider.addEventListener('touchend', () => { isDragging = false; });
                slider.addEventListener('touchcancel', () => { isDragging = false; });

                return { slider, thumb, updatePosition };
            }
        };

        // Game Modal Controls
        function openGame(game) {
            document.getElementById(game + 'Modal').classList.add('active');
            if (game === 'tictactoe') initTTT();
            if (game === 'pong') initPong();
            if (game === 'connect4') initC4();
            if (game === 'reaction') initReaction();
        }

        function closeGame(game) {
            document.getElementById(game + 'Modal').classList.remove('active');
            if (game === 'pong') stopPong();
        }

        // ==================== P2 MODE SYSTEM (AI vs Manual) ====================
        const p2Modes = {
            tictactoe: 'ai',
            connect4: 'ai',
            pong: 'ai',
            airhockey: 'ai',
            snake: 'ai',
            memory: 'ai'
        };

        function setP2Mode(game, mode) {
            p2Modes[game] = mode;
            // Update button styles
            const toggleId = {
                tictactoe: 'tttP2Toggle',
                connect4: 'c4P2Toggle',
                pong: 'pongP2Toggle',
                airhockey: 'hockeyP2Toggle',
                snake: 'snakeP2Toggle',
                memory: 'memoryP2Toggle'
            }[game];

            if (toggleId) {
                const toggle = document.getElementById(toggleId);
                if (toggle) {
                    toggle.querySelectorAll('.p2-toggle-btn').forEach(btn => {
                        btn.classList.remove('active');
                        if ((mode === 'ai' && btn.textContent === 'AI') ||
                            (mode === 'manual' && btn.textContent === '2P')) {
                            btn.classList.add('active');
                        }
                    });
                }
            }

            // Restart the game when mode changes
            if (game === 'tictactoe') initTTT();
            if (game === 'connect4') initC4();
            if (game === 'pong') resetPong();
            if (game === 'airhockey') resetHockey();
            if (game === 'snake') initSnake();
            if (game === 'memory') initMemory();
        }

        function hideP2TogglesInMultiplayer() {
            const toggles = document.querySelectorAll('.p2-mode-toggle');
            toggles.forEach(t => t.classList.add('hidden'));
        }

        function showP2Toggles() {
            const toggles = document.querySelectorAll('.p2-mode-toggle');
            toggles.forEach(t => t.classList.remove('hidden'));
        }

        // ==================== TIC TAC TOE ====================
        let tttBoard, tttCurrentPlayer, tttGameOver;

        function initTTT() {
            tttBoard = ['', '', '', '', '', '', '', '', ''];
            tttCurrentPlayer = 'X';
            tttGameOver = false;
            document.getElementById('tttStatus').textContent = "Player X's turn";
            document.getElementById('tttStatus').style.color = '#00ff88';
            renderTTT();
        }

        function renderTTT() {
            const board = document.getElementById('tttBoard');
            board.innerHTML = '';
            tttBoard.forEach((cell, i) => {
                const cellEl = document.createElement('button');
                cellEl.className = `ttt-cell ${cell.toLowerCase()} ${cell ? 'taken' : ''}`;
                cellEl.onclick = () => handleTTTClick(i);
                board.appendChild(cellEl);
            });
        }

        function handleTTTClick(i) {
            if (tttBoard[i] || tttGameOver) return;
            // In AI mode, only allow clicks during player's turn (X)
            if (p2Modes.tictactoe === 'ai' && tttCurrentPlayer !== 'X' && !(mp && mp.connected)) return;

            makeTTTMove(i);
        }

        function makeTTTMove(i) {
            tttBoard[i] = tttCurrentPlayer;
            sound.play('pop');

            const winner = checkTTTWinner();
            if (winner) {
                document.getElementById('tttStatus').textContent = `Player ${winner} wins!`;
                document.getElementById('tttStatus').style.color = winner === 'X' ? '#00ff88' : '#ff6b6b';
                document.getElementById('tttStatus').classList.add('winner');
                sound.play('win');
                tttGameOver = true;
                // Highlight winning cells
                const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
                for (const [a,b,c] of lines) {
                    if (tttBoard[a] && tttBoard[a] === tttBoard[b] && tttBoard[a] === tttBoard[c]) {
                        setTimeout(() => {
                            document.querySelectorAll('.ttt-cell')[a]?.classList.add('winning');
                            document.querySelectorAll('.ttt-cell')[b]?.classList.add('winning');
                            document.querySelectorAll('.ttt-cell')[c]?.classList.add('winning');
                        }, 100);
                        break;
                    }
                }
            } else if (tttBoard.every(cell => cell)) {
                document.getElementById('tttStatus').textContent = "It's a draw!";
                document.getElementById('tttStatus').style.color = '#ffd93d';
                sound.play('lose');
                tttGameOver = true;
            } else {
                tttCurrentPlayer = tttCurrentPlayer === 'X' ? 'O' : 'X';
                document.getElementById('tttStatus').textContent = `Player ${tttCurrentPlayer}'s turn`;
                document.getElementById('tttStatus').style.color = tttCurrentPlayer === 'X' ? '#00ff88' : '#ff6b6b';

                // AI move (only if not in multiplayer)
                if (p2Modes.tictactoe === 'ai' && tttCurrentPlayer === 'O' && !tttGameOver && !(mp && mp.connected)) {
                    setTimeout(() => tttAIMove(), 500);
                }
            }
            renderTTT();
        }

        function tttAIMove() {
            if (tttGameOver) return;
            const move = getTTTBestMove();
            if (move !== -1) {
                makeTTTMove(move);
            }
        }

        function getTTTBestMove() {
            // Try to win
            for (let i = 0; i < 9; i++) {
                if (!tttBoard[i]) {
                    tttBoard[i] = 'O';
                    if (checkTTTWinner() === 'O') {
                        tttBoard[i] = '';
                        return i;
                    }
                    tttBoard[i] = '';
                }
            }
            // Block player from winning
            for (let i = 0; i < 9; i++) {
                if (!tttBoard[i]) {
                    tttBoard[i] = 'X';
                    if (checkTTTWinner() === 'X') {
                        tttBoard[i] = '';
                        return i;
                    }
                    tttBoard[i] = '';
                }
            }
            // Take center
            if (!tttBoard[4]) return 4;
            // Take corner
            const corners = [0, 2, 6, 8];
            const emptyCorners = corners.filter(i => !tttBoard[i]);
            if (emptyCorners.length) return emptyCorners[Math.floor(Math.random() * emptyCorners.length)];
            // Take any empty
            const empty = tttBoard.map((c, i) => c ? -1 : i).filter(i => i !== -1);
            return empty.length ? empty[Math.floor(Math.random() * empty.length)] : -1;
        }

        function checkTTTWinner() {
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ];
            for (const [a, b, c] of lines) {
                if (tttBoard[a] && tttBoard[a] === tttBoard[b] && tttBoard[a] === tttBoard[c]) {
                    return tttBoard[a];
                }
            }
            return null;
        }

        // ==================== CONNECT FOUR ====================
        let c4Board, c4CurrentPlayer, c4GameOver;

        function initC4() {
            c4Board = Array(6).fill(null).map(() => Array(7).fill(0));
            c4CurrentPlayer = 1;
            c4GameOver = false;
            document.getElementById('c4Status').innerHTML = 'üî¥ Player 1\'s turn';
            renderC4();
            renderC4Indicators();
        }

        function renderC4Indicators() {
            const indicators = document.getElementById('c4Indicators');
            indicators.innerHTML = '';
            for (let col = 0; col < 7; col++) {
                const ind = document.createElement('div');
                ind.className = `c4-indicator p${c4CurrentPlayer}`;
                ind.onclick = () => handleC4Click(col);
                indicators.appendChild(ind);
            }
        }

        function renderC4() {
            const board = document.getElementById('c4Board');
            board.innerHTML = '';
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 7; col++) {
                    const cell = document.createElement('div');
                    cell.className = `c4-cell ${c4Board[row][col] === 1 ? 'p1' : ''} ${c4Board[row][col] === 2 ? 'p2' : ''} ${c4Board[row][col] ? 'taken' : ''}`;
                    cell.onclick = () => handleC4Click(col);
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    board.appendChild(cell);
                }
            }
        }

        function handleC4Click(col) {
            if (c4GameOver) return;
            // In AI mode, only allow clicks during player 1's turn (not in multiplayer)
            if (p2Modes.connect4 === 'ai' && c4CurrentPlayer !== 1 && !(mp && mp.connected)) return;

            makeC4Move(col);
        }

        function makeC4Move(col) {
            for (let row = 5; row >= 0; row--) {
                if (c4Board[row][col] === 0) {
                    c4Board[row][col] = c4CurrentPlayer;
                    sound.play('whoosh');

                    renderC4();

                    // Add drop animation
                    const cells = document.querySelectorAll('.c4-cell');
                    const cellIndex = row * 7 + col;
                    cells[cellIndex].classList.add('dropping');

                    // Play hit sound when piece lands
                    setTimeout(() => sound.play('hit'), 300);

                    if (checkC4Winner(row, col)) {
                        const emoji = c4CurrentPlayer === 1 ? 'üî¥' : 'üü°';
                        document.getElementById('c4Status').innerHTML = `${emoji} Player ${c4CurrentPlayer} wins!`;
                        document.getElementById('c4Status').classList.add('winner');
                        sound.play('win');
                        c4GameOver = true;
                    } else if (c4Board[0].every(cell => cell !== 0)) {
                        document.getElementById('c4Status').textContent = "It's a draw!";
                        sound.play('lose');
                        c4GameOver = true;
                    } else {
                        c4CurrentPlayer = c4CurrentPlayer === 1 ? 2 : 1;
                        const emoji = c4CurrentPlayer === 1 ? 'üî¥' : 'üü°';
                        document.getElementById('c4Status').innerHTML = `${emoji} Player ${c4CurrentPlayer}'s turn`;
                        renderC4Indicators();

                        // AI move (only if not in multiplayer)
                        if (p2Modes.connect4 === 'ai' && c4CurrentPlayer === 2 && !c4GameOver && !(mp && mp.connected)) {
                            setTimeout(() => c4AIMove(), 600);
                        }
                    }
                    return;
                }
            }
        }

        function c4AIMove() {
            if (c4GameOver) return;
            const col = getC4BestMove();
            if (col !== -1) {
                makeC4Move(col);
            }
        }

        function getC4BestMove() {
            // Try to win
            for (let col = 0; col < 7; col++) {
                const row = getC4DropRow(col);
                if (row !== -1) {
                    c4Board[row][col] = 2;
                    if (checkC4Winner(row, col)) {
                        c4Board[row][col] = 0;
                        return col;
                    }
                    c4Board[row][col] = 0;
                }
            }
            // Block player from winning
            for (let col = 0; col < 7; col++) {
                const row = getC4DropRow(col);
                if (row !== -1) {
                    c4Board[row][col] = 1;
                    if (checkC4Winner(row, col)) {
                        c4Board[row][col] = 0;
                        return col;
                    }
                    c4Board[row][col] = 0;
                }
            }
            // Prefer center columns
            const centerCols = [3, 2, 4, 1, 5, 0, 6];
            for (const col of centerCols) {
                if (getC4DropRow(col) !== -1) return col;
            }
            return -1;
        }

        function getC4DropRow(col) {
            for (let row = 5; row >= 0; row--) {
                if (c4Board[row][col] === 0) return row;
            }
            return -1;
        }

        function checkC4Winner(row, col) {
            const player = c4Board[row][col];
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

            for (const [dr, dc] of directions) {
                let count = 1;
                for (let i = 1; i < 4; i++) {
                    const r = row + dr * i, c = col + dc * i;
                    if (r >= 0 && r < 6 && c >= 0 && c < 7 && c4Board[r][c] === player) count++;
                    else break;
                }
                for (let i = 1; i < 4; i++) {
                    const r = row - dr * i, c = col - dc * i;
                    if (r >= 0 && r < 6 && c >= 0 && c < 7 && c4Board[r][c] === player) count++;
                    else break;
                }
                if (count >= 4) return true;
            }
            return false;
        }

        // ==================== PONG ====================
        let pongCanvas, pongCtx, pongAnimationId;
        let pongBall, pongP1, pongP2, pongScores, pongKeys;

        function initPong() {
            pongCanvas = document.getElementById('pongCanvas');
            pongCtx = pongCanvas.getContext('2d');

            pongScores = { p1: 0, p2: 0 };
            pongKeys = {};

            resetPongBall();
            resetPongPaddles();
            updatePongScores();

            document.addEventListener('keydown', handlePongKeyDown);
            document.addEventListener('keyup', handlePongKeyUp);

            // Setup mobile controls
            setupPongMobileControls();

            if (pongAnimationId) cancelAnimationFrame(pongAnimationId);
            pongLoop();
        }

        function setupPongMobileControls() {
            const setupButton = (id, key) => {
                const btn = document.getElementById(id);
                if (!btn || btn.dataset.mobileSetup) return;
                btn.dataset.mobileSetup = 'true';

                const start = (e) => { e.preventDefault(); pongKeys[key] = true; btn.classList.add('pressed'); };
                const end = (e) => { e.preventDefault(); pongKeys[key] = false; btn.classList.remove('pressed'); };

                btn.addEventListener('touchstart', start, { passive: false });
                btn.addEventListener('touchend', end, { passive: false });
                btn.addEventListener('touchcancel', end, { passive: false });
                btn.addEventListener('mousedown', start);
                btn.addEventListener('mouseup', end);
                btn.addEventListener('mouseleave', end);
            };

            setupButton('pongP1Up', 'w');
            setupButton('pongP1Down', 's');
            setupButton('pongP2Up', 'ArrowUp');
            setupButton('pongP2Down', 'ArrowDown');

            // Also allow touch on canvas to control P1 paddle
            const canvas = document.getElementById('pongCanvas');
            if (canvas && !canvas.dataset.touchSetup) {
                canvas.dataset.touchSetup = 'true';
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const y = (touch.clientY - rect.top) / rect.height * canvas.height;
                    if (pongPaddle1) {
                        pongPaddle1.y = Math.max(0, Math.min(canvas.height - pongPaddle1.height, y - pongPaddle1.height / 2));
                    }
                }, { passive: false });
            }
        }

        function handlePongKeyDown(e) {
            pongKeys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'w', 's'].includes(e.key)) {
                e.preventDefault();
            }
        }

        function handlePongKeyUp(e) {
            pongKeys[e.key] = false;
        }

        function resetPongBall() {
            pongBall = {
                x: 240,
                y: 140,
                vx: (Math.random() > 0.5 ? 1 : -1) * 2.5,
                vy: (Math.random() - 0.5) * 2,
                radius: 8
            };
        }

        function resetPongPaddles() {
            pongP1 = { x: 15, y: 115, width: 10, height: 50, vy: 0 };
            pongP2 = { x: 455, y: 115, width: 10, height: 50, vy: 0 };
        }

        function resetPong() {
            pongScores = { p1: 0, p2: 0 };
            updatePongScores();
            resetPongBall();
            resetPongPaddles();
        }

        function stopPong() {
            if (pongAnimationId) {
                cancelAnimationFrame(pongAnimationId);
                pongAnimationId = null;
            }
            document.removeEventListener('keydown', handlePongKeyDown);
            document.removeEventListener('keyup', handlePongKeyUp);
        }

        function updatePongScores() {
            document.getElementById('p1Score').textContent = pongScores.p1;
            document.getElementById('p2Score').textContent = pongScores.p2;
        }

        function pongLoop() {
            // Paddle movement with velocity (more fluid controls)
            const paddleAccel = 0.5;
            const paddleMaxSpeed = 5;
            const paddleFriction = 0.9;

            // P1 paddle (W/S)
            if (pongKeys['w']) {
                pongP1.vy -= paddleAccel;
            } else if (pongKeys['s']) {
                pongP1.vy += paddleAccel;
            } else {
                pongP1.vy *= paddleFriction;
            }
            pongP1.vy = Math.max(-paddleMaxSpeed, Math.min(paddleMaxSpeed, pongP1.vy));
            pongP1.y += pongP1.vy;
            pongP1.y = Math.max(0, Math.min(230, pongP1.y));

            // P2 paddle (Arrow keys or AI)
            if (p2Modes.pong === 'ai' && !(mp && mp.connected)) {
                // AI follows the ball with some reaction delay
                const paddleCenter = pongP2.y + pongP2.height / 2;
                const targetY = pongBall.y;
                const aiSpeed = 0.08; // AI reaction speed (lower = easier)

                if (targetY < paddleCenter - 10) {
                    pongP2.vy -= paddleAccel * aiSpeed * 10;
                } else if (targetY > paddleCenter + 10) {
                    pongP2.vy += paddleAccel * aiSpeed * 10;
                } else {
                    pongP2.vy *= paddleFriction;
                }
            } else {
                if (pongKeys['ArrowUp']) {
                    pongP2.vy -= paddleAccel;
                } else if (pongKeys['ArrowDown']) {
                    pongP2.vy += paddleAccel;
                } else {
                    pongP2.vy *= paddleFriction;
                }
            }
            pongP2.vy = Math.max(-paddleMaxSpeed, Math.min(paddleMaxSpeed, pongP2.vy));
            pongP2.y += pongP2.vy;
            pongP2.y = Math.max(0, Math.min(230, pongP2.y));

            // Ball trail particles
            particles.pong.trail(pongBall.x, pongBall.y, '#ffffff', 4);

            // Move ball
            pongBall.x += pongBall.vx;
            pongBall.y += pongBall.vy;

            // Ball collision with top/bottom
            if (pongBall.y <= 8 || pongBall.y >= 272) {
                pongBall.vy *= -1;
                sound.play('hit', { volume: 0.3 });
                particles.pong.emit(pongBall.x, pongBall.y, { count: 5, color: '#fff', speed: 2, lifetime: 20 });
            }

            // Ball collision with P1 paddle
            if (pongBall.x <= pongP1.x + pongP1.width + 8 &&
                pongBall.y >= pongP1.y &&
                pongBall.y <= pongP1.y + pongP1.height &&
                pongBall.vx < 0) {
                pongBall.vx = Math.min(Math.abs(pongBall.vx) * 1.03, 6);
                pongBall.vy += (Math.random() - 0.5) * 1.5;
                sound.play('hit');
                particles.pong.emit(pongP1.x + pongP1.width, pongBall.y, { count: 15, color: '#00ff88', speed: 4, spread: Math.PI / 2 });
                screenShake('#pongCanvas', 3, 100);
            }

            // Ball collision with P2 paddle
            if (pongBall.x >= pongP2.x - 8 &&
                pongBall.y >= pongP2.y &&
                pongBall.y <= pongP2.y + pongP2.height &&
                pongBall.vx > 0) {
                pongBall.vx = -Math.min(Math.abs(pongBall.vx) * 1.03, 6);
                pongBall.vy += (Math.random() - 0.5) * 1.5;
                sound.play('hit');
                particles.pong.emit(pongP2.x, pongBall.y, { count: 15, color: '#ff6b6b', speed: 4, spread: Math.PI / 2 });
                screenShake('#pongCanvas', 3, 100);
            }

            // Score - P2 scores
            if (pongBall.x <= 0) {
                pongScores.p2++;
                updatePongScores();
                sound.play('score');
                particles.pong.explosion(pongBall.x, pongBall.y, '#ff6b6b', 30);
                screenShake('.pong-cabinet', 8, 300);
                document.getElementById('p2Score').classList.add('score-pop');
                setTimeout(() => document.getElementById('p2Score').classList.remove('score-pop'), 300);
                resetPongBall();
            }
            // Score - P1 scores
            if (pongBall.x >= 480) {
                pongScores.p1++;
                updatePongScores();
                sound.play('score');
                particles.pong.explosion(pongBall.x, pongBall.y, '#00ff88', 30);
                screenShake('.pong-cabinet', 8, 300);
                document.getElementById('p1Score').classList.add('score-pop');
                setTimeout(() => document.getElementById('p1Score').classList.remove('score-pop'), 300);
                resetPongBall();
            }

            // Update particles
            particles.pong.update();

            // Draw background
            pongCtx.fillStyle = '#000';
            pongCtx.fillRect(0, 0, 480, 280);

            // Center line
            pongCtx.setLineDash([8, 8]);
            pongCtx.strokeStyle = '#333';
            pongCtx.lineWidth = 2;
            pongCtx.beginPath();
            pongCtx.moveTo(240, 0);
            pongCtx.lineTo(240, 280);
            pongCtx.stroke();
            pongCtx.setLineDash([]);

            // Draw particles
            particles.pong.draw(pongCtx);

            // Glow effect for paddles
            pongCtx.shadowBlur = 15;

            // P1 Paddle
            pongCtx.shadowColor = '#00ff88';
            pongCtx.fillStyle = '#00ff88';
            pongCtx.fillRect(pongP1.x, pongP1.y, pongP1.width, pongP1.height);

            // P2 Paddle
            pongCtx.shadowColor = '#ff6b6b';
            pongCtx.fillStyle = '#ff6b6b';
            pongCtx.fillRect(pongP2.x, pongP2.y, pongP2.width, pongP2.height);

            // Ball with glow
            pongCtx.shadowColor = '#fff';
            pongCtx.shadowBlur = 20;
            pongCtx.fillStyle = '#ffffff';
            pongCtx.beginPath();
            pongCtx.arc(pongBall.x, pongBall.y, pongBall.radius, 0, Math.PI * 2);
            pongCtx.fill();

            pongCtx.shadowBlur = 0;

            pongAnimationId = requestAnimationFrame(pongLoop);
        }

        // ==================== REACTION RACE ====================
        let reactionTimeout, reactionReady, reactionScores, reactionActive;

        function initReaction() {
            reactionScores = { p1: 0, p2: 0 };
            reactionReady = false;
            reactionActive = false;
            document.getElementById('reactionScore1').textContent = '0';
            document.getElementById('reactionScore2').textContent = '0';
            document.getElementById('reactionStatus').textContent = 'Press START to begin!';
            document.getElementById('reactionP1').classList.remove('ready');
            document.getElementById('reactionP2').classList.remove('ready');
        }

        function startReaction() {
            if (reactionActive) return;
            reactionActive = true;
            reactionReady = false;
            document.getElementById('reactionP1').classList.remove('ready');
            document.getElementById('reactionP2').classList.remove('ready');
            document.getElementById('reactionStatus').textContent = 'Wait for it...';

            if (reactionTimeout) clearTimeout(reactionTimeout);

            const delay = 1500 + Math.random() * 3000;
            reactionTimeout = setTimeout(() => {
                reactionReady = true;
                document.getElementById('reactionP1').classList.add('ready');
                document.getElementById('reactionP2').classList.add('ready');
                document.getElementById('reactionStatus').textContent = 'GO! GO! GO!';
                sound.play('beep', { freq: 880 });
            }, delay);
        }

        document.addEventListener('keydown', (e) => {
            if (!document.getElementById('reactionModal').classList.contains('active')) return;
            if (!reactionActive) return;

            if (e.key.toLowerCase() === 'q') {
                handleReactionPress(1);
            } else if (e.key.toLowerCase() === 'p') {
                handleReactionPress(2);
            }
        });

        function handleReactionPress(player) {
            if (!reactionActive) return;
            if (reactionTimeout) clearTimeout(reactionTimeout);
            reactionActive = false;

            if (!reactionReady) {
                const otherPlayer = player === 1 ? 2 : 1;
                reactionScores[`p${otherPlayer}`]++;
                document.getElementById(`reactionScore${otherPlayer}`).textContent = reactionScores[`p${otherPlayer}`];
                document.getElementById('reactionStatus').textContent = `Too early! Point to P${otherPlayer}`;
                sound.play('lose');
                screenShake(`#reactionP${player}`, 5, 200);
            } else {
                reactionScores[`p${player}`]++;
                document.getElementById(`reactionScore${player}`).textContent = reactionScores[`p${player}`];
                document.getElementById('reactionStatus').textContent = `P${player} wins the round!`;
                sound.play('score');
                document.getElementById(`reactionP${player}`).classList.add('winner');
                setTimeout(() => document.getElementById(`reactionP${player}`).classList.remove('winner'), 1000);
            }

            document.getElementById('reactionP1').classList.remove('ready');
            document.getElementById('reactionP2').classList.remove('ready');
            reactionReady = false;
        }

        // Allow clicking/tapping the buttons on mobile
        const setupReactionBtn = (id, player) => {
            const btn = document.getElementById(id);
            const handler = (e) => {
                e.preventDefault();
                if (document.getElementById('reactionModal').classList.contains('active') && reactionActive) {
                    handleReactionPress(player);
                }
            };
            btn.addEventListener('click', handler);
            btn.addEventListener('touchstart', handler, { passive: false });
        };
        setupReactionBtn('reactionP1', 1);
        setupReactionBtn('reactionP2', 2);
    </script>

    <!-- Snake Battle Modal -->
    <div class="game-modal" id="snakeModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('snake')">&times;</button>
            <h2 class="game-title">SNAKE BATTLE</h2>
            <div class="p2-mode-toggle" id="snakeP2Toggle">
                <span class="p2-mode-label">P2:</span>
                <button class="p2-toggle-btn active" onclick="setP2Mode('snake', 'ai')">AI</button>
                <button class="p2-toggle-btn" onclick="setP2Mode('snake', 'manual')">2P</button>
            </div>
            <div class="game-status" id="snakeStatus">Press START to begin!</div>
            <div class="snake-wrapper">
                <canvas id="snakeCanvas" width="400" height="400"></canvas>
            </div>
            <div class="snake-controls">
                <p>P1: <span>W</span><span>A</span><span>S</span><span>D</span> &nbsp; P2: <span>‚Üë</span><span>‚Üê</span><span>‚Üì</span><span>‚Üí</span></p>
            </div>
            <div class="mobile-controls" id="snakeMobileControls">
                <div class="mobile-controls-row">
                    <div style="text-align: center;">
                        <div class="mobile-paddle-label">P1</div>
                        <div class="mobile-dpad" id="snakeP1Dpad"></div>
                    </div>
                    <div style="text-align: center;">
                        <div class="mobile-paddle-label">P2</div>
                        <div class="mobile-dpad" id="snakeP2Dpad"></div>
                    </div>
                </div>
            </div>
            <button class="restart-btn" onclick="startSnake()">START</button>
        </div>
    </div>

    <!-- Memory Match Modal -->
    <div class="game-modal" id="memoryModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('memory')">&times;</button>
            <h2 class="game-title">MEMORY MATCH</h2>
            <div class="p2-mode-toggle" id="memoryP2Toggle">
                <span class="p2-mode-label">P2:</span>
                <button class="p2-toggle-btn active" onclick="setP2Mode('memory', 'ai')">AI</button>
                <button class="p2-toggle-btn" onclick="setP2Mode('memory', 'manual')">2P</button>
            </div>
            <div class="game-status" id="memoryStatus">Player 1's turn</div>
            <div class="memory-scores">
                <span class="memory-score p1">P1: <span id="memoryScore1">0</span></span>
                <span class="memory-score p2">P2: <span id="memoryScore2">0</span></span>
            </div>
            <div class="memory-board" id="memoryBoard"></div>
            <button class="restart-btn" onclick="initMemory()">RESTART</button>
        </div>
    </div>

    <!-- Rock Paper Scissors Modal -->
    <div class="game-modal" id="rpsModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('rps')">&times;</button>
            <h2 class="game-title">ROCK PAPER SCISSORS</h2>
            <div class="game-status" id="rpsStatus">Best of 5 - Choose your weapon!</div>
            <div class="rps-scores">
                <span class="rps-score p1">P1: <span id="rpsScore1">0</span></span>
                <span class="rps-score p2">P2: <span id="rpsScore2">0</span></span>
            </div>
            <div class="rps-arena">
                <div class="rps-player" id="rpsP1Area">
                    <div class="rps-label">Player 1</div>
                    <div class="rps-choice" id="rpsP1Choice">?</div>
                    <div class="rps-buttons">
                        <button onclick="rpsSelect(1, 'rock')">ü™®</button>
                        <button onclick="rpsSelect(1, 'paper')">üìÑ</button>
                        <button onclick="rpsSelect(1, 'scissors')">‚úÇÔ∏è</button>
                    </div>
                </div>
                <div class="rps-vs">VS</div>
                <div class="rps-player" id="rpsP2Area">
                    <div class="rps-label">Player 2</div>
                    <div class="rps-choice" id="rpsP2Choice">?</div>
                    <div class="rps-buttons">
                        <button onclick="rpsSelect(2, 'rock')">ü™®</button>
                        <button onclick="rpsSelect(2, 'paper')">üìÑ</button>
                        <button onclick="rpsSelect(2, 'scissors')">‚úÇÔ∏è</button>
                    </div>
                </div>
            </div>
            <button class="restart-btn" onclick="initRPS()">RESTART</button>
        </div>
    </div>

    <!-- Speed Typing Modal -->
    <div class="game-modal" id="typingModal">
        <div class="game-container" style="max-width: 600px;">
            <button class="close-game" onclick="closeGame('typing')">&times;</button>
            <h2 class="game-title">TYPEWRITER</h2>
            <div class="game-status" id="typingStatus">Type the text as fast as you can!</div>
            <div class="typewriter-stats">
                <div class="typewriter-stat">WPM: <span id="typeWpm">0</span></div>
                <div class="typewriter-stat">ACC: <span id="typeAcc">100</span>%</div>
                <div class="typewriter-stat">TIME: <span id="typeTime">0.0</span>s</div>
            </div>
            <div class="typewriter-text" id="typewriterText" onclick="document.getElementById('typewriterInput').focus()">
                Click here and start typing...
            </div>
            <input type="text" id="typewriterInput" class="typewriter-input" autocomplete="off" autocapitalize="off" spellcheck="false">
            <div class="keyboard" id="keyboard">
                <div class="keyboard-row">
                    <div class="key" data-key="`">`</div>
                    <div class="key" data-key="1">1</div>
                    <div class="key" data-key="2">2</div>
                    <div class="key" data-key="3">3</div>
                    <div class="key" data-key="4">4</div>
                    <div class="key" data-key="5">5</div>
                    <div class="key" data-key="6">6</div>
                    <div class="key" data-key="7">7</div>
                    <div class="key" data-key="8">8</div>
                    <div class="key" data-key="9">9</div>
                    <div class="key" data-key="0">0</div>
                    <div class="key" data-key="-">-</div>
                    <div class="key" data-key="=">=</div>
                </div>
                <div class="keyboard-row">
                    <div class="key" data-key="q">Q</div>
                    <div class="key" data-key="w">W</div>
                    <div class="key" data-key="e">E</div>
                    <div class="key" data-key="r">R</div>
                    <div class="key" data-key="t">T</div>
                    <div class="key" data-key="y">Y</div>
                    <div class="key" data-key="u">U</div>
                    <div class="key" data-key="i">I</div>
                    <div class="key" data-key="o">O</div>
                    <div class="key" data-key="p">P</div>
                    <div class="key" data-key="[">[</div>
                    <div class="key" data-key="]">]</div>
                </div>
                <div class="keyboard-row">
                    <div class="key" data-key="a">A</div>
                    <div class="key" data-key="s">S</div>
                    <div class="key" data-key="d">D</div>
                    <div class="key" data-key="f">F</div>
                    <div class="key" data-key="g">G</div>
                    <div class="key" data-key="h">H</div>
                    <div class="key" data-key="j">J</div>
                    <div class="key" data-key="k">K</div>
                    <div class="key" data-key="l">L</div>
                    <div class="key" data-key=";">;</div>
                    <div class="key" data-key="'">'</div>
                </div>
                <div class="keyboard-row">
                    <div class="key" data-key="z">Z</div>
                    <div class="key" data-key="x">X</div>
                    <div class="key" data-key="c">C</div>
                    <div class="key" data-key="v">V</div>
                    <div class="key" data-key="b">B</div>
                    <div class="key" data-key="n">N</div>
                    <div class="key" data-key="m">M</div>
                    <div class="key" data-key=",">,</div>
                    <div class="key" data-key=".">.</div>
                    <div class="key" data-key="/">?</div>
                </div>
                <div class="keyboard-row">
                    <div class="key space" data-key=" ">SPACE</div>
                </div>
            </div>
            <button class="restart-btn" onclick="startTyping()">START</button>
        </div>
    </div>

    <!-- Whack-a-Mole Modal -->
    <div class="game-modal" id="whackModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('whack')">&times;</button>
            <h2 class="game-title">WHACK-A-MOLE</h2>
            <div class="game-status" id="whackStatus">30 seconds - Click to whack!</div>
            <div class="whack-scores">
                <span class="whack-score p1">P1: <span id="whackScore1">0</span></span>
                <span class="whack-timer" id="whackTimer">30</span>
                <span class="whack-score p2">P2: <span id="whackScore2">0</span></span>
            </div>
            <div class="whack-arena">
                <div class="whack-side p1">
                    <div class="whack-grid" id="whackGrid1"></div>
                </div>
                <div class="whack-side p2">
                    <div class="whack-grid" id="whackGrid2"></div>
                </div>
            </div>
            <button class="restart-btn" onclick="startWhack()">START</button>
        </div>
    </div>

    <!-- Air Hockey Modal -->
    <div class="game-modal" id="airhockeyModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('airhockey')">&times;</button>
            <h2 class="game-title">AIR HOCKEY</h2>
            <div class="p2-mode-toggle" id="hockeyP2Toggle">
                <span class="p2-mode-label">P2:</span>
                <button class="p2-toggle-btn active" onclick="setP2Mode('airhockey', 'ai')">AI</button>
                <button class="p2-toggle-btn" onclick="setP2Mode('airhockey', 'manual')">2P</button>
            </div>
            <div class="hockey-wrapper">
                <div class="hockey-cabinet">
                    <div class="hockey-scores">
                        <span class="hockey-score p1" id="hockeyScore1">0</span>
                        <span class="hockey-score p2" id="hockeyScore2">0</span>
                    </div>
                    <canvas id="hockeyCanvas" width="400" height="500"></canvas>
                </div>
                <div class="hockey-controls">
                    <p>P1: <span>W</span><span>A</span><span>S</span><span>D</span> &nbsp; P2: <span>‚Üë</span><span>‚Üê</span><span>‚Üì</span><span>‚Üí</span></p>
                </div>
                <div class="mobile-controls" id="hockeyMobileControls">
                    <div class="mobile-controls-row">
                        <div style="text-align: center;">
                            <div class="mobile-paddle-label">P1</div>
                            <div class="mobile-dpad" id="hockeyP1Dpad"></div>
                        </div>
                        <div style="text-align: center;">
                            <div class="mobile-paddle-label">P2</div>
                            <div class="mobile-dpad" id="hockeyP2Dpad"></div>
                        </div>
                    </div>
                </div>
            </div>
            <button class="restart-btn" onclick="resetHockey()">RESTART</button>
        </div>
    </div>

    <!-- Battleship Modal -->
    <div class="game-modal" id="battleshipModal">
        <div class="game-container" style="max-width: 800px;">
            <button class="close-game" onclick="closeGame('battleship')">&times;</button>
            <h2 class="game-title">BATTLESHIP</h2>
            <div class="game-status" id="battleshipStatus">Player 1: Place your ships!</div>
            <div class="battleship-arena">
                <div class="battleship-side">
                    <div class="battleship-label">Player 1</div>
                    <div class="battleship-grid" id="bsGrid1"></div>
                </div>
                <div class="battleship-side">
                    <div class="battleship-label">Player 2</div>
                    <div class="battleship-grid" id="bsGrid2"></div>
                </div>
            </div>
            <div class="battleship-info" id="bsInfo">Click cells to place 5 ships</div>
            <button class="restart-btn" onclick="initBattleship()">RESTART</button>
        </div>
    </div>

    <!-- Simon Says Modal -->
    <div class="game-modal" id="simonModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('simon')">&times;</button>
            <h2 class="game-title">SIMON SAYS</h2>
            <div class="game-status" id="simonStatus">Watch the pattern!</div>
            <div class="simon-scores">
                <span class="simon-score p1">P1: <span id="simonScore1">0</span></span>
                <span class="simon-score p2">P2: <span id="simonScore2">0</span></span>
            </div>
            <div class="simon-board">
                <button class="simon-btn" data-color="green"></button>
                <button class="simon-btn" data-color="red"></button>
                <button class="simon-btn" data-color="yellow"></button>
                <button class="simon-btn" data-color="blue"></button>
                <button class="simon-btn" data-color="purple"></button>
                <button class="simon-btn" data-color="orange"></button>
                <button class="simon-btn" data-color="pink"></button>
                <button class="simon-btn" data-color="cyan"></button>
                <button class="simon-btn" data-color="lime"></button>
                <button class="simon-btn" data-color="coral"></button>
                <button class="simon-btn" data-color="teal"></button>
                <button class="simon-btn" data-color="gold"></button>
                <button class="simon-btn" data-color="indigo"></button>
                <button class="simon-btn" data-color="mint"></button>
                <button class="simon-btn" data-color="salmon"></button>
                <button class="simon-btn" data-color="violet"></button>
            </div>
            <div class="simon-info" id="simonInfo">Current Player: P1</div>
            <button class="restart-btn" onclick="initSimon()">START</button>
        </div>
    </div>

    <!-- Tetris Modal -->
    <div class="game-modal" id="tetrisModal">
        <div class="game-container tetris-container">
            <button class="close-game" onclick="closeGame('tetris')">&times;</button>
            <h2 class="game-title">TETRIS</h2>
            <div class="tetris-wrapper">
                <div class="tetris-sidebar">
                    <div class="tetris-next">
                        <div class="tetris-label">NEXT</div>
                        <canvas id="tetrisNext" width="100" height="100"></canvas>
                    </div>
                    <div class="tetris-stats">
                        <div class="tetris-stat">
                            <div class="tetris-label">SCORE</div>
                            <div class="tetris-value" id="tetrisScore">0</div>
                        </div>
                        <div class="tetris-stat">
                            <div class="tetris-label">LEVEL</div>
                            <div class="tetris-value" id="tetrisLevel">1</div>
                        </div>
                        <div class="tetris-stat">
                            <div class="tetris-label">LINES</div>
                            <div class="tetris-value" id="tetrisLines">0</div>
                        </div>
                    </div>
                </div>
                <div class="tetris-main">
                    <canvas id="tetrisCanvas" width="300" height="600"></canvas>
                    <div class="tetris-overlay" id="tetrisOverlay">
                        <div class="tetris-message" id="tetrisMessage">Press START</div>
                    </div>
                </div>
                <div class="tetris-controls-info">
                    <div class="tetris-label">CONTROLS</div>
                    <div class="tetris-keys">
                        <span>‚Üê ‚Üí Move</span>
                        <span>‚Üë Rotate</span>
                        <span>‚Üì Soft Drop</span>
                        <span>Space Hard Drop</span>
                    </div>
                </div>
            </div>
            <div class="mobile-controls" id="tetrisMobileControls">
                <div class="mobile-controls-row" style="gap: 15px;">
                    <button class="mobile-btn mobile-action-btn" id="tetrisLeft">‚óÄ</button>
                    <button class="mobile-btn mobile-action-btn" id="tetrisRotate">‚Üª</button>
                    <button class="mobile-btn mobile-action-btn" id="tetrisRight">‚ñ∂</button>
                </div>
                <div class="mobile-controls-row" style="gap: 15px; margin-top: 10px;">
                    <button class="mobile-btn mobile-action-btn" id="tetrisDown">‚ñº</button>
                    <button class="mobile-btn mobile-action-btn blue" id="tetrisDrop">‚¨á</button>
                </div>
            </div>
            <button class="restart-btn" onclick="startTetris()">START</button>
        </div>
    </div>

    <!-- Hungry Hippos Modal -->
    <div class="game-modal" id="hipposModal">
        <div class="game-container hippos-container">
            <button class="close-game" onclick="closeGame('hippos')">&times;</button>
            <h2 class="game-title">HUNGRY HIPPOS</h2>
            <div class="game-status" id="hipposStatus">Press START to play!</div>
            <div class="hippos-scores">
                <div class="hippos-score p1">
                    <span class="hippo-icon">ü¶õ</span>
                    <span>P1: <span id="hipposScore1">0</span></span>
                    <div class="hippos-key">Tap Q</div>
                </div>
                <div class="hippos-score p2">
                    <span class="hippo-icon flip">ü¶õ</span>
                    <span>P2: <span id="hipposScore2">0</span></span>
                    <div class="hippos-key">Tap P</div>
                </div>
            </div>
            <div class="hippos-arena">
                <canvas id="hipposCanvas" width="500" height="400"></canvas>
            </div>
            <div class="hippos-timer">Food Left: <span id="hipposFood">0</span></div>
            <div class="mobile-controls" id="hipposMobileControls">
                <div class="mobile-controls-row">
                    <button class="mobile-btn mobile-action-btn" id="hipposP1Btn" style="font-size: 24px;">ü¶õ<br><small>P1</small></button>
                    <button class="mobile-btn mobile-action-btn red" id="hipposP2Btn" style="font-size: 24px;">ü¶õ<br><small>P2</small></button>
                </div>
            </div>
            <button class="restart-btn" onclick="startHippos()">START</button>
        </div>
    </div>

    <script>
        // ==================== SNAKE BATTLE ====================
        let snakeCanvas, snakeCtx, snakeAnimationId, snakeGameRunning;
        let snake1, snake2, snakeFood;
        const SNAKE_GRID = 20;
        const SNAKE_SIZE = 400 / SNAKE_GRID;

        function initSnake() {
            snakeCanvas = document.getElementById('snakeCanvas');
            snakeCtx = snakeCanvas.getContext('2d');
            snakeGameRunning = false;
            document.getElementById('snakeStatus').textContent = 'Press START to begin!';
        }

        function startSnake() {
            snake1 = {
                body: [{x: 3, y: 10}, {x: 2, y: 10}, {x: 1, y: 10}],
                dir: {x: 1, y: 0},
                nextDir: {x: 1, y: 0},
                color: '#00ff88',
                alive: true
            };
            snake2 = {
                body: [{x: 16, y: 10}, {x: 17, y: 10}, {x: 18, y: 10}],
                dir: {x: -1, y: 0},
                nextDir: {x: -1, y: 0},
                color: '#ff6b6b',
                alive: true
            };
            placeSnakeFood();
            snakeGameRunning = true;
            document.getElementById('snakeStatus').textContent = 'GO!';
            if (snakeAnimationId) cancelAnimationFrame(snakeAnimationId);
            snakeLoop();
        }

        function placeSnakeFood() {
            do {
                snakeFood = {
                    x: Math.floor(Math.random() * SNAKE_GRID),
                    y: Math.floor(Math.random() * SNAKE_GRID)
                };
            } while (isSnakeCollision(snakeFood, snake1.body) || isSnakeCollision(snakeFood, snake2.body));
        }

        function isSnakeCollision(pos, body) {
            return body.some(seg => seg.x === pos.x && seg.y === pos.y);
        }

        let snakeLastTime = 0;
        const SNAKE_SPEED = 120;

        function snakeAIMove() {
            if (!snake2.alive || p2Modes.snake !== 'ai' || (mp && mp.connected)) return;

            const head = snake2.body[0];
            const possibleDirs = [
                {x: 0, y: -1}, // up
                {x: 0, y: 1},  // down
                {x: -1, y: 0}, // left
                {x: 1, y: 0}   // right
            ].filter(dir => {
                // Can't reverse
                if (dir.x === -snake2.dir.x && dir.y === -snake2.dir.y) return false;
                // Check if safe
                const newHead = {x: head.x + dir.x, y: head.y + dir.y};
                if (newHead.x < 0 || newHead.x >= SNAKE_GRID || newHead.y < 0 || newHead.y >= SNAKE_GRID) return false;
                if (isSnakeCollision(newHead, snake2.body)) return false;
                if (isSnakeCollision(newHead, snake1.body)) return false;
                return true;
            });

            if (possibleDirs.length === 0) return; // No safe moves

            // Prefer direction toward food
            let bestDir = possibleDirs[0];
            let bestDist = Infinity;
            for (const dir of possibleDirs) {
                const newHead = {x: head.x + dir.x, y: head.y + dir.y};
                const dist = Math.abs(newHead.x - snakeFood.x) + Math.abs(newHead.y - snakeFood.y);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestDir = dir;
                }
            }
            snake2.nextDir = bestDir;
        }

        function snakeLoop(timestamp) {
            if (!snakeGameRunning) return;

            if (timestamp - snakeLastTime >= SNAKE_SPEED) {
                snakeLastTime = timestamp;
                snakeAIMove(); // AI decides next move before update
                updateSnakes();
            }

            drawSnakes();
            snakeAnimationId = requestAnimationFrame(snakeLoop);
        }

        function updateSnakes() {
            let snakeDied = false;
            [snake1, snake2].forEach(snake => {
                if (!snake.alive) return;
                snake.dir = snake.nextDir;
                const head = {x: snake.body[0].x + snake.dir.x, y: snake.body[0].y + snake.dir.y};

                // Wall collision
                if (head.x < 0 || head.x >= SNAKE_GRID || head.y < 0 || head.y >= SNAKE_GRID) {
                    snake.alive = false;
                    snakeDied = true;
                    // Death explosion particles
                    const deathX = snake.body[0].x * SNAKE_SIZE + SNAKE_SIZE/2;
                    const deathY = snake.body[0].y * SNAKE_SIZE + SNAKE_SIZE/2;
                    particles.snake.explosion(deathX, deathY, snake.color, 40);
                    sound.play('explosion');
                    screenShake('#snakeCanvas', 10, 300);
                    return;
                }

                // Self collision
                if (isSnakeCollision(head, snake.body)) {
                    snake.alive = false;
                    snakeDied = true;
                    const deathX = head.x * SNAKE_SIZE + SNAKE_SIZE/2;
                    const deathY = head.y * SNAKE_SIZE + SNAKE_SIZE/2;
                    particles.snake.explosion(deathX, deathY, snake.color, 40);
                    sound.play('explosion');
                    screenShake('#snakeCanvas', 10, 300);
                    return;
                }

                // Other snake collision
                const other = snake === snake1 ? snake2 : snake1;
                if (isSnakeCollision(head, other.body)) {
                    snake.alive = false;
                    snakeDied = true;
                    const deathX = head.x * SNAKE_SIZE + SNAKE_SIZE/2;
                    const deathY = head.y * SNAKE_SIZE + SNAKE_SIZE/2;
                    particles.snake.explosion(deathX, deathY, snake.color, 40);
                    sound.play('explosion');
                    screenShake('#snakeCanvas', 10, 300);
                    return;
                }

                snake.body.unshift(head);

                // Food
                if (head.x === snakeFood.x && head.y === snakeFood.y) {
                    // Eat effect
                    const foodX = snakeFood.x * SNAKE_SIZE + SNAKE_SIZE/2;
                    const foodY = snakeFood.y * SNAKE_SIZE + SNAKE_SIZE/2;
                    particles.snake.emit(foodX, foodY, { count: 10, color: '#ffd93d', speed: 3, lifetime: 30, type: 'star' });
                    sound.play('pop');
                    placeSnakeFood();
                } else {
                    snake.body.pop();
                }
            });

            // Check win
            if (!snake1.alive || !snake2.alive) {
                snakeGameRunning = false;
                if (!snake1.alive && !snake2.alive) {
                    document.getElementById('snakeStatus').textContent = "It's a tie!";
                } else if (!snake1.alive) {
                    document.getElementById('snakeStatus').textContent = 'Player 2 wins!';
                    sound.play('win');
                } else {
                    document.getElementById('snakeStatus').textContent = 'Player 1 wins!';
                    sound.play('win');
                }
            }
        }

        function drawSnakes() {
            // Update particles
            particles.snake.update();

            snakeCtx.fillStyle = '#0a0a15';
            snakeCtx.fillRect(0, 0, 400, 400);

            // Grid
            snakeCtx.strokeStyle = '#1a1a2a';
            for (let i = 0; i <= SNAKE_GRID; i++) {
                snakeCtx.beginPath();
                snakeCtx.moveTo(i * SNAKE_SIZE, 0);
                snakeCtx.lineTo(i * SNAKE_SIZE, 400);
                snakeCtx.stroke();
                snakeCtx.beginPath();
                snakeCtx.moveTo(0, i * SNAKE_SIZE);
                snakeCtx.lineTo(400, i * SNAKE_SIZE);
                snakeCtx.stroke();
            }

            // Food with pulsing effect
            const pulse = 1 + Math.sin(Date.now() / 200) * 0.2;
            snakeCtx.fillStyle = '#ffd93d';
            snakeCtx.shadowColor = '#ffd93d';
            snakeCtx.shadowBlur = 15 * pulse;
            snakeCtx.beginPath();
            snakeCtx.arc(snakeFood.x * SNAKE_SIZE + SNAKE_SIZE/2, snakeFood.y * SNAKE_SIZE + SNAKE_SIZE/2, (SNAKE_SIZE/2 - 2) * pulse, 0, Math.PI * 2);
            snakeCtx.fill();
            snakeCtx.shadowBlur = 0;

            // Draw particles
            particles.snake.draw(snakeCtx);

            // Snakes with gradient effect
            [snake1, snake2].forEach(snake => {
                snake.body.forEach((seg, i) => {
                    const alpha = snake.alive ? 1 - (i / snake.body.length) * 0.5 : 0.3;
                    snakeCtx.globalAlpha = alpha;
                    snakeCtx.fillStyle = snake.alive ? snake.color : '#666';
                    if (i === 0) {
                        snakeCtx.shadowColor = snake.color;
                        snakeCtx.shadowBlur = 15;
                        // Draw eyes on head
                        snakeCtx.fillRect(seg.x * SNAKE_SIZE + 1, seg.y * SNAKE_SIZE + 1, SNAKE_SIZE - 2, SNAKE_SIZE - 2);
                        snakeCtx.shadowBlur = 0;
                        // Eyes
                        snakeCtx.fillStyle = '#fff';
                        const eyeOffset = SNAKE_SIZE / 4;
                        snakeCtx.beginPath();
                        snakeCtx.arc(seg.x * SNAKE_SIZE + eyeOffset + 3, seg.y * SNAKE_SIZE + eyeOffset + 3, 2, 0, Math.PI * 2);
                        snakeCtx.arc(seg.x * SNAKE_SIZE + SNAKE_SIZE - eyeOffset - 3, seg.y * SNAKE_SIZE + eyeOffset + 3, 2, 0, Math.PI * 2);
                        snakeCtx.fill();
                    } else {
                        snakeCtx.fillRect(seg.x * SNAKE_SIZE + 2, seg.y * SNAKE_SIZE + 2, SNAKE_SIZE - 4, SNAKE_SIZE - 4);
                    }
                });
                snakeCtx.globalAlpha = 1;
            });
        }

        document.addEventListener('keydown', (e) => {
            if (!document.getElementById('snakeModal').classList.contains('active')) return;
            if (!snakeGameRunning) return;

            // P1 controls
            if (e.key.toLowerCase() === 'w' && snake1.dir.y !== 1) snake1.nextDir = {x: 0, y: -1};
            if (e.key.toLowerCase() === 's' && snake1.dir.y !== -1) snake1.nextDir = {x: 0, y: 1};
            if (e.key.toLowerCase() === 'a' && snake1.dir.x !== 1) snake1.nextDir = {x: -1, y: 0};
            if (e.key.toLowerCase() === 'd' && snake1.dir.x !== -1) snake1.nextDir = {x: 1, y: 0};

            // P2 controls (manual mode or multiplayer)
            if (p2Modes.snake === 'manual' || (mp && mp.connected)) {
                if (e.key === 'ArrowUp' && snake2.dir.y !== 1) snake2.nextDir = {x: 0, y: -1};
                if (e.key === 'ArrowDown' && snake2.dir.y !== -1) snake2.nextDir = {x: 0, y: 1};
                if (e.key === 'ArrowLeft' && snake2.dir.x !== 1) snake2.nextDir = {x: -1, y: 0};
                if (e.key === 'ArrowRight' && snake2.dir.x !== -1) snake2.nextDir = {x: 1, y: 0};
            }

            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });

        // Snake mobile controls setup
        (function setupSnakeMobileControls() {
            const createDpadButton = (label, onClick, className = '') => {
                const btn = document.createElement('button');
                btn.className = 'mobile-btn ' + className;
                btn.innerHTML = label;
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); onClick(); }, { passive: false });
                btn.addEventListener('click', onClick);
                return btn;
            };

            const p1Dpad = document.getElementById('snakeP1Dpad');
            const p2Dpad = document.getElementById('snakeP2Dpad');

            if (p1Dpad && !p1Dpad.dataset.setup) {
                p1Dpad.dataset.setup = 'true';
                p1Dpad.appendChild(createDpadButton('‚ñ≤', () => { if (snake1 && snake1.dir.y !== 1) snake1.nextDir = {x: 0, y: -1}; }, 'up'));
                p1Dpad.appendChild(createDpadButton('‚óÄ', () => { if (snake1 && snake1.dir.x !== 1) snake1.nextDir = {x: -1, y: 0}; }, 'left'));
                p1Dpad.appendChild(createDpadButton('‚ñ∂', () => { if (snake1 && snake1.dir.x !== -1) snake1.nextDir = {x: 1, y: 0}; }, 'right'));
                p1Dpad.appendChild(createDpadButton('‚ñº', () => { if (snake1 && snake1.dir.y !== -1) snake1.nextDir = {x: 0, y: 1}; }, 'down'));
            }

            if (p2Dpad && !p2Dpad.dataset.setup) {
                p2Dpad.dataset.setup = 'true';
                p2Dpad.appendChild(createDpadButton('‚ñ≤', () => { if (snake2 && snake2.dir.y !== 1) snake2.nextDir = {x: 0, y: -1}; }, 'up red'));
                p2Dpad.appendChild(createDpadButton('‚óÄ', () => { if (snake2 && snake2.dir.x !== 1) snake2.nextDir = {x: -1, y: 0}; }, 'left red'));
                p2Dpad.appendChild(createDpadButton('‚ñ∂', () => { if (snake2 && snake2.dir.x !== -1) snake2.nextDir = {x: 1, y: 0}; }, 'right red'));
                p2Dpad.appendChild(createDpadButton('‚ñº', () => { if (snake2 && snake2.dir.y !== -1) snake2.nextDir = {x: 0, y: 1}; }, 'down red'));
            }
        })();

        function stopSnake() {
            snakeGameRunning = false;
            if (snakeAnimationId) cancelAnimationFrame(snakeAnimationId);
        }

        // ==================== MEMORY MATCH ====================
        let memoryCards, memoryFlipped, memoryMatched, memoryCurrentPlayer, memoryScores, memoryLocked;
        const MEMORY_ICONS = ['üéÆ', 'üéØ', 'üé≤', 'üé™', 'üé®', 'üé≠', 'üé™', 'üéØ'];

        function initMemory() {
            const icons = [...MEMORY_ICONS, ...MEMORY_ICONS];
            memoryCards = icons.sort(() => Math.random() - 0.5);
            memoryFlipped = [];
            memoryMatched = new Set();
            memoryCurrentPlayer = 1;
            memoryScores = {1: 0, 2: 0};
            memoryLocked = false;
            memoryAIKnown = {}; // Reset AI memory
            document.getElementById('memoryScore1').textContent = '0';
            document.getElementById('memoryScore2').textContent = '0';
            document.getElementById('memoryStatus').textContent = "Player 1's turn";
            document.getElementById('memoryStatus').style.color = '#00ff88';
            renderMemory();
        }

        function renderMemory() {
            const board = document.getElementById('memoryBoard');
            board.innerHTML = '';
            memoryCards.forEach((icon, i) => {
                const card = document.createElement('div');
                card.className = `memory-card ${memoryFlipped.includes(i) || memoryMatched.has(i) ? 'flipped' : ''}`;
                card.innerHTML = `<div class="memory-front">?</div><div class="memory-back">${icon}</div>`;
                card.onclick = () => flipCard(i);
                board.appendChild(card);
            });
        }

        function flipCard(index) {
            if (memoryLocked || memoryFlipped.includes(index) || memoryMatched.has(index)) return;
            // In AI mode, only allow clicks during player 1's turn (not in multiplayer)
            if (p2Modes.memory === 'ai' && memoryCurrentPlayer !== 1 && !(mp && mp.connected)) return;

            memoryFlipped.push(index);
            renderMemory();

            if (memoryFlipped.length === 2) {
                memoryLocked = true;
                const [first, second] = memoryFlipped;

                if (memoryCards[first] === memoryCards[second]) {
                    memoryMatched.add(first);
                    memoryMatched.add(second);
                    memoryScores[memoryCurrentPlayer]++;
                    document.getElementById(`memoryScore${memoryCurrentPlayer}`).textContent = memoryScores[memoryCurrentPlayer];
                    memoryFlipped = [];
                    memoryLocked = false;

                    if (memoryMatched.size === memoryCards.length) {
                        const winner = memoryScores[1] > memoryScores[2] ? 1 : memoryScores[2] > memoryScores[1] ? 2 : 0;
                        document.getElementById('memoryStatus').textContent = winner ? `Player ${winner} wins!` : "It's a tie!";
                        document.getElementById('memoryStatus').style.color = '#ffd93d';
                    } else if (p2Modes.memory === 'ai' && memoryCurrentPlayer === 2 && !(mp && mp.connected)) {
                        // AI got a match, goes again
                        setTimeout(() => memoryAITurn(), 800);
                    }
                } else {
                    setTimeout(() => {
                        memoryFlipped = [];
                        memoryCurrentPlayer = memoryCurrentPlayer === 1 ? 2 : 1;
                        document.getElementById('memoryStatus').textContent = `Player ${memoryCurrentPlayer}'s turn`;
                        document.getElementById('memoryStatus').style.color = memoryCurrentPlayer === 1 ? '#00ff88' : '#ff6b6b';
                        memoryLocked = false;
                        renderMemory();

                        // AI's turn (not in multiplayer)
                        if (p2Modes.memory === 'ai' && memoryCurrentPlayer === 2 && !(mp && mp.connected)) {
                            setTimeout(() => memoryAITurn(), 600);
                        }
                    }, 1000);
                }
            }
        }

        // AI memory: remembers seen cards
        let memoryAIKnown = {};

        function memoryAITurn() {
            if (memoryMatched.size === memoryCards.length) return;

            const unmatched = [];
            for (let i = 0; i < memoryCards.length; i++) {
                if (!memoryMatched.has(i)) unmatched.push(i);
            }

            // Check if AI knows a matching pair
            let firstCard = -1, secondCard = -1;
            for (let i = 0; i < unmatched.length; i++) {
                const cardI = unmatched[i];
                const iconI = memoryAIKnown[cardI];
                if (iconI) {
                    for (let j = i + 1; j < unmatched.length; j++) {
                        const cardJ = unmatched[j];
                        if (memoryAIKnown[cardJ] === iconI) {
                            firstCard = cardI;
                            secondCard = cardJ;
                            break;
                        }
                    }
                }
                if (firstCard !== -1) break;
            }

            if (firstCard === -1) {
                // Pick random cards
                const shuffled = unmatched.sort(() => Math.random() - 0.5);
                firstCard = shuffled[0];
                secondCard = shuffled[1];
            }

            // Flip first card
            memoryFlipped.push(firstCard);
            memoryAIKnown[firstCard] = memoryCards[firstCard];
            renderMemory();

            setTimeout(() => {
                // Flip second card
                memoryFlipped.push(secondCard);
                memoryAIKnown[secondCard] = memoryCards[secondCard];
                renderMemory();

                // Check match
                memoryLocked = true;
                setTimeout(() => {
                    if (memoryCards[firstCard] === memoryCards[secondCard]) {
                        memoryMatched.add(firstCard);
                        memoryMatched.add(secondCard);
                        memoryScores[2]++;
                        document.getElementById('memoryScore2').textContent = memoryScores[2];
                        memoryFlipped = [];
                        memoryLocked = false;
                        renderMemory();

                        if (memoryMatched.size === memoryCards.length) {
                            const winner = memoryScores[1] > memoryScores[2] ? 1 : memoryScores[2] > memoryScores[1] ? 2 : 0;
                            document.getElementById('memoryStatus').textContent = winner ? `Player ${winner} wins!` : "It's a tie!";
                            document.getElementById('memoryStatus').style.color = '#ffd93d';
                        } else {
                            // AI goes again
                            setTimeout(() => memoryAITurn(), 800);
                        }
                    } else {
                        memoryFlipped = [];
                        memoryCurrentPlayer = 1;
                        document.getElementById('memoryStatus').textContent = "Player 1's turn";
                        document.getElementById('memoryStatus').style.color = '#00ff88';
                        memoryLocked = false;
                        renderMemory();
                    }
                }, 800);
            }, 600);
        }

        // ==================== ROCK PAPER SCISSORS ====================
        let rpsChoices, rpsScores, rpsRound;

        function initRPS() {
            rpsChoices = {1: null, 2: null};
            rpsScores = {1: 0, 2: 0};
            rpsRound = 1;
            document.getElementById('rpsScore1').textContent = '0';
            document.getElementById('rpsScore2').textContent = '0';
            document.getElementById('rpsP1Choice').textContent = '?';
            document.getElementById('rpsP2Choice').textContent = '?';
            document.getElementById('rpsStatus').textContent = 'Round 1 - Choose your weapon!';
            document.querySelectorAll('.rps-buttons button').forEach(b => b.disabled = false);
        }

        function rpsSelect(player, choice) {
            rpsChoices[player] = choice;
            const emoji = choice === 'rock' ? 'ü™®' : choice === 'paper' ? 'üìÑ' : '‚úÇÔ∏è';
            document.getElementById(`rpsP${player}Choice`).textContent = '‚úì';

            if (rpsChoices[1] && rpsChoices[2]) {
                setTimeout(rpsReveal, 500);
            }
        }

        function rpsReveal() {
            const emojis = {rock: 'ü™®', paper: 'üìÑ', scissors: '‚úÇÔ∏è'};
            document.getElementById('rpsP1Choice').textContent = emojis[rpsChoices[1]];
            document.getElementById('rpsP2Choice').textContent = emojis[rpsChoices[2]];

            const c1 = rpsChoices[1], c2 = rpsChoices[2];
            let winner = 0;
            if (c1 !== c2) {
                if ((c1 === 'rock' && c2 === 'scissors') || (c1 === 'paper' && c2 === 'rock') || (c1 === 'scissors' && c2 === 'paper')) {
                    winner = 1;
                } else {
                    winner = 2;
                }
                rpsScores[winner]++;
                document.getElementById(`rpsScore${winner}`).textContent = rpsScores[winner];
            }

            if (rpsScores[1] >= 3 || rpsScores[2] >= 3) {
                const champ = rpsScores[1] >= 3 ? 1 : 2;
                document.getElementById('rpsStatus').textContent = `Player ${champ} wins the match!`;
                document.querySelectorAll('.rps-buttons button').forEach(b => b.disabled = true);
            } else {
                document.getElementById('rpsStatus').textContent = winner ? `P${winner} wins round ${rpsRound}!` : 'Tie round!';
                setTimeout(() => {
                    rpsRound++;
                    rpsChoices = {1: null, 2: null};
                    document.getElementById('rpsP1Choice').textContent = '?';
                    document.getElementById('rpsP2Choice').textContent = '?';
                    document.getElementById('rpsStatus').textContent = `Round ${rpsRound} - Choose your weapon!`;
                }, 1500);
            }
        }

        // ==================== SPEED TYPING ====================
        let typingScores, typingCurrentWord, typingActive;
        // Typewriter sentences
        const TYPING_SENTENCES = [
            "The quick brown fox jumps over the lazy dog.",
            "Pack my box with five dozen liquor jugs.",
            "How vexingly quick daft zebras jump!",
            "The five boxing wizards jump quickly.",
            "Sphinx of black quartz, judge my vow.",
            "Two driven jocks help fax my big quiz.",
            "The jay, pig, fox, zebra and my wolves quack!",
            "Sympathizing would fix Quaker objectives.",
            "A wizard's job is to vex chumps quickly in fog.",
            "Watch Jeopardy, Alex Trebek's fun TV quiz game.",
            "Coding is like poetry written for machines.",
            "Debug the system before launching the app.",
            "The server crashed due to memory overflow.",
            "Always write clean and readable code.",
            "Version control saves developers daily."
        ];

        let typeText = '';
        let typeIndex = 0;
        let typeStartTime = null;
        let typeErrors = 0;
        let typeTotalChars = 0;
        let typeTimer = null;

        function initTyping() {
            typingActive = false;
            typeText = '';
            typeIndex = 0;
            typeStartTime = null;
            typeErrors = 0;
            typeTotalChars = 0;
            if (typeTimer) clearInterval(typeTimer);
            document.getElementById('typeWpm').textContent = '0';
            document.getElementById('typeAcc').textContent = '100';
            document.getElementById('typeTime').textContent = '0.0';
            document.getElementById('typewriterText').innerHTML = 'Click START to begin...';
            document.getElementById('typewriterInput').value = '';
            document.getElementById('typingStatus').textContent = 'Type the text as fast as you can!';
            document.querySelectorAll('.key').forEach(k => k.classList.remove('active', 'error'));
        }

        function startTyping() {
            initTyping();
            typeText = TYPING_SENTENCES[Math.floor(Math.random() * TYPING_SENTENCES.length)];
            typeIndex = 0;
            typeErrors = 0;
            typeTotalChars = 0;
            typingActive = true;
            renderTypewriterText();
            document.getElementById('typewriterInput').value = '';
            document.getElementById('typewriterInput').focus();
            highlightNextKey();
        }

        function renderTypewriterText() {
            let html = '';
            for (let i = 0; i < typeText.length; i++) {
                let cls = 'typewriter-char ';
                if (i < typeIndex) {
                    cls += 'correct';
                } else if (i === typeIndex) {
                    cls += 'current';
                } else {
                    cls += 'pending';
                }
                const char = typeText[i] === ' ' ? '&nbsp;' : typeText[i];
                html += `<span class="${cls}">${char}</span>`;
            }
            document.getElementById('typewriterText').innerHTML = html;
        }

        function highlightNextKey() {
            document.querySelectorAll('.key').forEach(k => k.classList.remove('active', 'error'));
            if (typeIndex < typeText.length) {
                const nextChar = typeText[typeIndex].toLowerCase();
                const keyEl = document.querySelector(`.key[data-key="${nextChar}"]`);
                if (keyEl) keyEl.classList.add('active');
            }
        }

        function updateTypeStats() {
            if (!typeStartTime) return;
            const elapsed = (Date.now() - typeStartTime) / 1000;
            const words = typeIndex / 5;
            const wpm = elapsed > 0 ? Math.round((words / elapsed) * 60) : 0;
            const accuracy = typeTotalChars > 0 ? Math.round(((typeTotalChars - typeErrors) / typeTotalChars) * 100) : 100;

            document.getElementById('typeWpm').textContent = wpm;
            document.getElementById('typeAcc').textContent = Math.max(0, accuracy);
            document.getElementById('typeTime').textContent = elapsed.toFixed(1);
        }

        document.getElementById('typewriterInput')?.addEventListener('keydown', (e) => {
            if (!typingActive) return;
            if (e.key === 'Backspace' || e.key === 'Tab' || e.key === 'Shift' || e.key === 'Control' || e.key === 'Alt' || e.key === 'Meta') {
                e.preventDefault();
                return;
            }
        });

        document.getElementById('typewriterInput')?.addEventListener('input', (e) => {
            if (!typingActive || typeIndex >= typeText.length) return;

            // Start timer on first keystroke
            if (!typeStartTime) {
                typeStartTime = Date.now();
                typeTimer = setInterval(updateTypeStats, 100);
            }

            const typed = e.data;
            if (!typed) return;

            typeTotalChars++;
            const expected = typeText[typeIndex];

            // Highlight pressed key
            document.querySelectorAll('.key').forEach(k => k.classList.remove('active', 'error'));
            const pressedKey = document.querySelector(`.key[data-key="${typed.toLowerCase()}"]`);

            if (typed === expected) {
                if (pressedKey) pressedKey.classList.add('active');
                sound.play('pop');
                typeIndex++;
                renderTypewriterText();
                highlightNextKey();

                // Check if complete
                if (typeIndex >= typeText.length) {
                    typingActive = false;
                    clearInterval(typeTimer);
                    updateTypeStats();
                    const elapsed = ((Date.now() - typeStartTime) / 1000).toFixed(1);
                    const wpm = document.getElementById('typeWpm').textContent;
                    const acc = document.getElementById('typeAcc').textContent;
                    document.getElementById('typingStatus').textContent = `Done! ${wpm} WPM, ${acc}% accuracy`;
                    sound.play('win');
                }
            } else {
                if (pressedKey) pressedKey.classList.add('error');
                sound.play('hit', { volume: 0.3 });
                typeErrors++;
                // Mark current char as error briefly
                const chars = document.querySelectorAll('.typewriter-char');
                if (chars[typeIndex]) {
                    chars[typeIndex].classList.add('incorrect');
                    setTimeout(() => {
                        chars[typeIndex]?.classList.remove('incorrect');
                        chars[typeIndex]?.classList.add('current');
                    }, 150);
                }
            }

            // Clear input
            e.target.value = '';
        });

        // Focus input when clicking the text area
        document.getElementById('typewriterText')?.addEventListener('click', () => {
            document.getElementById('typewriterInput').focus();
        });

        // ==================== WHACK-A-MOLE ====================
        let whackScores, whackTimer, whackInterval, whackMoleIntervals, whackActive;

        function initWhack() {
            whackScores = {1: 0, 2: 0};
            whackActive = false;
            document.getElementById('whackScore1').textContent = '0';
            document.getElementById('whackScore2').textContent = '0';
            document.getElementById('whackTimer').textContent = '30';
            document.getElementById('whackStatus').textContent = 'Press START!';
            renderWhackGrids();
        }

        function renderWhackGrids() {
            [1, 2].forEach(p => {
                const grid = document.getElementById(`whackGrid${p}`);
                grid.innerHTML = '';
                for (let i = 0; i < 9; i++) {
                    const hole = document.createElement('div');
                    hole.className = 'whack-hole';
                    hole.dataset.player = p;
                    hole.dataset.index = i;
                    const whack = (e) => { e.preventDefault(); whackMole(p, i); };
                    hole.onclick = whack;
                    hole.addEventListener('touchstart', whack, { passive: false });
                    grid.appendChild(hole);
                }
            });
        }

        function startWhack() {
            initWhack();
            whackActive = true;
            let timeLeft = 30;
            document.getElementById('whackStatus').textContent = 'WHACK!';

            whackInterval = setInterval(() => {
                timeLeft--;
                document.getElementById('whackTimer').textContent = timeLeft;
                if (timeLeft <= 0) {
                    endWhack();
                }
            }, 1000);

            whackMoleIntervals = [1, 2].map(p => setInterval(() => spawnMole(p), 800));
        }

        function spawnMole(player) {
            if (!whackActive) return;
            const grid = document.getElementById(`whackGrid${player}`);
            const holes = grid.querySelectorAll('.whack-hole');
            const emptyHoles = Array.from(holes).filter(h => !h.classList.contains('mole'));
            if (emptyHoles.length) {
                const hole = emptyHoles[Math.floor(Math.random() * emptyHoles.length)];
                hole.classList.add('mole');
                setTimeout(() => hole.classList.remove('mole'), 1000);
            }
        }

        function whackMole(player, index) {
            if (!whackActive) return;
            const hole = document.querySelector(`.whack-hole[data-player="${player}"][data-index="${index}"]`);
            if (hole.classList.contains('mole')) {
                hole.classList.remove('mole');
                hole.classList.add('hit');
                setTimeout(() => hole.classList.remove('hit'), 200);
                whackScores[player]++;
                document.getElementById(`whackScore${player}`).textContent = whackScores[player];
            }
        }

        function endWhack() {
            whackActive = false;
            clearInterval(whackInterval);
            whackMoleIntervals.forEach(i => clearInterval(i));
            const winner = whackScores[1] > whackScores[2] ? 1 : whackScores[2] > whackScores[1] ? 2 : 0;
            document.getElementById('whackStatus').textContent = winner ? `Player ${winner} wins!` : "It's a tie!";
        }

        function stopWhack() {
            whackActive = false;
            if (whackInterval) clearInterval(whackInterval);
            if (whackMoleIntervals) whackMoleIntervals.forEach(i => clearInterval(i));
        }

        // ==================== AIR HOCKEY ====================
        let hockeyCanvas, hockeyCtx, hockeyAnimationId;
        let hockeyPuck, hockeyP1, hockeyP2, hockeyScores, hockeyKeys;

        function initHockey() {
            hockeyCanvas = document.getElementById('hockeyCanvas');
            hockeyCtx = hockeyCanvas.getContext('2d');
            hockeyScores = {1: 0, 2: 0};
            hockeyKeys = {};
            resetHockeyPositions();
            updateHockeyScores();

            document.addEventListener('keydown', handleHockeyKeyDown);
            document.addEventListener('keyup', handleHockeyKeyUp);

            // Setup mobile controls
            setupHockeyMobileControls();

            if (hockeyAnimationId) cancelAnimationFrame(hockeyAnimationId);
            hockeyLoop();
        }

        function setupHockeyMobileControls() {
            const createDpadButton = (label, keyDown, keyUp, className = '') => {
                const btn = document.createElement('button');
                btn.className = 'mobile-btn ' + className;
                btn.innerHTML = label;

                const start = (e) => { e.preventDefault(); hockeyKeys[keyDown] = true; btn.classList.add('pressed'); };
                const end = (e) => { e.preventDefault(); hockeyKeys[keyDown] = false; btn.classList.remove('pressed'); };

                btn.addEventListener('touchstart', start, { passive: false });
                btn.addEventListener('touchend', end, { passive: false });
                btn.addEventListener('touchcancel', end, { passive: false });
                btn.addEventListener('mousedown', start);
                btn.addEventListener('mouseup', end);
                btn.addEventListener('mouseleave', end);
                return btn;
            };

            const p1Dpad = document.getElementById('hockeyP1Dpad');
            const p2Dpad = document.getElementById('hockeyP2Dpad');

            if (p1Dpad && !p1Dpad.dataset.setup) {
                p1Dpad.dataset.setup = 'true';
                p1Dpad.appendChild(createDpadButton('‚ñ≤', 'w', 'w', 'up'));
                p1Dpad.appendChild(createDpadButton('‚óÄ', 'a', 'a', 'left'));
                p1Dpad.appendChild(createDpadButton('‚ñ∂', 'd', 'd', 'right'));
                p1Dpad.appendChild(createDpadButton('‚ñº', 's', 's', 'down'));
            }

            if (p2Dpad && !p2Dpad.dataset.setup) {
                p2Dpad.dataset.setup = 'true';
                p2Dpad.appendChild(createDpadButton('‚ñ≤', 'ArrowUp', 'ArrowUp', 'up red'));
                p2Dpad.appendChild(createDpadButton('‚óÄ', 'ArrowLeft', 'ArrowLeft', 'left red'));
                p2Dpad.appendChild(createDpadButton('‚ñ∂', 'ArrowRight', 'ArrowRight', 'right red'));
                p2Dpad.appendChild(createDpadButton('‚ñº', 'ArrowDown', 'ArrowDown', 'down red'));
            }

            // Also allow touch on canvas to control P1 paddle
            if (hockeyCanvas && !hockeyCanvas.dataset.touchSetup) {
                hockeyCanvas.dataset.touchSetup = 'true';
                hockeyCanvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const rect = hockeyCanvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = (touch.clientX - rect.left) / rect.width * hockeyCanvas.width;
                    const y = (touch.clientY - rect.top) / rect.height * hockeyCanvas.height;
                    // Limit P1 to bottom half
                    if (hockeyP1 && y > 250) {
                        hockeyP1.x = Math.max(30, Math.min(370, x));
                        hockeyP1.y = Math.max(280, Math.min(470, y));
                    }
                }, { passive: false });
            }
        }

        function handleHockeyKeyDown(e) {
            hockeyKeys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
        }

        function handleHockeyKeyUp(e) {
            hockeyKeys[e.key] = false;
        }

        function resetHockeyPositions() {
            hockeyPuck = {x: 200, y: 250, vx: 0, vy: 2, radius: 12};
            hockeyP1 = {x: 200, y: 430, radius: 25, vx: 0, vy: 0};
            hockeyP2 = {x: 200, y: 70, radius: 25, vx: 0, vy: 0};
        }

        function resetHockey() {
            hockeyScores = {1: 0, 2: 0};
            updateHockeyScores();
            resetHockeyPositions();
        }

        function updateHockeyScores() {
            document.getElementById('hockeyScore1').textContent = hockeyScores[1];
            document.getElementById('hockeyScore2').textContent = hockeyScores[2];
        }

        function stopHockey() {
            if (hockeyAnimationId) cancelAnimationFrame(hockeyAnimationId);
            document.removeEventListener('keydown', handleHockeyKeyDown);
            document.removeEventListener('keyup', handleHockeyKeyUp);
        }

        function hockeyLoop() {
            // Velocity-based movement for fluid controls
            const accel = 0.4;
            const maxSpeed = 4;
            const friction = 0.92;

            // P1 movement (bottom half) - WASD
            if (hockeyKeys['a']) hockeyP1.vx -= accel;
            else if (hockeyKeys['d']) hockeyP1.vx += accel;
            else hockeyP1.vx *= friction;

            if (hockeyKeys['w']) hockeyP1.vy -= accel;
            else if (hockeyKeys['s']) hockeyP1.vy += accel;
            else hockeyP1.vy *= friction;

            // Clamp P1 velocity
            hockeyP1.vx = Math.max(-maxSpeed, Math.min(maxSpeed, hockeyP1.vx));
            hockeyP1.vy = Math.max(-maxSpeed, Math.min(maxSpeed, hockeyP1.vy));

            // Apply P1 movement with bounds
            hockeyP1.x += hockeyP1.vx;
            hockeyP1.y += hockeyP1.vy;
            hockeyP1.x = Math.max(30, Math.min(370, hockeyP1.x));
            hockeyP1.y = Math.max(270, Math.min(470, hockeyP1.y));

            // P2 movement (top half) - Arrow keys or AI
            if (p2Modes.airhockey === 'ai' && !(mp && mp.connected)) {
                // AI follows the puck
                const aiReaction = 0.15;
                const targetX = hockeyPuck.x;
                const targetY = Math.min(hockeyPuck.y, 180); // Stay in top half

                if (targetX < hockeyP2.x - 15) hockeyP2.vx -= accel * aiReaction * 8;
                else if (targetX > hockeyP2.x + 15) hockeyP2.vx += accel * aiReaction * 8;
                else hockeyP2.vx *= friction;

                if (targetY < hockeyP2.y - 15) hockeyP2.vy -= accel * aiReaction * 8;
                else if (targetY > hockeyP2.y + 15) hockeyP2.vy += accel * aiReaction * 8;
                else hockeyP2.vy *= friction;
            } else {
                if (hockeyKeys['ArrowLeft']) hockeyP2.vx -= accel;
                else if (hockeyKeys['ArrowRight']) hockeyP2.vx += accel;
                else hockeyP2.vx *= friction;

                if (hockeyKeys['ArrowUp']) hockeyP2.vy -= accel;
                else if (hockeyKeys['ArrowDown']) hockeyP2.vy += accel;
                else hockeyP2.vy *= friction;
            }

            // Clamp P2 velocity
            hockeyP2.vx = Math.max(-maxSpeed, Math.min(maxSpeed, hockeyP2.vx));
            hockeyP2.vy = Math.max(-maxSpeed, Math.min(maxSpeed, hockeyP2.vy));

            // Apply P2 movement with bounds
            hockeyP2.x += hockeyP2.vx;
            hockeyP2.y += hockeyP2.vy;
            hockeyP2.x = Math.max(30, Math.min(370, hockeyP2.x));
            hockeyP2.y = Math.max(30, Math.min(230, hockeyP2.y));

            // Puck physics
            hockeyPuck.x += hockeyPuck.vx;
            hockeyPuck.y += hockeyPuck.vy;

            // Wall bounce
            if (hockeyPuck.x <= 15 || hockeyPuck.x >= 385) hockeyPuck.vx *= -0.9;
            hockeyPuck.x = Math.max(15, Math.min(385, hockeyPuck.x));

            // Goal check
            if (hockeyPuck.y <= 10) {
                if (hockeyPuck.x > 140 && hockeyPuck.x < 260) {
                    hockeyScores[1]++;
                    updateHockeyScores();
                    resetHockeyPositions();
                } else {
                    hockeyPuck.vy *= -0.9;
                    hockeyPuck.y = 15;
                }
            }
            if (hockeyPuck.y >= 490) {
                if (hockeyPuck.x > 140 && hockeyPuck.x < 260) {
                    hockeyScores[2]++;
                    updateHockeyScores();
                    resetHockeyPositions();
                } else {
                    hockeyPuck.vy *= -0.9;
                    hockeyPuck.y = 485;
                }
            }

            // Paddle collision
            [hockeyP1, hockeyP2].forEach(paddle => {
                const dx = hockeyPuck.x - paddle.x;
                const dy = hockeyPuck.y - paddle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < hockeyPuck.radius + paddle.radius) {
                    const angle = Math.atan2(dy, dx);
                    const speed = Math.sqrt(hockeyPuck.vx ** 2 + hockeyPuck.vy ** 2) + 1;
                    hockeyPuck.vx = Math.cos(angle) * speed;
                    hockeyPuck.vy = Math.sin(angle) * speed;
                    hockeyPuck.x = paddle.x + Math.cos(angle) * (hockeyPuck.radius + paddle.radius + 1);
                    hockeyPuck.y = paddle.y + Math.sin(angle) * (hockeyPuck.radius + paddle.radius + 1);
                }
            });

            // Friction
            hockeyPuck.vx *= 0.99;
            hockeyPuck.vy *= 0.99;

            // Draw
            hockeyCtx.fillStyle = '#1a3d1a';
            hockeyCtx.fillRect(0, 0, 400, 500);

            // Center line
            hockeyCtx.strokeStyle = '#2a5a2a';
            hockeyCtx.lineWidth = 2;
            hockeyCtx.beginPath();
            hockeyCtx.moveTo(0, 250);
            hockeyCtx.lineTo(400, 250);
            hockeyCtx.stroke();

            // Center circle
            hockeyCtx.beginPath();
            hockeyCtx.arc(200, 250, 50, 0, Math.PI * 2);
            hockeyCtx.stroke();

            // Goals
            hockeyCtx.fillStyle = '#333';
            hockeyCtx.fillRect(140, 0, 120, 10);
            hockeyCtx.fillRect(140, 490, 120, 10);

            // Paddles
            hockeyCtx.shadowBlur = 15;
            hockeyCtx.shadowColor = '#00ff88';
            hockeyCtx.fillStyle = '#00ff88';
            hockeyCtx.beginPath();
            hockeyCtx.arc(hockeyP1.x, hockeyP1.y, hockeyP1.radius, 0, Math.PI * 2);
            hockeyCtx.fill();

            hockeyCtx.shadowColor = '#ff6b6b';
            hockeyCtx.fillStyle = '#ff6b6b';
            hockeyCtx.beginPath();
            hockeyCtx.arc(hockeyP2.x, hockeyP2.y, hockeyP2.radius, 0, Math.PI * 2);
            hockeyCtx.fill();

            // Puck
            hockeyCtx.shadowColor = '#fff';
            hockeyCtx.fillStyle = '#111';
            hockeyCtx.beginPath();
            hockeyCtx.arc(hockeyPuck.x, hockeyPuck.y, hockeyPuck.radius, 0, Math.PI * 2);
            hockeyCtx.fill();
            hockeyCtx.strokeStyle = '#fff';
            hockeyCtx.lineWidth = 2;
            hockeyCtx.stroke();

            hockeyCtx.shadowBlur = 0;

            hockeyAnimationId = requestAnimationFrame(hockeyLoop);
        }

        // ==================== BATTLESHIP ====================
        let bsGrids, bsShips, bsCurrentPlayer, bsPhase, bsShipsPlaced;

        function initBattleship() {
            bsGrids = {1: Array(10).fill(null).map(() => Array(10).fill(0)), 2: Array(10).fill(null).map(() => Array(10).fill(0))};
            bsShips = {1: [], 2: []};
            bsCurrentPlayer = 1;
            bsPhase = 'placing';
            bsShipsPlaced = {1: 0, 2: 0};
            document.getElementById('battleshipStatus').textContent = 'Player 1: Place 5 ships!';
            document.getElementById('bsInfo').textContent = 'Click cells to place ships';
            renderBattleshipGrids();
        }

        function renderBattleshipGrids() {
            [1, 2].forEach(p => {
                const grid = document.getElementById(`bsGrid${p}`);
                grid.innerHTML = '';
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 10; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'bs-cell';
                        const val = bsGrids[p][row][col];
                        if (val === 1 && (bsPhase === 'placing' && bsCurrentPlayer === p || bsPhase === 'gameover')) cell.classList.add('ship');
                        if (val === 2) cell.classList.add('hit');
                        if (val === 3) cell.classList.add('miss');
                        cell.onclick = () => handleBsClick(p, row, col);
                        grid.appendChild(cell);
                    }
                }
            });
        }

        function handleBsClick(player, row, col) {
            if (bsPhase === 'placing') {
                if (player !== bsCurrentPlayer) return;
                if (bsGrids[player][row][col] === 1) return;
                bsGrids[player][row][col] = 1;
                bsShipsPlaced[player]++;
                renderBattleshipGrids();

                if (bsShipsPlaced[player] >= 5) {
                    if (bsCurrentPlayer === 1) {
                        bsCurrentPlayer = 2;
                        document.getElementById('battleshipStatus').textContent = 'Player 2: Place 5 ships!';
                    } else {
                        bsPhase = 'playing';
                        bsCurrentPlayer = 1;
                        document.getElementById('battleshipStatus').textContent = "Player 1's turn to attack!";
                        document.getElementById('bsInfo').textContent = 'Click enemy grid to fire';
                    }
                }
            } else if (bsPhase === 'playing') {
                if (player === bsCurrentPlayer) return;
                if (bsGrids[player][row][col] >= 2) return;

                if (bsGrids[player][row][col] === 1) {
                    bsGrids[player][row][col] = 2;
                    document.getElementById('bsInfo').textContent = 'HIT!';
                } else {
                    bsGrids[player][row][col] = 3;
                    document.getElementById('bsInfo').textContent = 'Miss...';
                }
                renderBattleshipGrids();

                // Check win
                const enemy = bsCurrentPlayer === 1 ? 2 : 1;
                const shipsLeft = bsGrids[enemy].flat().filter(c => c === 1).length;
                if (shipsLeft === 0) {
                    bsPhase = 'gameover';
                    document.getElementById('battleshipStatus').textContent = `Player ${bsCurrentPlayer} wins!`;
                    document.getElementById('bsInfo').textContent = 'All ships sunk!';
                } else {
                    bsCurrentPlayer = bsCurrentPlayer === 1 ? 2 : 1;
                    document.getElementById('battleshipStatus').textContent = `Player ${bsCurrentPlayer}'s turn to attack!`;
                }
            }
        }

        // ==================== SIMON SAYS ====================
        let simonSequence, simonPlayerSequence, simonCurrentPlayer, simonScores, simonPlaying, simonShowingPattern;
        const SIMON_COLORS = ['green', 'red', 'yellow', 'blue', 'purple', 'orange', 'pink', 'cyan', 'lime', 'coral', 'teal', 'gold', 'indigo', 'mint', 'salmon', 'violet'];

        function initSimon() {
            simonSequence = [];
            simonPlayerSequence = [];
            simonCurrentPlayer = 1;
            simonScores = {1: 0, 2: 0};
            simonPlaying = true;
            simonShowingPattern = false;
            document.getElementById('simonScore1').textContent = '0';
            document.getElementById('simonScore2').textContent = '0';
            document.getElementById('simonInfo').textContent = 'Current Player: P1';
            addSimonColor();
            setTimeout(() => playSimonSequence(), 300);
        }

        function addSimonColor() {
            simonSequence.push(SIMON_COLORS[Math.floor(Math.random() * SIMON_COLORS.length)]);
        }

        function playSimonSequence() {
            simonShowingPattern = true;
            document.getElementById('simonStatus').textContent = 'Watch the pattern!';
            let i = 0;
            const interval = setInterval(() => {
                if (i >= simonSequence.length) {
                    clearInterval(interval);
                    simonShowingPattern = false;
                    document.getElementById('simonStatus').textContent = 'Your turn!';
                    return;
                }
                flashSimonButton(simonSequence[i]);
                i++;
            }, 350);
        }

        function flashSimonButton(color) {
            const btn = document.querySelector(`.simon-btn[data-color="${color}"]`);
            btn.classList.add('active');
            sound.play('simon', { color });
            setTimeout(() => btn.classList.remove('active'), 250);
        }

        document.querySelectorAll('.simon-btn').forEach(btn => {
            const handleSimonClick = () => {
                if (!simonPlaying || simonShowingPattern) return;
                const color = btn.dataset.color;
                flashSimonButton(color);
                simonPlayerSequence.push(color);

                const idx = simonPlayerSequence.length - 1;
                if (simonPlayerSequence[idx] !== simonSequence[idx]) {
                    // Wrong!
                    simonScores[simonCurrentPlayer === 1 ? 2 : 1]++;
                    document.getElementById(`simonScore${simonCurrentPlayer === 1 ? 2 : 1}`).textContent = simonScores[simonCurrentPlayer === 1 ? 2 : 1];
                    document.getElementById('simonStatus').textContent = `P${simonCurrentPlayer} made a mistake!`;

                    if (simonScores[1] >= 3 || simonScores[2] >= 3) {
                        simonPlaying = false;
                        document.getElementById('simonStatus').textContent = `Player ${simonScores[1] >= 3 ? 1 : 2} wins!`;
                    } else {
                        simonCurrentPlayer = simonCurrentPlayer === 1 ? 2 : 1;
                        simonSequence = [];
                        simonPlayerSequence = [];
                        addSimonColor();
                        document.getElementById('simonInfo').textContent = `Current Player: P${simonCurrentPlayer}`;
                        setTimeout(() => playSimonSequence(), 600);
                    }
                } else if (simonPlayerSequence.length === simonSequence.length) {
                    // Completed sequence
                    document.getElementById('simonStatus').textContent = 'Correct! Watch next...';
                    simonPlayerSequence = [];
                    addSimonColor();
                    setTimeout(() => playSimonSequence(), 600);
                }
            };

            // Prevent duplicate handling from both click and touchstart
            let lastTouch = 0;
            btn.addEventListener('click', () => {
                if (Date.now() - lastTouch < 300) return;
                handleSimonClick();
            });
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                lastTouch = Date.now();
                handleSimonClick();
            }, { passive: false });
        });

        // ==================== TETRIS ====================
        let tetrisCanvas, tetrisCtx, tetrisNextCanvas, tetrisNextCtx;
        let tetrisBoard, tetrisCurrentPiece, tetrisNextPiece;
        let tetrisScore, tetrisLevel, tetrisLines;
        let tetrisGameRunning, tetrisAnimationId, tetrisDropTime, tetrisLastDrop;

        const TETRIS_COLS = 10;
        const TETRIS_ROWS = 20;
        const TETRIS_BLOCK = 30;  // Big blocks for big game space

        const TETRIS_PIECES = {
            I: { shape: [[1,1,1,1]], color: '#00f5ff' },
            O: { shape: [[1,1],[1,1]], color: '#ffdd00' },
            T: { shape: [[0,1,0],[1,1,1]], color: '#aa00ff' },
            S: { shape: [[0,1,1],[1,1,0]], color: '#00ff88' },
            Z: { shape: [[1,1,0],[0,1,1]], color: '#ff4444' },
            J: { shape: [[1,0,0],[1,1,1]], color: '#4488ff' },
            L: { shape: [[0,0,1],[1,1,1]], color: '#ff8800' }
        };

        function initTetris() {
            tetrisCanvas = document.getElementById('tetrisCanvas');
            tetrisCtx = tetrisCanvas.getContext('2d');
            tetrisNextCanvas = document.getElementById('tetrisNext');
            tetrisNextCtx = tetrisNextCanvas.getContext('2d');

            // Reset state
            tetrisBoard = Array(TETRIS_ROWS).fill(null).map(() => Array(TETRIS_COLS).fill(0));
            tetrisScore = 0;
            tetrisLevel = 1;
            tetrisLines = 0;
            tetrisGameRunning = false;

            updateTetrisDisplay();
            drawTetrisBoard();

            document.getElementById('tetrisOverlay').classList.remove('hidden');
            document.getElementById('tetrisMessage').textContent = 'Press START';
        }

        function startTetris() {
            if (tetrisGameRunning) {
                stopTetris();
            }

            tetrisBoard = Array(TETRIS_ROWS).fill(null).map(() => Array(TETRIS_COLS).fill(0));
            tetrisScore = 0;
            tetrisLevel = 1;
            tetrisLines = 0;
            tetrisGameRunning = true;
            tetrisDropTime = 1000;
            tetrisLastDrop = Date.now();

            tetrisCurrentPiece = spawnTetrisPiece();
            tetrisNextPiece = spawnTetrisPiece();

            document.getElementById('tetrisOverlay').classList.add('hidden');
            updateTetrisDisplay();

            tetrisAnimationId = requestAnimationFrame(tetrisGameLoop);
        }

        function stopTetris() {
            tetrisGameRunning = false;
            if (tetrisAnimationId) {
                cancelAnimationFrame(tetrisAnimationId);
            }
        }

        function spawnTetrisPiece() {
            const pieces = Object.keys(TETRIS_PIECES);
            const type = pieces[Math.floor(Math.random() * pieces.length)];
            const piece = TETRIS_PIECES[type];
            return {
                shape: piece.shape.map(row => [...row]),
                color: piece.color,
                x: Math.floor(TETRIS_COLS / 2) - Math.floor(piece.shape[0].length / 2),
                y: 0
            };
        }

        function tetrisGameLoop() {
            if (!tetrisGameRunning) return;

            const now = Date.now();
            if (now - tetrisLastDrop > tetrisDropTime) {
                moveTetrisPiece(0, 1);
                tetrisLastDrop = now;
            }

            drawTetrisBoard();
            tetrisAnimationId = requestAnimationFrame(tetrisGameLoop);
        }

        function drawTetrisBoard() {
            tetrisCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            tetrisCtx.fillRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);

            // Draw grid lines
            tetrisCtx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            tetrisCtx.lineWidth = 1;
            for (let x = 0; x <= TETRIS_COLS; x++) {
                tetrisCtx.beginPath();
                tetrisCtx.moveTo(x * TETRIS_BLOCK, 0);
                tetrisCtx.lineTo(x * TETRIS_BLOCK, tetrisCanvas.height);
                tetrisCtx.stroke();
            }
            for (let y = 0; y <= TETRIS_ROWS; y++) {
                tetrisCtx.beginPath();
                tetrisCtx.moveTo(0, y * TETRIS_BLOCK);
                tetrisCtx.lineTo(tetrisCanvas.width, y * TETRIS_BLOCK);
                tetrisCtx.stroke();
            }

            // Draw placed blocks
            for (let y = 0; y < TETRIS_ROWS; y++) {
                for (let x = 0; x < TETRIS_COLS; x++) {
                    if (tetrisBoard[y][x]) {
                        drawTetrisBlock(tetrisCtx, x, y, tetrisBoard[y][x]);
                    }
                }
            }

            // Draw current piece
            if (tetrisCurrentPiece) {
                // Draw ghost piece
                let ghostY = tetrisCurrentPiece.y;
                while (canMoveTetris(0, ghostY - tetrisCurrentPiece.y + 1)) {
                    ghostY++;
                }
                tetrisCurrentPiece.shape.forEach((row, dy) => {
                    row.forEach((val, dx) => {
                        if (val) {
                            tetrisCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                            tetrisCtx.fillRect(
                                (tetrisCurrentPiece.x + dx) * TETRIS_BLOCK + 2,
                                (ghostY + dy) * TETRIS_BLOCK + 2,
                                TETRIS_BLOCK - 4,
                                TETRIS_BLOCK - 4
                            );
                        }
                    });
                });

                // Draw actual piece
                tetrisCurrentPiece.shape.forEach((row, dy) => {
                    row.forEach((val, dx) => {
                        if (val) {
                            drawTetrisBlock(tetrisCtx, tetrisCurrentPiece.x + dx, tetrisCurrentPiece.y + dy, tetrisCurrentPiece.color);
                        }
                    });
                });
            }

            // Draw next piece preview
            tetrisNextCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            tetrisNextCtx.fillRect(0, 0, tetrisNextCanvas.width, tetrisNextCanvas.height);

            if (tetrisNextPiece) {
                const previewBlock = 20;
                const offsetX = (tetrisNextCanvas.width - tetrisNextPiece.shape[0].length * previewBlock) / 2;
                const offsetY = (tetrisNextCanvas.height - tetrisNextPiece.shape.length * previewBlock) / 2;

                tetrisNextPiece.shape.forEach((row, dy) => {
                    row.forEach((val, dx) => {
                        if (val) {
                            tetrisNextCtx.fillStyle = tetrisNextPiece.color;
                            tetrisNextCtx.fillRect(
                                offsetX + dx * previewBlock + 2,
                                offsetY + dy * previewBlock + 2,
                                previewBlock - 4,
                                previewBlock - 4
                            );
                            tetrisNextCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                            tetrisNextCtx.strokeRect(
                                offsetX + dx * previewBlock + 2,
                                offsetY + dy * previewBlock + 2,
                                previewBlock - 4,
                                previewBlock - 4
                            );
                        }
                    });
                });
            }
        }

        function drawTetrisBlock(ctx, x, y, color) {
            const bx = x * TETRIS_BLOCK;
            const by = y * TETRIS_BLOCK;
            const size = TETRIS_BLOCK - 2;

            // Main block
            ctx.fillStyle = color;
            ctx.fillRect(bx + 1, by + 1, size, size);

            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(bx + 1, by + 1, size, 4);
            ctx.fillRect(bx + 1, by + 1, 4, size);

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(bx + size - 3, by + 1, 4, size);
            ctx.fillRect(bx + 1, by + size - 3, size, 4);
        }

        function canMoveTetris(dx, dy, newShape = null) {
            const shape = newShape || tetrisCurrentPiece.shape;
            const newX = tetrisCurrentPiece.x + dx;
            const newY = tetrisCurrentPiece.y + dy;

            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = newX + x;
                        const boardY = newY + y;

                        if (boardX < 0 || boardX >= TETRIS_COLS || boardY >= TETRIS_ROWS) {
                            return false;
                        }
                        if (boardY >= 0 && tetrisBoard[boardY][boardX]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function moveTetrisPiece(dx, dy) {
            if (canMoveTetris(dx, dy)) {
                tetrisCurrentPiece.x += dx;
                tetrisCurrentPiece.y += dy;
                return true;
            } else if (dy > 0) {
                // Can't move down, lock piece
                lockTetrisPiece();
                return false;
            }
            return false;
        }

        function rotateTetrisPiece() {
            const shape = tetrisCurrentPiece.shape;
            const rotated = shape[0].map((_, i) => shape.map(row => row[i]).reverse());

            if (canMoveTetris(0, 0, rotated)) {
                tetrisCurrentPiece.shape = rotated;
                sound.play('click');
            } else if (canMoveTetris(-1, 0, rotated)) {
                tetrisCurrentPiece.x -= 1;
                tetrisCurrentPiece.shape = rotated;
                sound.play('click');
            } else if (canMoveTetris(1, 0, rotated)) {
                tetrisCurrentPiece.x += 1;
                tetrisCurrentPiece.shape = rotated;
                sound.play('click');
            }
        }

        function hardDropTetris() {
            while (moveTetrisPiece(0, 1)) {
                tetrisScore += 2;
            }
            sound.play('whoosh');
        }

        function lockTetrisPiece() {
            tetrisCurrentPiece.shape.forEach((row, dy) => {
                row.forEach((val, dx) => {
                    if (val) {
                        const boardY = tetrisCurrentPiece.y + dy;
                        const boardX = tetrisCurrentPiece.x + dx;
                        if (boardY >= 0) {
                            tetrisBoard[boardY][boardX] = tetrisCurrentPiece.color;
                        }
                    }
                });
            });

            sound.play('hit');
            clearTetrisLines();

            tetrisCurrentPiece = tetrisNextPiece;
            tetrisNextPiece = spawnTetrisPiece();

            // Check game over
            if (!canMoveTetris(0, 0)) {
                tetrisGameOver();
            }
        }

        function clearTetrisLines() {
            let linesCleared = 0;

            for (let y = TETRIS_ROWS - 1; y >= 0; y--) {
                if (tetrisBoard[y].every(cell => cell !== 0)) {
                    tetrisBoard.splice(y, 1);
                    tetrisBoard.unshift(Array(TETRIS_COLS).fill(0));
                    linesCleared++;
                    y++; // Check same row again
                }
            }

            if (linesCleared > 0) {
                const points = [0, 100, 300, 500, 800];
                tetrisScore += points[linesCleared] * tetrisLevel;
                tetrisLines += linesCleared;
                tetrisLevel = Math.floor(tetrisLines / 10) + 1;
                tetrisDropTime = Math.max(100, 1000 - (tetrisLevel - 1) * 100);

                if (linesCleared === 4) {
                    sound.play('win');
                } else {
                    sound.play('score');
                }

                updateTetrisDisplay();
            }
        }

        function tetrisGameOver() {
            tetrisGameRunning = false;
            cancelAnimationFrame(tetrisAnimationId);

            sound.play('lose');

            document.getElementById('tetrisOverlay').classList.remove('hidden');
            document.getElementById('tetrisMessage').innerHTML =
                `GAME OVER<br><br>Score: ${tetrisScore}<br>Level: ${tetrisLevel}<br>Lines: ${tetrisLines}`;
        }

        function updateTetrisDisplay() {
            document.getElementById('tetrisScore').textContent = tetrisScore;
            document.getElementById('tetrisLevel').textContent = tetrisLevel;
            document.getElementById('tetrisLines').textContent = tetrisLines;
        }

        // Tetris keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!tetrisGameRunning) return;
            if (!document.getElementById('tetrisModal').classList.contains('active')) return;

            switch (e.key) {
                case 'ArrowLeft':
                    moveTetrisPiece(-1, 0);
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    moveTetrisPiece(1, 0);
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    moveTetrisPiece(0, 1);
                    tetrisScore += 1;
                    e.preventDefault();
                    break;
                case 'ArrowUp':
                    rotateTetrisPiece();
                    e.preventDefault();
                    break;
                case ' ':
                    hardDropTetris();
                    e.preventDefault();
                    break;
            }
        });

        // Tetris mobile controls setup
        (function setupTetrisMobileControls() {
            const setupBtn = (id, action) => {
                const btn = document.getElementById(id);
                if (!btn || btn.dataset.setup) return;
                btn.dataset.setup = 'true';
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); action(); }, { passive: false });
                btn.addEventListener('click', action);
            };

            setupBtn('tetrisLeft', () => moveTetrisPiece(-1, 0));
            setupBtn('tetrisRight', () => moveTetrisPiece(1, 0));
            setupBtn('tetrisDown', () => { moveTetrisPiece(0, 1); tetrisScore += 1; });
            setupBtn('tetrisRotate', () => rotateTetrisPiece());
            setupBtn('tetrisDrop', () => hardDropTetris());
        })();

        // ==================== HUNGRY HIPPOS ====================
        let hipposCanvas, hipposCtx;
        let hipposGameRunning, hipposAnimationId;
        let hippoFood, hippo1, hippo2;
        let hipposScore1, hipposScore2;
        let hippoKeys = { q: false, p: false, qCanChomp: true, pCanChomp: true };

        const FOOD_TYPES = ['üçé', 'üçä', 'üçã', 'üçá', 'üçì', 'üçí', 'ü•ù', 'üçë'];

        function initHippos() {
            hipposCanvas = document.getElementById('hipposCanvas');
            hipposCtx = hipposCanvas.getContext('2d');

            hipposScore1 = 0;
            hipposScore2 = 0;
            hipposGameRunning = false;
            hippoFood = [];

            updateHipposDisplay();
            drawHipposGame();

            document.getElementById('hipposStatus').textContent = 'Press START to play!';
        }

        function startHippos() {
            if (hipposGameRunning) {
                stopHippos();
            }

            hipposScore1 = 0;
            hipposScore2 = 0;
            hippoFood = [];
            hipposGameRunning = true;

            // Initialize hippos - positioned on left and right sides
            hippo1 = {
                x: 50,
                y: hipposCanvas.height / 2,
                targetY: hipposCanvas.height / 2,
                chomping: false,
                chompFrame: 0,
                hasCheckedFood: false,
                direction: 1, // facing right
                color: '#00ff88',
                bodyColor: '#7cb87c',
                caughtFood: null // Food being pulled back
            };

            hippo2 = {
                x: hipposCanvas.width - 50,
                y: hipposCanvas.height / 2,
                targetY: hipposCanvas.height / 2,
                chomping: false,
                chompFrame: 0,
                hasCheckedFood: false,
                direction: -1, // facing left
                color: '#ff6b6b',
                bodyColor: '#c97878',
                caughtFood: null
            };

            // Reset chomp state
            hippoKeys.qCanChomp = true;
            hippoKeys.pCanChomp = true;

            // Spawn initial food
            for (let i = 0; i < 15; i++) {
                spawnHippoFood();
            }

            updateHipposDisplay();
            document.getElementById('hipposStatus').textContent = 'CHOMP! Tap Q (P1) or P (P2) rapidly!';

            hipposAnimationId = requestAnimationFrame(hipposGameLoop);

            // Spawn more food periodically
            hipposFoodInterval = setInterval(() => {
                if (hipposGameRunning && hippoFood.length < 20) {
                    spawnHippoFood();
                    spawnHippoFood();
                }
            }, 2000);

            // End game after 30 seconds
            hipposEndTimeout = setTimeout(() => {
                endHipposGame();
            }, 30000);
        }

        let hipposFoodInterval, hipposEndTimeout;

        function stopHippos() {
            hipposGameRunning = false;
            if (hipposAnimationId) cancelAnimationFrame(hipposAnimationId);
            if (hipposFoodInterval) clearInterval(hipposFoodInterval);
            if (hipposEndTimeout) clearTimeout(hipposEndTimeout);
        }

        function spawnHippoFood() {
            const food = {
                x: 100 + Math.random() * (hipposCanvas.width - 200),
                y: Math.random() * hipposCanvas.height,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3,
                type: FOOD_TYPES[Math.floor(Math.random() * FOOD_TYPES.length)],
                size: 20 + Math.random() * 10
            };
            hippoFood.push(food);
        }

        function hipposGameLoop() {
            if (!hipposGameRunning) return;

            updateHippos();
            drawHipposGame();

            hipposAnimationId = requestAnimationFrame(hipposGameLoop);
        }

        function updateHippos() {
            // Update food positions (bouncing)
            hippoFood.forEach(food => {
                food.x += food.vx;
                food.y += food.vy;

                // Bounce off walls
                if (food.x < 80 || food.x > hipposCanvas.width - 80) {
                    food.vx *= -1;
                    food.x = Math.max(80, Math.min(hipposCanvas.width - 80, food.x));
                }
                if (food.y < 20 || food.y > hipposCanvas.height - 20) {
                    food.vy *= -1;
                    food.y = Math.max(20, Math.min(hipposCanvas.height - 20, food.y));
                }

                // Add some randomness
                food.vx += (Math.random() - 0.5) * 0.2;
                food.vy += (Math.random() - 0.5) * 0.2;

                // Limit speed
                food.vx = Math.max(-4, Math.min(4, food.vx));
                food.vy = Math.max(-4, Math.min(4, food.vy));
            });

            // Update hippo 1 (controlled by Q) - tap to chomp
            if (hippoKeys.q && hippoKeys.qCanChomp && !hippo1.chomping) {
                hippo1.chomping = true;
                hippo1.chompFrame = 0;
                hippo1.hasCheckedFood = false;
                hippo1.caughtFood = null;
                hippoKeys.qCanChomp = false;
            }

            if (hippo1.chomping) {
                hippo1.chompFrame += 0.04; // Slower, more deliberate chomp
                // Check for food at peak extension (frame 0.5)
                if (hippo1.chompFrame >= 0.45 && hippo1.chompFrame < 0.55 && !hippo1.hasCheckedFood) {
                    checkHippoChomp(hippo1, 1);
                    hippo1.hasCheckedFood = true;
                }
                if (hippo1.chompFrame >= 1) {
                    hippo1.chomping = false;
                    hippo1.chompFrame = 0;
                    hippo1.caughtFood = null;
                }
            }

            // Update hippo 2 (controlled by P) - tap to chomp
            if (hippoKeys.p && hippoKeys.pCanChomp && !hippo2.chomping) {
                hippo2.chomping = true;
                hippo2.chompFrame = 0;
                hippo2.hasCheckedFood = false;
                hippo2.caughtFood = null;
                hippoKeys.pCanChomp = false;
            }

            if (hippo2.chomping) {
                hippo2.chompFrame += 0.04; // Slower, more deliberate chomp
                // Check for food at peak extension (frame 0.5)
                if (hippo2.chompFrame >= 0.45 && hippo2.chompFrame < 0.55 && !hippo2.hasCheckedFood) {
                    checkHippoChomp(hippo2, 2);
                    hippo2.hasCheckedFood = true;
                }
                if (hippo2.chompFrame >= 1) {
                    hippo2.chomping = false;
                    hippo2.chompFrame = 0;
                    hippo2.caughtFood = null;
                }
            }

            // Hippos follow nearest food vertically
            updateHippoTarget(hippo1);
            updateHippoTarget(hippo2);

            // Smooth movement towards target
            hippo1.y += (hippo1.targetY - hippo1.y) * 0.1;
            hippo2.y += (hippo2.targetY - hippo2.y) * 0.1;

            updateHipposDisplay();
        }

        function updateHippoTarget(hippo) {
            let nearestFood = null;
            let nearestDist = Infinity;

            hippoFood.forEach(food => {
                const dist = Math.abs(food.y - hippo.y);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestFood = food;
                }
            });

            if (nearestFood) {
                hippo.targetY = nearestFood.y;
            }

            // Clamp to canvas
            hippo.targetY = Math.max(40, Math.min(hipposCanvas.height - 40, hippo.targetY));
        }

        function checkHippoChomp(hippo, player) {
            const chompReach = 90;
            const chompX = hippo.x + (hippo.direction * chompReach);

            for (let i = hippoFood.length - 1; i >= 0; i--) {
                const food = hippoFood[i];
                const dx = food.x - chompX;
                const dy = food.y - hippo.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 50) {
                    // Caught! Store the food to animate it being pulled back
                    hippo.caughtFood = { type: food.type, size: food.size };
                    hippoFood.splice(i, 1);
                    if (player === 1) {
                        hipposScore1++;
                    } else {
                        hipposScore2++;
                    }
                    sound.play('pop');
                    break; // Only catch one food per chomp
                }
            }
        }

        function drawHipposGame() {
            const ctx = hipposCtx;

            // Clear with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, hipposCanvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#16213e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, hipposCanvas.width, hipposCanvas.height);

            // Draw center zone
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.fillRect(100, 0, hipposCanvas.width - 200, hipposCanvas.height);

            // Draw player zones
            ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            ctx.fillRect(0, 0, 100, hipposCanvas.height);
            ctx.fillStyle = 'rgba(255, 107, 107, 0.1)';
            ctx.fillRect(hipposCanvas.width - 100, 0, 100, hipposCanvas.height);

            // Draw food with glow
            hippoFood.forEach(food => {
                ctx.save();
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10;
                ctx.font = `${food.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(food.type, food.x, food.y);
                ctx.restore();
            });

            // Draw hippos
            drawHippo(hippo1);
            drawHippo(hippo2);
        }

        function drawHippo(hippo) {
            const ctx = hipposCtx;

            // Calculate neck extension (0 to 1 and back)
            const extensionCurve = Math.sin(hippo.chompFrame * Math.PI);
            const neckExtension = hippo.chomping ? extensionCurve * 70 : 0;

            // Mouth open amount (opens as extending, closes as retracting)
            const mouthOpen = hippo.chomping ? extensionCurve * 25 : 0;

            const bodyX = hippo.x;
            const headX = bodyX + (hippo.direction * (30 + neckExtension));

            ctx.save();

            // Draw body (stationary oval)
            ctx.fillStyle = hippo.bodyColor;
            ctx.beginPath();
            ctx.ellipse(bodyX, hippo.y, 35, 28, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw neck (always connects body to head)
            ctx.fillStyle = hippo.bodyColor;
            ctx.beginPath();
            ctx.moveTo(bodyX + hippo.direction * 20, hippo.y - 15);
            ctx.lineTo(headX - hippo.direction * 15, hippo.y - 12);
            ctx.lineTo(headX - hippo.direction * 15, hippo.y + 12);
            ctx.lineTo(bodyX + hippo.direction * 20, hippo.y + 15);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw head
            const headColor = hippo.bodyColor;
            ctx.fillStyle = headColor;
            ctx.beginPath();
            ctx.ellipse(headX, hippo.y, 25, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Draw snout/nose bump
            const snoutX = headX + hippo.direction * 18;
            ctx.fillStyle = hippo.bodyColor;
            ctx.beginPath();
            ctx.ellipse(snoutX, hippo.y + 3, 12, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Draw nostrils
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.arc(snoutX + hippo.direction * 4, hippo.y, 2, 0, Math.PI * 2);
            ctx.arc(snoutX + hippo.direction * 4, hippo.y + 6, 2, 0, Math.PI * 2);
            ctx.fill();

            // Draw mouth (opens and closes)
            const mouthY = hippo.y + 8;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;

            // Upper jaw line
            ctx.beginPath();
            ctx.moveTo(headX, mouthY - mouthOpen/2);
            ctx.lineTo(snoutX + hippo.direction * 8, mouthY - mouthOpen/2);
            ctx.stroke();

            // Lower jaw line
            ctx.beginPath();
            ctx.moveTo(headX, mouthY + mouthOpen/2);
            ctx.lineTo(snoutX + hippo.direction * 8, mouthY + mouthOpen/2);
            ctx.stroke();

            // Draw inside of mouth when open
            if (mouthOpen > 5) {
                ctx.fillStyle = '#8B4557';
                ctx.beginPath();
                ctx.ellipse(headX + hippo.direction * 10, mouthY, 10, mouthOpen/2.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Teeth
                ctx.fillStyle = '#fff';
                for (let i = 0; i < 3; i++) {
                    const toothX = headX + hippo.direction * (5 + i * 6);
                    ctx.beginPath();
                    ctx.moveTo(toothX, mouthY - mouthOpen/2);
                    ctx.lineTo(toothX - 2, mouthY - mouthOpen/2 + 4);
                    ctx.lineTo(toothX + 2, mouthY - mouthOpen/2 + 4);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Draw eye
            const eyeX = headX - hippo.direction * 5;
            const eyeY = hippo.y - 8;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(eyeX, eyeY, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(eyeX + hippo.direction * 2, eyeY, 3, 0, Math.PI * 2);
            ctx.fill();

            // Draw ear
            ctx.fillStyle = hippo.bodyColor;
            ctx.beginPath();
            ctx.ellipse(headX - hippo.direction * 15, hippo.y - 15, 8, 5, hippo.direction * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Draw caught food being pulled back
            if (hippo.caughtFood && hippo.chompFrame > 0.5) {
                const pullProgress = (hippo.chompFrame - 0.5) / 0.5; // 0 to 1 as retracting
                const foodX = headX + hippo.direction * 15 * (1 - pullProgress);
                ctx.font = `${hippo.caughtFood.size * (1 - pullProgress * 0.5)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = 1 - pullProgress;
                ctx.fillText(hippo.caughtFood.type, foodX, hippo.y + 5);
            }

            ctx.restore();

            // Draw player indicator
            ctx.fillStyle = hippo.color;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(hippo.direction === 1 ? 'P1 [Q]' : 'P2 [P]', bodyX, hippo.y + 50);
        }

        function endHipposGame() {
            stopHippos();

            let winner;
            if (hipposScore1 > hipposScore2) {
                winner = 'Player 1 WINS!';
                sound.play('win');
            } else if (hipposScore2 > hipposScore1) {
                winner = 'Player 2 WINS!';
                sound.play('win');
            } else {
                winner = "It's a TIE!";
                sound.play('score');
            }

            document.getElementById('hipposStatus').textContent = winner;
        }

        function updateHipposDisplay() {
            document.getElementById('hipposScore1').textContent = hipposScore1;
            document.getElementById('hipposScore2').textContent = hipposScore2;
            document.getElementById('hipposFood').textContent = hippoFood.length;
        }

        // Hungry Hippos keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!hipposGameRunning) return;
            if (!document.getElementById('hipposModal').classList.contains('active')) return;

            if (e.key.toLowerCase() === 'q') {
                hippoKeys.q = true;
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'p') {
                hippoKeys.p = true;
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'q') {
                hippoKeys.q = false;
                hippoKeys.qCanChomp = true; // Allow next chomp when key released
            }
            if (e.key.toLowerCase() === 'p') {
                hippoKeys.p = false;
                hippoKeys.pCanChomp = true; // Allow next chomp when key released
            }
        });

        // Hippos mobile controls setup
        (function setupHipposMobileControls() {
            const setupBtn = (id, keyProp, canChompProp) => {
                const btn = document.getElementById(id);
                if (!btn || btn.dataset.setup) return;
                btn.dataset.setup = 'true';

                const press = (e) => {
                    e.preventDefault();
                    if (!hipposGameRunning) return;
                    hippoKeys[keyProp] = true;
                    btn.classList.add('pressed');
                };

                const release = (e) => {
                    e.preventDefault();
                    hippoKeys[keyProp] = false;
                    hippoKeys[canChompProp] = true;
                    btn.classList.remove('pressed');
                };

                btn.addEventListener('touchstart', press, { passive: false });
                btn.addEventListener('touchend', release, { passive: false });
                btn.addEventListener('touchcancel', release, { passive: false });
                btn.addEventListener('mousedown', press);
                btn.addEventListener('mouseup', release);
                btn.addEventListener('mouseleave', release);
            };

            setupBtn('hipposP1Btn', 'q', 'qCanChomp');
            setupBtn('hipposP2Btn', 'p', 'pCanChomp');
        })();

        // Game name mappings for display
        const gameNames = {
            tictactoe: 'Tic Tac Toe',
            connect4: 'Connect Four',
            pong: 'Pong',
            reaction: 'Reaction Race',
            snake: 'Snake Battle',
            memory: 'Memory Match',
            rps: 'Rock Paper Scissors',
            typing: 'Typewriter',
            whack: 'Whack-a-Mole',
            airhockey: 'Air Hockey',
            battleship: 'Battleship',
            simon: 'Simon Says',
            tetris: 'Tetris',
            hippos: 'Hungry Hippos'
        };

        // Update openGame function
        const originalOpenGame = openGame;
        openGame = function(game, fromInvite = false) {
            document.getElementById(game + 'Modal').classList.add('active');
            if (game === 'tictactoe') initTTT();
            if (game === 'pong') initPong();
            if (game === 'connect4') initC4();
            if (game === 'reaction') initReaction();
            if (game === 'snake') initSnake();
            if (game === 'memory') initMemory();
            if (game === 'rps') initRPS();
            if (game === 'typing') initTyping();
            if (game === 'whack') initWhack();
            if (game === 'airhockey') initHockey();
            if (game === 'battleship') initBattleship();
            if (game === 'simon') initSimon();
            if (game === 'tetris') initTetris();
            if (game === 'hippos') initHippos();

            // Send game invite to connected player (if not already from an invite)
            if (mp && mp.connected && !fromInvite) {
                mp.inviteToGame(game, gameNames[game] || game);
            }
        }

        // Update closeGame function
        const originalCloseGame = closeGame;
        closeGame = function(game) {
            document.getElementById(game + 'Modal').classList.remove('active');
            if (game === 'pong') stopPong();
            if (game === 'snake') stopSnake();
            if (game === 'whack') stopWhack();
            if (game === 'airhockey') stopHockey();
            if (game === 'tetris') stopTetris();
            if (game === 'hippos') stopHippos();
        }

        // ==================== MULTIPLAYER MANAGER ====================
        class MultiplayerManager {
            constructor() {
                this.peer = null;
                this.conn = null;
                this.isHost = false;
                this.roomCode = null;
                this.connected = false;
                this.onDataCallback = null;
                this.myName = 'Player';
                this.opponentName = 'Player';
            }

            generateRoomCode() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let code = '';
                for (let i = 0; i < 6; i++) {
                    code += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return code;
            }

            getMyName() {
                const input = document.getElementById('playerNameInput');
                return (input && input.value.trim()) || 'Player';
            }

            async createRoom() {
                return new Promise((resolve, reject) => {
                    this.roomCode = this.generateRoomCode();
                    this.isHost = true;
                    this.myName = this.getMyName();

                    this.peer = new Peer('ryans-arcade-' + this.roomCode, {
                        debug: 0
                    });

                    this.peer.on('open', (id) => {
                        console.log('Room created with code:', this.roomCode);
                        document.getElementById('hostNameDisplay').textContent = this.myName;
                        resolve(this.roomCode);
                    });

                    this.peer.on('connection', (conn) => {
                        console.log('Guest connected!');
                        this.conn = conn;
                        this.setupConnection();
                    });

                    this.peer.on('error', (err) => {
                        console.error('Peer error:', err);
                        if (err.type === 'unavailable-id') {
                            this.peer.destroy();
                            this.createRoom().then(resolve).catch(reject);
                        } else {
                            reject(err);
                        }
                    });
                });
            }

            async joinRoom(code) {
                return new Promise((resolve, reject) => {
                    this.roomCode = code.toUpperCase();
                    this.isHost = false;
                    this.myName = this.getMyName();

                    this.peer = new Peer({
                        debug: 0
                    });

                    this.peer.on('open', () => {
                        console.log('Connecting to room:', this.roomCode);
                        this.conn = this.peer.connect('ryans-arcade-' + this.roomCode, {
                            reliable: true
                        });

                        this.conn.on('open', () => {
                            console.log('Connected to host!');
                            this.setupConnection();
                            resolve();
                        });

                        this.conn.on('error', (err) => {
                            console.error('Connection error:', err);
                            reject(err);
                        });
                    });

                    this.peer.on('error', (err) => {
                        console.error('Peer error:', err);
                        reject(err);
                    });

                    setTimeout(() => {
                        if (!this.connected) {
                            reject(new Error('Connection timeout'));
                        }
                    }, 10000);
                });
            }

            setupConnection() {
                this.connected = true;
                hideP2TogglesInMultiplayer();

                this.conn.on('data', (data) => {
                    // Handle system messages
                    if (data.type === 'playerInfo') {
                        this.opponentName = data.name;
                        this.updatePlayerDisplay();
                    } else if (data.type === 'gameInvite') {
                        showGameInvite(data.game, data.gameName, data.playerName);
                    } else if (data.type === 'gameAccept') {
                        openGame(data.game);
                    } else if (this.onDataCallback) {
                        this.onDataCallback(data);
                    }
                });

                this.conn.on('close', () => {
                    console.log('Connection closed');
                    this.connected = false;
                    this.onDisconnect();
                });

                // Send our name to the other player
                setTimeout(() => {
                    this.send({ type: 'playerInfo', name: this.myName });
                }, 100);

                this.onConnect();
            }

            updatePlayerDisplay() {
                const p1Name = this.isHost ? this.myName : this.opponentName;
                const p2Name = this.isHost ? this.opponentName : this.myName;

                document.getElementById('connectedP1Name').textContent = p1Name;
                document.getElementById('connectedP2Name').textContent = p2Name;

                if (this.isHost) {
                    document.getElementById('hostNameDisplay').textContent = this.myName;
                    document.getElementById('guestLabel').textContent = this.opponentName;
                }
            }

            send(data) {
                if (this.conn && this.connected) {
                    this.conn.send(data);
                }
            }

            onData(callback) {
                this.onDataCallback = callback;
            }

            inviteToGame(game, gameName) {
                this.send({
                    type: 'gameInvite',
                    game: game,
                    gameName: gameName,
                    playerName: this.myName
                });
            }

            acceptGameInvite(game) {
                this.send({ type: 'gameAccept', game: game });
                openGame(game, true); // true = from invite, don't send invite back
            }

            onConnect() {
                // Use requestAnimationFrame to ensure DOM updates are applied
                requestAnimationFrame(() => {
                    document.querySelector('.multiplayer-btn').classList.add('connected');
                    document.querySelector('.multiplayer-btn span:last-child').textContent = 'Connected';
                    document.querySelectorAll('.game-card').forEach(card => {
                        card.classList.add('mp-active');
                    });

                    if (this.isHost) {
                        document.getElementById('guestDot').classList.add('connected');
                        document.getElementById('guestLabel').textContent = 'Connected!';
                    }

                    this.updatePlayerDisplay();

                    // Hide all lobby screens
                    document.getElementById('lobbyOptions').style.display = 'none';
                    document.getElementById('lobbyRoom').style.display = 'none';
                    document.getElementById('lobbyJoin').style.display = 'none';
                    document.getElementById('lobbyConnecting').style.display = 'none';
                    document.getElementById('nameInputSection').style.display = 'none';
                    document.getElementById('lobbyConnected').style.display = 'block';
                    document.getElementById('lobbyStatus').textContent = 'Connected! Ready to play.';

                    // Force a reflow to ensure styles are applied
                    document.getElementById('lobbyConnected').offsetHeight;

                    sound.play('score');

                    // For guests joining via link, auto-close lobby after showing connected message briefly
                    if (!this.isHost) {
                        setTimeout(() => {
                            closeLobby();
                        }, 1500);
                    }
                });
            }

            onDisconnect() {
                document.querySelector('.multiplayer-btn').classList.remove('connected');
                document.querySelector('.multiplayer-btn span:last-child').textContent = 'Multiplayer';
                document.querySelectorAll('.game-card').forEach(card => {
                    card.classList.remove('mp-active');
                });

                if (this.isHost) {
                    document.getElementById('guestDot').classList.remove('connected');
                    document.getElementById('guestLabel').textContent = 'Disconnected';
                }

                showP2Toggles(); // Show AI/2P toggles again
                sound.play('lose');
                alert('Player disconnected!');
            }

            disconnect() {
                if (this.conn) {
                    this.conn.close();
                }
                if (this.peer) {
                    this.peer.destroy();
                }
                this.connected = false;
                this.peer = null;
                this.conn = null;
                this.roomCode = null;
            }
        }

        // Global multiplayer instance
        const mp = new MultiplayerManager();

        // Game invite popup
        let currentInvite = null;

        function showGameInvite(game, gameName, playerName) {
            // Remove existing invite
            const existing = document.querySelector('.game-invite');
            if (existing) existing.remove();

            const gameIcons = {
                tictactoe: '‚≠ï', connect4: 'üî¥', pong: 'üèì', reaction: '‚ö°',
                snake: 'üêç', memory: 'üÉè', rps: '‚úä', typing: '‚å®Ô∏è',
                whack: 'üî®', airhockey: 'üèí', battleship: 'üö¢', simon: 'üéµ'
            };

            const invite = document.createElement('div');
            invite.className = 'game-invite';
            invite.innerHTML = `
                <div class="game-invite-title">GAME INVITE</div>
                <div class="game-invite-game">${gameIcons[game] || 'üéÆ'}</div>
                <div class="game-invite-name">${playerName} wants to play ${gameName}!</div>
                <div class="game-invite-buttons">
                    <button class="game-invite-btn accept" onclick="acceptInvite('${game}')">JOIN</button>
                    <button class="game-invite-btn decline" onclick="declineInvite()">LATER</button>
                </div>
            `;
            document.body.appendChild(invite);
            sound.play('beep', { freq: 660 });
            currentInvite = game;
        }

        function acceptInvite(game) {
            const invite = document.querySelector('.game-invite');
            if (invite) invite.remove();
            mp.acceptGameInvite(game);
            currentInvite = null;
        }

        function declineInvite() {
            const invite = document.querySelector('.game-invite');
            if (invite) invite.remove();
            currentInvite = null;
        }

        // ==================== LOBBY FUNCTIONS ====================
        function openLobby() {
            document.getElementById('lobbyModal').classList.add('active');
            showLobbyOptions();
        }

        function closeLobby() {
            document.getElementById('lobbyModal').classList.remove('active');
        }

        function showLobbyOptions() {
            document.getElementById('lobbyOptions').style.display = 'flex';
            document.getElementById('lobbyRoom').style.display = 'none';
            document.getElementById('lobbyJoin').style.display = 'none';
            document.getElementById('lobbyConnecting').style.display = 'none';
            document.getElementById('lobbyConnected').style.display = 'none';
            document.getElementById('lobbyStatus').textContent = 'Choose an option to play with a friend!';
        }

        function showJoinInput() {
            document.getElementById('lobbyOptions').style.display = 'none';
            document.getElementById('lobbyJoin').style.display = 'block';
            document.getElementById('lobbyStatus').textContent = 'Enter the room code from your friend';
            document.getElementById('joinCodeInput').value = '';
            document.getElementById('joinCodeInput').focus();
        }

        async function createRoom() {
            document.getElementById('lobbyOptions').style.display = 'none';
            document.getElementById('lobbyConnecting').style.display = 'flex';
            document.getElementById('lobbyStatus').textContent = 'Creating room...';

            try {
                const code = await mp.createRoom();
                document.getElementById('roomCode').textContent = code;
                document.getElementById('lobbyConnecting').style.display = 'none';
                document.getElementById('lobbyRoom').style.display = 'block';
                document.getElementById('lobbyStatus').textContent = 'Share this code with your friend!';
            } catch (error) {
                console.error('Failed to create room:', error);
                document.getElementById('lobbyStatus').textContent = 'Failed to create room. Try again.';
                showLobbyOptions();
            }
        }

        async function joinRoom() {
            const code = document.getElementById('joinCodeInput').value.trim();
            if (code.length !== 6) {
                document.getElementById('lobbyStatus').textContent = 'Please enter a 6-character code';
                return;
            }

            document.getElementById('lobbyJoin').style.display = 'none';
            document.getElementById('lobbyConnecting').style.display = 'flex';
            document.getElementById('lobbyStatus').textContent = 'Connecting to room...';

            try {
                await mp.joinRoom(code);
            } catch (error) {
                console.error('Failed to join room:', error);
                document.getElementById('lobbyStatus').textContent = 'Failed to connect. Check the code and try again.';
                showJoinInput();
            }
        }

        function copyRoomCode() {
            navigator.clipboard.writeText(mp.roomCode).then(() => {
                const btn = event.target.closest('.room-action-btn');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<span>‚úì</span> Copied!';
                setTimeout(() => btn.innerHTML = originalText, 2000);
            });
        }

        function copyRoomLink() {
            const url = window.location.origin + window.location.pathname + '?room=' + mp.roomCode;
            navigator.clipboard.writeText(url).then(() => {
                const btn = event.target.closest('.room-action-btn');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<span>‚úì</span> Copied!';
                setTimeout(() => btn.innerHTML = originalText, 2000);
            });
        }

        // Check for room code in URL on page load
        function checkUrlForRoom() {
            const params = new URLSearchParams(window.location.search);
            const roomCode = params.get('room');
            if (roomCode) {
                openLobby();
                document.getElementById('joinCodeInput').value = roomCode;
                joinRoom();
            }
        }

        // ==================== GAME SYNC HANDLERS ====================
        mp.onData((data) => {
            switch (data.game) {
                case 'tictactoe':
                    handleTTTSync(data);
                    break;
                case 'connect4':
                    handleC4Sync(data);
                    break;
                case 'pong':
                    handlePongSync(data);
                    break;
                case 'reaction':
                    handleReactionSync(data);
                    break;
                case 'snake':
                    handleSnakeSync(data);
                    break;
                case 'memory':
                    handleMemorySync(data);
                    break;
                case 'rps':
                    handleRPSSync(data);
                    break;
                case 'typing':
                    handleTypingSync(data);
                    break;
                case 'whack':
                    handleWhackSync(data);
                    break;
                case 'airhockey':
                    handleHockeySync(data);
                    break;
                case 'battleship':
                    handleBattleshipSync(data);
                    break;
                case 'simon':
                    handleSimonSync(data);
                    break;
            }
        });

        // ==================== TIC TAC TOE SYNC ====================
        function handleTTTSync(data) {
            if (data.type === 'move') {
                tttBoard = data.board;
                tttCurrentPlayer = data.currentPlayer;
                tttGameOver = data.gameOver;
                document.getElementById('tttStatus').textContent = data.status;
                document.getElementById('tttStatus').style.color = data.statusColor;
                renderTTT();
            } else if (data.type === 'restart') {
                initTTT();
            }
        }

        // Modify TTT click handler for multiplayer
        const originalHandleTTTClick = handleTTTClick;
        handleTTTClick = function(i) {
            if (!mp.connected) {
                originalHandleTTTClick(i);
                return;
            }

            // In multiplayer: Host is X, Guest is O
            const myPlayer = mp.isHost ? 'X' : 'O';
            if (tttCurrentPlayer !== myPlayer || tttBoard[i] || tttGameOver) return;

            originalHandleTTTClick(i);

            // Sync state
            mp.send({
                game: 'tictactoe',
                type: 'move',
                board: tttBoard,
                currentPlayer: tttCurrentPlayer,
                gameOver: tttGameOver,
                status: document.getElementById('tttStatus').textContent,
                statusColor: document.getElementById('tttStatus').style.color
            });
        };

        // ==================== CONNECT FOUR SYNC ====================
        function handleC4Sync(data) {
            if (data.type === 'move') {
                c4Board = data.board;
                c4CurrentPlayer = data.currentPlayer;
                c4GameOver = data.gameOver;
                document.getElementById('c4Status').innerHTML = data.status;
                renderC4();
                renderC4Indicators();
            } else if (data.type === 'restart') {
                initC4();
            }
        }

        const originalHandleC4Click = handleC4Click;
        handleC4Click = function(col) {
            if (!mp.connected) {
                originalHandleC4Click(col);
                return;
            }

            const myPlayer = mp.isHost ? 1 : 2;
            if (c4CurrentPlayer !== myPlayer || c4GameOver) return;

            originalHandleC4Click(col);

            mp.send({
                game: 'connect4',
                type: 'move',
                board: c4Board,
                currentPlayer: c4CurrentPlayer,
                gameOver: c4GameOver,
                status: document.getElementById('c4Status').innerHTML
            });
        };

        // ==================== PONG SYNC ====================
        function handlePongSync(data) {
            if (data.type === 'state') {
                // Guest receives game state from host
                if (!mp.isHost) {
                    pongBall = data.ball;
                    pongP1 = data.p1;
                    pongP2 = data.p2;
                    pongScores = data.scores;
                    updatePongScores();
                }
            } else if (data.type === 'input') {
                // Host receives guest input
                if (mp.isHost) {
                    if (data.key === 'up') pongP2.y = Math.max(0, pongP2.y - 6);
                    if (data.key === 'down') pongP2.y = Math.min(230, pongP2.y + 6);
                }
            }
        }

        // Modify pong loop for multiplayer sync
        const originalPongLoop = pongLoop;
        pongLoop = function() {
            if (mp.connected && mp.isHost) {
                // Host runs the game and syncs state
                originalPongLoop.call(this);
                mp.send({
                    game: 'pong',
                    type: 'state',
                    ball: pongBall,
                    p1: pongP1,
                    p2: pongP2,
                    scores: pongScores
                });
            } else if (mp.connected && !mp.isHost) {
                // Guest only renders, doesn't run physics
                pongCtx.fillStyle = '#000';
                pongCtx.fillRect(0, 0, 480, 280);
                pongCtx.setLineDash([8, 8]);
                pongCtx.strokeStyle = '#333';
                pongCtx.lineWidth = 2;
                pongCtx.beginPath();
                pongCtx.moveTo(240, 0);
                pongCtx.lineTo(240, 280);
                pongCtx.stroke();
                pongCtx.setLineDash([]);
                pongCtx.shadowBlur = 15;
                pongCtx.shadowColor = '#00ff88';
                pongCtx.fillStyle = '#00ff88';
                pongCtx.fillRect(pongP1.x, pongP1.y, pongP1.width, pongP1.height);
                pongCtx.shadowColor = '#ff6b6b';
                pongCtx.fillStyle = '#ff6b6b';
                pongCtx.fillRect(pongP2.x, pongP2.y, pongP2.width, pongP2.height);
                pongCtx.shadowColor = '#fff';
                pongCtx.shadowBlur = 20;
                pongCtx.fillStyle = '#ffffff';
                pongCtx.beginPath();
                pongCtx.arc(pongBall.x, pongBall.y, pongBall.radius, 0, Math.PI * 2);
                pongCtx.fill();
                pongCtx.shadowBlur = 0;
                pongAnimationId = requestAnimationFrame(pongLoop);
            } else {
                originalPongLoop.call(this);
            }
        };

        // Send guest input to host
        const originalHandlePongKeyDown = handlePongKeyDown;
        handlePongKeyDown = function(e) {
            originalHandlePongKeyDown(e);
            if (mp.connected && !mp.isHost) {
                if (e.key === 'ArrowUp') mp.send({ game: 'pong', type: 'input', key: 'up' });
                if (e.key === 'ArrowDown') mp.send({ game: 'pong', type: 'input', key: 'down' });
            }
        };

        // ==================== SNAKE SYNC ====================
        function handleSnakeSync(data) {
            if (data.type === 'state') {
                if (!mp.isHost) {
                    snake1 = data.snake1;
                    snake2 = data.snake2;
                    snakeFood = data.food;
                    snakeGameRunning = data.running;
                    document.getElementById('snakeStatus').textContent = data.status;
                }
            } else if (data.type === 'input') {
                if (mp.isHost) {
                    const dir = data.dir;
                    if (dir.x !== -snake2.dir.x && dir.y !== -snake2.dir.y) {
                        snake2.nextDir = dir;
                    }
                }
            } else if (data.type === 'start') {
                startSnake();
            }
        }

        // Modify snake loop for multiplayer
        const originalSnakeLoop = snakeLoop;
        snakeLoop = function(timestamp) {
            if (mp.connected && mp.isHost) {
                originalSnakeLoop.call(this, timestamp);
                mp.send({
                    game: 'snake',
                    type: 'state',
                    snake1: snake1,
                    snake2: snake2,
                    food: snakeFood,
                    running: snakeGameRunning,
                    status: document.getElementById('snakeStatus').textContent
                });
            } else if (mp.connected && !mp.isHost) {
                drawSnakes();
                if (snakeGameRunning) {
                    snakeAnimationId = requestAnimationFrame(snakeLoop);
                }
            } else {
                originalSnakeLoop.call(this, timestamp);
            }
        };

        // ==================== MEMORY SYNC ====================
        function handleMemorySync(data) {
            if (data.type === 'state') {
                memoryCards = data.cards;
                memoryFlipped = data.flipped;
                memoryMatched = new Set(data.matched);
                memoryCurrentPlayer = data.currentPlayer;
                memoryScores = data.scores;
                memoryLocked = data.locked;
                document.getElementById('memoryScore1').textContent = memoryScores[1];
                document.getElementById('memoryScore2').textContent = memoryScores[2];
                document.getElementById('memoryStatus').textContent = data.status;
                document.getElementById('memoryStatus').style.color = data.statusColor;
                renderMemory();
            }
        }

        const originalFlipCard = flipCard;
        flipCard = function(index) {
            if (!mp.connected) {
                originalFlipCard(index);
                return;
            }

            const myPlayer = mp.isHost ? 1 : 2;
            if (memoryCurrentPlayer !== myPlayer) return;

            originalFlipCard(index);

            mp.send({
                game: 'memory',
                type: 'state',
                cards: memoryCards,
                flipped: memoryFlipped,
                matched: Array.from(memoryMatched),
                currentPlayer: memoryCurrentPlayer,
                scores: memoryScores,
                locked: memoryLocked,
                status: document.getElementById('memoryStatus').textContent,
                statusColor: document.getElementById('memoryStatus').style.color
            });
        };

        // ==================== ROCK PAPER SCISSORS SYNC ====================
        function handleRPSSync(data) {
            if (data.type === 'select') {
                const otherPlayer = mp.isHost ? 2 : 1;
                rpsChoices[otherPlayer] = data.choice;
                document.getElementById(`rpsP${otherPlayer}Choice`).textContent = '‚úì';
                if (rpsChoices[1] && rpsChoices[2]) {
                    setTimeout(rpsReveal, 500);
                }
            } else if (data.type === 'state') {
                rpsScores = data.scores;
                rpsRound = data.round;
                document.getElementById('rpsScore1').textContent = rpsScores[1];
                document.getElementById('rpsScore2').textContent = rpsScores[2];
                document.getElementById('rpsP1Choice').textContent = data.p1Choice;
                document.getElementById('rpsP2Choice').textContent = data.p2Choice;
                document.getElementById('rpsStatus').textContent = data.status;
            } else if (data.type === 'restart') {
                initRPS();
            }
        }

        const originalRpsSelect = rpsSelect;
        rpsSelect = function(player, choice) {
            if (!mp.connected) {
                originalRpsSelect(player, choice);
                return;
            }

            const myPlayer = mp.isHost ? 1 : 2;
            if (player !== myPlayer) return;

            originalRpsSelect(player, choice);

            mp.send({
                game: 'rps',
                type: 'select',
                choice: choice
            });
        };

        // ==================== TYPING SYNC ====================
        function handleTypingSync(data) {
            if (data.type === 'word') {
                typingCurrentWord = data.word;
                document.getElementById('typingWord').textContent = data.word;
                document.getElementById('typingInput1').value = '';
                document.getElementById('typingInput2').value = '';
            } else if (data.type === 'score') {
                typingScores = data.scores;
                document.getElementById('typingScore1').textContent = typingScores[1];
                document.getElementById('typingScore2').textContent = typingScores[2];
                if (data.winner) {
                    typingActive = false;
                    document.getElementById('typingWord').textContent = 'üèÜ';
                    document.getElementById('typingStatus').textContent = `Player ${data.winner} wins!`;
                }
            }
        }

        const originalCheckTyping = checkTyping;
        checkTyping = function(player, value) {
            if (!mp.connected) {
                originalCheckTyping(player, value);
                return;
            }

            const myPlayer = mp.isHost ? 1 : 2;
            if (player !== myPlayer) return;

            if (!typingActive) return;
            if (value.toUpperCase() === typingCurrentWord) {
                typingScores[player]++;
                document.getElementById(`typingScore${player}`).textContent = typingScores[player];

                if (typingScores[player] >= 5) {
                    typingActive = false;
                    document.getElementById('typingWord').textContent = 'üèÜ';
                    document.getElementById('typingStatus').textContent = `Player ${player} wins!`;
                    mp.send({ game: 'typing', type: 'score', scores: typingScores, winner: player });
                } else {
                    const newWord = TYPING_WORDS[Math.floor(Math.random() * TYPING_WORDS.length)];
                    typingCurrentWord = newWord;
                    document.getElementById('typingWord').textContent = newWord;
                    document.getElementById('typingInput1').value = '';
                    document.getElementById('typingInput2').value = '';
                    mp.send({ game: 'typing', type: 'word', word: newWord });
                    mp.send({ game: 'typing', type: 'score', scores: typingScores, winner: null });
                }
            }
        };

        // ==================== WHACK-A-MOLE SYNC ====================
        function handleWhackSync(data) {
            if (data.type === 'score') {
                whackScores = data.scores;
                document.getElementById('whackScore1').textContent = whackScores[1];
                document.getElementById('whackScore2').textContent = whackScores[2];
            } else if (data.type === 'end') {
                document.getElementById('whackStatus').textContent = data.status;
            }
        }

        const originalWhackMole = whackMole;
        whackMole = function(player, index) {
            if (!mp.connected) {
                originalWhackMole(player, index);
                return;
            }

            const myPlayer = mp.isHost ? 1 : 2;
            if (player !== myPlayer) return;

            originalWhackMole(player, index);

            mp.send({
                game: 'whack',
                type: 'score',
                scores: whackScores
            });
        };

        // ==================== AIR HOCKEY SYNC ====================
        function handleHockeySync(data) {
            if (data.type === 'state') {
                if (!mp.isHost) {
                    hockeyPuck = data.puck;
                    hockeyP1 = data.p1;
                    hockeyP2 = data.p2;
                    hockeyScores = data.scores;
                    updateHockeyScores();
                }
            } else if (data.type === 'input') {
                if (mp.isHost) {
                    const speed = 5;
                    if (data.keys.left && hockeyP2.x > 30) hockeyP2.x -= speed;
                    if (data.keys.right && hockeyP2.x < 370) hockeyP2.x += speed;
                    if (data.keys.up && hockeyP2.y > 30) hockeyP2.y -= speed;
                    if (data.keys.down && hockeyP2.y < 230) hockeyP2.y += speed;
                }
            }
        }

        const originalHockeyLoop = hockeyLoop;
        hockeyLoop = function() {
            if (mp.connected && mp.isHost) {
                originalHockeyLoop.call(this);
                mp.send({
                    game: 'airhockey',
                    type: 'state',
                    puck: hockeyPuck,
                    p1: hockeyP1,
                    p2: hockeyP2,
                    scores: hockeyScores
                });
            } else if (mp.connected && !mp.isHost) {
                // Guest sends input and renders
                mp.send({
                    game: 'airhockey',
                    type: 'input',
                    keys: {
                        left: hockeyKeys['ArrowLeft'],
                        right: hockeyKeys['ArrowRight'],
                        up: hockeyKeys['ArrowUp'],
                        down: hockeyKeys['ArrowDown']
                    }
                });
                // Render
                hockeyCtx.fillStyle = '#1a3d1a';
                hockeyCtx.fillRect(0, 0, 400, 500);
                hockeyCtx.strokeStyle = '#2a5a2a';
                hockeyCtx.lineWidth = 2;
                hockeyCtx.beginPath();
                hockeyCtx.moveTo(0, 250);
                hockeyCtx.lineTo(400, 250);
                hockeyCtx.stroke();
                hockeyCtx.beginPath();
                hockeyCtx.arc(200, 250, 50, 0, Math.PI * 2);
                hockeyCtx.stroke();
                hockeyCtx.fillStyle = '#333';
                hockeyCtx.fillRect(140, 0, 120, 10);
                hockeyCtx.fillRect(140, 490, 120, 10);
                hockeyCtx.shadowBlur = 15;
                hockeyCtx.shadowColor = '#00ff88';
                hockeyCtx.fillStyle = '#00ff88';
                hockeyCtx.beginPath();
                hockeyCtx.arc(hockeyP1.x, hockeyP1.y, hockeyP1.radius, 0, Math.PI * 2);
                hockeyCtx.fill();
                hockeyCtx.shadowColor = '#ff6b6b';
                hockeyCtx.fillStyle = '#ff6b6b';
                hockeyCtx.beginPath();
                hockeyCtx.arc(hockeyP2.x, hockeyP2.y, hockeyP2.radius, 0, Math.PI * 2);
                hockeyCtx.fill();
                hockeyCtx.shadowColor = '#fff';
                hockeyCtx.fillStyle = '#111';
                hockeyCtx.beginPath();
                hockeyCtx.arc(hockeyPuck.x, hockeyPuck.y, hockeyPuck.radius, 0, Math.PI * 2);
                hockeyCtx.fill();
                hockeyCtx.strokeStyle = '#fff';
                hockeyCtx.lineWidth = 2;
                hockeyCtx.stroke();
                hockeyCtx.shadowBlur = 0;
                hockeyAnimationId = requestAnimationFrame(hockeyLoop);
            } else {
                originalHockeyLoop.call(this);
            }
        };

        // ==================== BATTLESHIP SYNC ====================
        function handleBattleshipSync(data) {
            if (data.type === 'state') {
                // Only show your ships and attacks on enemy
                const myPlayer = mp.isHost ? 1 : 2;
                const enemyPlayer = mp.isHost ? 2 : 1;

                bsGrids[myPlayer] = data.myGrid;
                // Only show hits/misses on enemy grid, not their ships
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        if (data.enemyGrid[r][c] >= 2) {
                            bsGrids[enemyPlayer][r][c] = data.enemyGrid[r][c];
                        }
                    }
                }
                bsPhase = data.phase;
                bsCurrentPlayer = data.currentPlayer;
                bsShipsPlaced = data.shipsPlaced;
                document.getElementById('battleshipStatus').textContent = data.status;
                document.getElementById('bsInfo').textContent = data.info;
                renderBattleshipGrids();
            }
        }

        const originalHandleBsClick = handleBsClick;
        handleBsClick = function(player, row, col) {
            if (!mp.connected) {
                originalHandleBsClick(player, row, col);
                return;
            }

            const myPlayer = mp.isHost ? 1 : 2;
            const enemyPlayer = mp.isHost ? 2 : 1;

            if (bsPhase === 'placing' && player === myPlayer) {
                originalHandleBsClick(player, row, col);
                mp.send({
                    game: 'battleship',
                    type: 'state',
                    myGrid: bsGrids[myPlayer],
                    enemyGrid: bsGrids[enemyPlayer],
                    phase: bsPhase,
                    currentPlayer: bsCurrentPlayer,
                    shipsPlaced: bsShipsPlaced,
                    status: document.getElementById('battleshipStatus').textContent,
                    info: document.getElementById('bsInfo').textContent
                });
            } else if (bsPhase === 'playing' && player === enemyPlayer && bsCurrentPlayer === myPlayer) {
                originalHandleBsClick(player, row, col);
                mp.send({
                    game: 'battleship',
                    type: 'state',
                    myGrid: bsGrids[myPlayer],
                    enemyGrid: bsGrids[enemyPlayer],
                    phase: bsPhase,
                    currentPlayer: bsCurrentPlayer,
                    shipsPlaced: bsShipsPlaced,
                    status: document.getElementById('battleshipStatus').textContent,
                    info: document.getElementById('bsInfo').textContent
                });
            }
        };

        // ==================== SIMON SYNC ====================
        function handleSimonSync(data) {
            if (data.type === 'state') {
                simonSequence = data.sequence;
                simonPlayerSequence = data.playerSequence;
                simonCurrentPlayer = data.currentPlayer;
                simonScores = data.scores;
                simonPlaying = data.playing;
                simonShowingPattern = data.showingPattern;
                document.getElementById('simonScore1').textContent = simonScores[1];
                document.getElementById('simonScore2').textContent = simonScores[2];
                document.getElementById('simonStatus').textContent = data.status;
                document.getElementById('simonInfo').textContent = data.info;
            } else if (data.type === 'flash') {
                flashSimonButton(data.color);
            }
        }

        // ==================== ENHANCED GAME SOUNDS ====================
        // Add click sounds to game cards
        document.querySelectorAll('.game-card').forEach(card => {
            card.addEventListener('click', () => sound.play('click'));
        });

        // Add click sounds to restart buttons
        document.querySelectorAll('.restart-btn').forEach(btn => {
            btn.addEventListener('click', () => sound.play('click'));
        });

        // Generate floating background particles
        function createFloatingParticles() {
            const container = document.getElementById('particles');
            const colors = ['var(--accent)', 'var(--accent-secondary)', 'var(--accent-third)', '#00ccff'];

            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 15 + 's';
                particle.style.animationDuration = (10 + Math.random() * 10) + 's';
                particle.style.width = (2 + Math.random() * 4) + 'px';
                particle.style.height = particle.style.width;
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                container.appendChild(particle);
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            checkUrlForRoom();
            // Initialize particle systems
            particles.pong.init('pongCanvas');
            particles.snake.init('snakeCanvas');
            particles.hockey.init('hockeyCanvas');
            // Create floating background particles
            createFloatingParticles();
        });
    </script>
</body>
</html>

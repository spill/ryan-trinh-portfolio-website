<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ryan's Arcade | Secret Zone</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-card: #1a1a24;
            --accent: #00ff88;
            --accent-secondary: #ff6b6b;
            --accent-third: #ffd93d;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --border: #2a2a3a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Scanline effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 9999;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 24px;
        }

        /* Header */
        header {
            padding: 24px 0;
            border-bottom: 1px solid var(--border);
        }

        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--accent);
            text-decoration: none;
            text-shadow: 0 0 10px var(--accent);
        }

        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Hero */
        .hero {
            text-align: center;
            padding: 60px 0;
        }

        .hero h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            margin-bottom: 16px;
            background: linear-gradient(135deg, var(--accent), var(--accent-third));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .hero .secret-badge {
            display: inline-block;
            padding: 6px 12px;
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid var(--accent-secondary);
            border-radius: 4px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            color: var(--accent-secondary);
            margin-bottom: 20px;
        }

        /* Games Grid */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
            padding: 40px 0 80px;
        }

        .game-card {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 16px;
            padding: 32px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .game-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent), var(--accent-third));
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .game-card:hover {
            border-color: var(--accent);
            transform: translateY(-4px);
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.1);
        }

        .game-card:hover::before {
            transform: scaleX(1);
        }

        .game-icon {
            font-size: 3rem;
            margin-bottom: 16px;
        }

        .game-card h3 {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.85rem;
            margin-bottom: 12px;
            color: var(--accent);
        }

        .game-card p {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 16px;
        }

        .player-badge {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent);
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--accent);
        }

        /* Game Modal */
        .game-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-y: auto;
        }

        .game-modal.active {
            display: flex;
        }

        .game-container {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 16px;
            padding: 32px;
            max-width: 650px;
            width: 100%;
            text-align: center;
            position: relative;
        }

        .close-game {
            position: absolute;
            top: 16px;
            right: 16px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-game:hover {
            color: var(--accent-secondary);
        }

        .game-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--accent);
            margin-bottom: 24px;
        }

        /* Game Status */
        .game-status {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.75rem;
            color: var(--accent-third);
            margin-bottom: 20px;
            min-height: 20px;
        }

        /* P2 Mode Toggle */
        .p2-mode-toggle {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .p2-mode-toggle.hidden {
            display: none;
        }

        .p2-mode-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            color: var(--text-secondary);
        }

        .p2-toggle-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.45rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .p2-toggle-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-primary);
        }

        .p2-toggle-btn:hover:not(.active) {
            border-color: var(--accent);
            color: var(--accent);
        }

        .restart-btn {
            padding: 12px 24px;
            background: transparent;
            border: 2px solid var(--accent);
            border-radius: 8px;
            color: var(--accent);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .restart-btn:hover {
            background: var(--accent);
            color: var(--bg-primary);
        }

        /* ==================== TIC TAC TOE BOARD ==================== */
        .ttt-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        .ttt-board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            background: linear-gradient(145deg, #2d1810, #1a0f0a);
            padding: 15px;
            border-radius: 12px;
            box-shadow:
                0 10px 30px rgba(0, 0, 0, 0.5),
                inset 0 2px 4px rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .ttt-board::before {
            content: '';
            position: absolute;
            inset: 10px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            pointer-events: none;
        }

        .ttt-cell {
            width: 100px;
            height: 100px;
            background: linear-gradient(145deg, #3d2415, #2a1a10);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: bold;
            transition: all 0.2s ease;
            position: relative;
        }

        .ttt-cell:nth-child(1) { border-radius: 8px 0 0 0; }
        .ttt-cell:nth-child(3) { border-radius: 0 8px 0 0; }
        .ttt-cell:nth-child(7) { border-radius: 0 0 0 8px; }
        .ttt-cell:nth-child(9) { border-radius: 0 0 8px 0; }

        .ttt-cell:nth-child(2),
        .ttt-cell:nth-child(5),
        .ttt-cell:nth-child(8) {
            border-left: 3px solid #5a3d2a;
            border-right: 3px solid #5a3d2a;
        }

        .ttt-cell:nth-child(4),
        .ttt-cell:nth-child(5),
        .ttt-cell:nth-child(6) {
            border-top: 3px solid #5a3d2a;
            border-bottom: 3px solid #5a3d2a;
        }

        .ttt-cell:hover:not(.taken) {
            background: linear-gradient(145deg, #4d3020, #3a2515);
        }

        .ttt-cell.x::after {
            content: '‚úï';
            color: #00ff88;
            text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
            font-size: 3.5rem;
        }

        .ttt-cell.o::after {
            content: '‚óã';
            color: #ff6b6b;
            text-shadow: 0 0 20px #ff6b6b, 0 0 40px #ff6b6b;
            font-size: 4rem;
        }

        /* ==================== CONNECT FOUR BOARD ==================== */
        .c4-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        .c4-frame {
            background: linear-gradient(180deg, #1a5fb4, #0d3a7a);
            padding: 20px;
            border-radius: 16px;
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.5),
                inset 0 2px 4px rgba(255, 255, 255, 0.2),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .c4-frame::before {
            content: 'CONNECT 4';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(180deg, #ffd93d, #f0a000);
            padding: 4px 16px;
            border-radius: 4px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            color: #1a1a24;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .c4-board {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            grid-template-rows: repeat(6, 50px);
            gap: 6px;
            background: linear-gradient(180deg, #1557a0, #0a3060);
            padding: 10px;
            border-radius: 8px;
        }

        .c4-cell {
            width: 50px;
            height: 50px;
            background: linear-gradient(180deg, #0a0a15, #15152a);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow:
                inset 0 4px 8px rgba(0, 0, 0, 0.5),
                0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .c4-cell:hover:not(.taken)::after {
            content: '';
            position: absolute;
            inset: 5px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
        }

        .c4-cell.p1 {
            background: radial-gradient(circle at 30% 30%, #ff8080, #cc0000, #990000);
            box-shadow:
                inset 0 4px 8px rgba(255, 255, 255, 0.3),
                inset 0 -4px 8px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(255, 0, 0, 0.4);
        }

        .c4-cell.p2 {
            background: radial-gradient(circle at 30% 30%, #ffff80, #ffcc00, #cc9900);
            box-shadow:
                inset 0 4px 8px rgba(255, 255, 255, 0.3),
                inset 0 -4px 8px rgba(0, 0, 0, 0.3),
                0 4px 12px rgba(255, 200, 0, 0.4);
        }

        .c4-cell.dropping {
            animation: dropPiece 0.5s ease-out;
        }

        @keyframes dropPiece {
            0% { transform: translateY(-300px); }
            60% { transform: translateY(10px); }
            80% { transform: translateY(-5px); }
            100% { transform: translateY(0); }
        }

        /* Column hover indicator */
        .c4-column-indicators {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            gap: 6px;
            padding: 0 10px;
            margin-bottom: 8px;
        }

        .c4-indicator {
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .c4-indicator::after {
            content: '‚ñº';
            font-size: 1rem;
        }

        .c4-indicator.p1::after {
            color: #ff4444;
            text-shadow: 0 0 10px #ff4444;
        }

        .c4-indicator.p2::after {
            color: #ffcc00;
            text-shadow: 0 0 10px #ffcc00;
        }

        .c4-frame:hover .c4-indicator {
            opacity: 1;
        }

        /* ==================== PONG ==================== */
        .pong-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .pong-cabinet {
            background: linear-gradient(180deg, #2a2a3a, #1a1a24);
            padding: 20px;
            border-radius: 16px;
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 2px rgba(255, 255, 255, 0.1);
        }

        .pong-screen {
            background: #000;
            border-radius: 8px;
            padding: 3px;
            box-shadow:
                inset 0 0 20px rgba(0, 255, 136, 0.1),
                0 0 10px rgba(0, 0, 0, 0.5);
        }

        .pong-scores {
            display: flex;
            justify-content: space-around;
            padding: 16px 0;
            font-family: 'Press Start 2P', cursive;
        }

        .pong-score {
            font-size: 1.8rem;
        }

        .pong-score.p1 {
            color: var(--accent);
            text-shadow: 0 0 20px var(--accent);
        }

        .pong-score.p2 {
            color: var(--accent-secondary);
            text-shadow: 0 0 20px var(--accent-secondary);
        }

        #pongCanvas {
            display: block;
            border-radius: 4px;
        }

        .pong-controls {
            margin-top: 16px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .pong-controls span {
            display: inline-block;
            padding: 2px 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin: 0 4px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
        }

        /* ==================== REACTION RACE ==================== */
        .reaction-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .reaction-arena {
            background: linear-gradient(180deg, #1a1a24, #0a0a0f);
            padding: 30px 40px;
            border-radius: 16px;
            box-shadow:
                0 15px 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 2px rgba(255, 255, 255, 0.05);
        }

        .reaction-status {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9rem;
            color: var(--accent-third);
            min-height: 30px;
            margin-bottom: 24px;
        }

        .reaction-container {
            display: flex;
            gap: 40px;
            justify-content: center;
            margin-bottom: 24px;
        }

        .reaction-btn {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Press Start 2P', cursive;
            position: relative;
            background: linear-gradient(180deg, #3a3a4a, #2a2a3a);
            box-shadow:
                0 8px 0 #1a1a24,
                0 12px 20px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.1);
        }

        .reaction-btn::before {
            content: '';
            position: absolute;
            inset: 8px;
            border-radius: 50%;
            background: linear-gradient(180deg, #4a4a5a, #3a3a4a);
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .reaction-btn .player-label,
        .reaction-btn .key-label {
            position: relative;
            z-index: 1;
        }

        .reaction-btn .player-label {
            font-size: 0.6rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .reaction-btn .key-label {
            font-size: 1.8rem;
            color: var(--text-primary);
        }

        .reaction-btn.p1 {
            box-shadow:
                0 8px 0 #004d29,
                0 12px 20px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.1);
        }

        .reaction-btn.p1::before {
            background: linear-gradient(180deg, #00aa55, #006633);
            border: 4px solid #00ff88;
        }

        .reaction-btn.p2 {
            box-shadow:
                0 8px 0 #661a1a,
                0 12px 20px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.1);
        }

        .reaction-btn.p2::before {
            background: linear-gradient(180deg, #aa3333, #662222);
            border: 4px solid #ff6b6b;
        }

        .reaction-btn:active {
            transform: translateY(4px);
            box-shadow:
                0 4px 0 #1a1a24,
                0 6px 10px rgba(0, 0, 0, 0.4);
        }

        .reaction-btn.ready {
            animation: pulse-glow 0.5s infinite alternate;
        }

        .reaction-btn.p1.ready::before {
            background: linear-gradient(180deg, #00ff88, #00cc66);
            box-shadow:
                inset 0 4px 8px rgba(255, 255, 255, 0.3),
                0 0 30px #00ff88;
        }

        .reaction-btn.p2.ready::before {
            background: linear-gradient(180deg, #ff6b6b, #cc4444);
            box-shadow:
                inset 0 4px 8px rgba(255, 255, 255, 0.3),
                0 0 30px #ff6b6b;
        }

        @keyframes pulse-glow {
            from { filter: brightness(1); }
            to { filter: brightness(1.3); }
        }

        .reaction-scores {
            display: flex;
            justify-content: center;
            gap: 60px;
        }

        .reaction-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }

        .reaction-score.p1 {
            color: var(--accent);
        }

        .reaction-score.p2 {
            color: var(--accent-secondary);
        }

        /* ==================== SNAKE BATTLE ==================== */
        .snake-wrapper {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        #snakeCanvas {
            border: 3px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
        }

        .snake-controls {
            margin-top: 16px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .snake-controls span {
            display: inline-block;
            padding: 2px 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin: 0 2px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
        }

        /* ==================== MEMORY MATCH ==================== */
        .memory-scores {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin-bottom: 20px;
        }

        .memory-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }

        .memory-score.p1 { color: var(--accent); }
        .memory-score.p2 { color: var(--accent-secondary); }

        .memory-board {
            display: grid;
            grid-template-columns: repeat(4, 70px);
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .memory-card {
            width: 70px;
            height: 70px;
            cursor: pointer;
            position: relative;
            perspective: 600px;
        }

        .memory-front, .memory-back {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            backface-visibility: hidden;
            transition: transform 0.4s ease;
            font-size: 2rem;
        }

        .memory-front {
            background: linear-gradient(145deg, #2a2a3a, #1a1a24);
            border: 2px solid var(--border);
            color: var(--text-secondary);
            font-family: 'Press Start 2P', cursive;
        }

        .memory-back {
            background: linear-gradient(145deg, #1a3d1a, #0a2a0a);
            border: 2px solid var(--accent);
            transform: rotateY(180deg);
        }

        .memory-card.flipped .memory-front {
            transform: rotateY(180deg);
        }

        .memory-card.flipped .memory-back {
            transform: rotateY(0);
        }

        /* ==================== ROCK PAPER SCISSORS ==================== */
        .rps-scores {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin-bottom: 20px;
        }

        .rps-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }

        .rps-score.p1 { color: var(--accent); }
        .rps-score.p2 { color: var(--accent-secondary); }

        .rps-arena {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-bottom: 20px;
        }

        .rps-player {
            text-align: center;
        }

        .rps-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .rps-choice {
            width: 80px;
            height: 80px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            margin: 0 auto 15px;
        }

        .rps-vs {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--accent-third);
        }

        .rps-buttons {
            display: flex;
            gap: 8px;
        }

        .rps-buttons button {
            width: 50px;
            height: 50px;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: var(--bg-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .rps-buttons button:hover {
            border-color: var(--accent);
            transform: scale(1.1);
        }

        .rps-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ==================== SPEED TYPING ==================== */
        .typing-scores {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin-bottom: 20px;
        }

        .typing-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }

        .typing-score.p1 { color: var(--accent); }
        .typing-score.p2 { color: var(--accent-secondary); }

        .typing-word {
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            color: var(--accent-third);
            text-shadow: 0 0 20px var(--accent-third);
            margin-bottom: 30px;
            letter-spacing: 4px;
        }

        .typing-inputs {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
        }

        .typing-player {
            text-align: center;
        }

        .typing-player label {
            display: block;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .typing-player input {
            width: 150px;
            padding: 12px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            text-align: center;
            text-transform: uppercase;
        }

        .typing-player input:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* ==================== WHACK-A-MOLE ==================== */
        .whack-scores {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            margin-bottom: 20px;
        }

        .whack-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }

        .whack-score.p1 { color: var(--accent); }
        .whack-score.p2 { color: var(--accent-secondary); }

        .whack-timer {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            color: var(--accent-third);
            text-shadow: 0 0 10px var(--accent-third);
        }

        .whack-arena {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 20px;
        }

        .whack-side {
            text-align: center;
        }

        .whack-grid {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            gap: 10px;
            padding: 15px;
            background: linear-gradient(145deg, #3d2415, #2a1a10);
            border-radius: 12px;
        }

        .whack-hole {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at center, #1a0f0a, #0a0505);
            border-radius: 50%;
            cursor: pointer;
            position: relative;
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .whack-hole.mole::after {
            content: 'üêπ';
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            animation: mole-pop 0.2s ease-out;
        }

        .whack-hole.hit {
            background: radial-gradient(circle at center, #004400, #002200);
        }

        @keyframes mole-pop {
            from { transform: translateY(20px) scale(0.5); }
            to { transform: translateY(0) scale(1); }
        }

        /* ==================== AIR HOCKEY ==================== */
        .hockey-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .hockey-cabinet {
            background: linear-gradient(180deg, #2a2a3a, #1a1a24);
            padding: 15px;
            border-radius: 16px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
        }

        .hockey-scores {
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            font-family: 'Press Start 2P', cursive;
        }

        .hockey-score {
            font-size: 1.5rem;
        }

        .hockey-score.p1 {
            color: var(--accent);
            text-shadow: 0 0 15px var(--accent);
        }

        .hockey-score.p2 {
            color: var(--accent-secondary);
            text-shadow: 0 0 15px var(--accent-secondary);
        }

        #hockeyCanvas {
            display: block;
            border-radius: 8px;
        }

        .hockey-controls {
            margin-top: 16px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .hockey-controls span {
            display: inline-block;
            padding: 2px 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin: 0 2px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
        }

        /* ==================== BATTLESHIP ==================== */
        .battleship-arena {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .battleship-side {
            text-align: center;
        }

        .battleship-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .battleship-grid {
            display: grid;
            grid-template-columns: repeat(10, 28px);
            gap: 2px;
            background: #0a1a3a;
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #1a3a6a;
        }

        .bs-cell {
            width: 28px;
            height: 28px;
            background: linear-gradient(145deg, #1a3a6a, #0a2a4a);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .bs-cell:hover {
            background: linear-gradient(145deg, #2a4a7a, #1a3a5a);
        }

        .bs-cell.ship {
            background: linear-gradient(145deg, #4a4a5a, #3a3a4a);
        }

        .bs-cell.hit {
            background: radial-gradient(circle, #ff4444, #aa0000);
            box-shadow: 0 0 10px #ff0000;
        }

        .bs-cell.miss {
            background: linear-gradient(145deg, #1a3a6a, #0a2a4a);
            position: relative;
        }

        .bs-cell.miss::after {
            content: '‚Ä¢';
            color: #fff;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        .battleship-info {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            color: var(--accent-third);
            margin-bottom: 20px;
        }

        /* ==================== SIMON SAYS ==================== */
        .simon-scores {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin-bottom: 20px;
        }

        .simon-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
        }

        .simon-score.p1 { color: var(--accent); }
        .simon-score.p2 { color: var(--accent-secondary); }

        .simon-board {
            display: grid;
            grid-template-columns: repeat(2, 100px);
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .simon-btn {
            width: 100px;
            height: 100px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.6;
        }

        .simon-btn[data-color="green"] {
            background: linear-gradient(145deg, #00aa44, #006622);
        }

        .simon-btn[data-color="red"] {
            background: linear-gradient(145deg, #cc3333, #881818);
        }

        .simon-btn[data-color="yellow"] {
            background: linear-gradient(145deg, #ccaa00, #886600);
        }

        .simon-btn[data-color="blue"] {
            background: linear-gradient(145deg, #3366cc, #1a3388);
        }

        .simon-btn.active, .simon-btn:hover {
            opacity: 1;
            transform: scale(1.05);
        }

        .simon-btn[data-color="green"].active {
            box-shadow: 0 0 30px #00ff88;
        }

        .simon-btn[data-color="red"].active {
            box-shadow: 0 0 30px #ff6b6b;
        }

        .simon-btn[data-color="yellow"].active {
            box-shadow: 0 0 30px #ffd93d;
        }

        .simon-btn[data-color="blue"].active {
            box-shadow: 0 0 30px #6699ff;
        }

        .simon-info {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        /* ==================== HEADER ACTIONS ==================== */
        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .multiplayer-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--accent), #00cc6a);
            border: none;
            border-radius: 8px;
            color: #000;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .multiplayer-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        .multiplayer-btn.connected {
            background: linear-gradient(135deg, #ffd93d, #ffaa00);
            box-shadow: 0 0 20px rgba(255, 217, 61, 0.3);
        }

        .mp-icon {
            font-size: 1.1rem;
        }

        /* ==================== MULTIPLAYER LOBBY ==================== */
        .lobby-container {
            max-width: 450px;
        }

        .lobby-status {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.65rem;
            color: var(--text-secondary);
            margin-bottom: 20px;
            line-height: 1.6;
        }

        /* Name Input */
        .name-input-section {
            margin-bottom: 20px;
        }

        .name-input-group {
            text-align: center;
        }

        .name-input-group label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .name-input-group input {
            width: 200px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1rem;
            text-align: center;
        }

        .name-input-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .lobby-options {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .lobby-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 24px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .lobby-btn:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .lobby-btn.create:hover {
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.2);
        }

        .lobby-btn.join:hover {
            border-color: var(--accent-third);
            box-shadow: 0 0 30px rgba(255, 217, 61, 0.2);
        }

        .lobby-btn-icon {
            font-size: 2rem;
        }

        .lobby-btn-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: var(--text-primary);
        }

        .lobby-btn-desc {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Room Display */
        .lobby-room {
            text-align: center;
        }

        .room-code-display {
            background: var(--bg-secondary);
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .room-label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .room-code {
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            color: var(--accent);
            letter-spacing: 8px;
            text-shadow: 0 0 20px var(--accent);
        }

        .room-actions {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 24px;
        }

        .room-action-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 10px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .room-action-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .connection-status {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .player-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .player-indicator.p1 {
            border-left: 3px solid var(--accent);
        }

        .player-indicator.p2 {
            border-left: 3px solid var(--accent-secondary);
        }

        .player-role {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            color: var(--text-secondary);
        }

        .player-name {
            flex: 1;
            text-align: right;
            font-weight: 600;
            color: var(--text-primary);
        }

        .player-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--border);
        }

        .player-dot.connected {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Connected Players Display */
        .connected-players {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 12px;
        }

        .connected-player {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .connected-player.p1 .player-badge-small {
            background: var(--accent);
        }

        .connected-player.p2 .player-badge-small {
            background: var(--accent-secondary);
        }

        .player-badge-small {
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            color: #000;
        }

        .vs-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            color: var(--accent-third);
        }

        /* Game invite notification */
        .game-invite {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-card);
            border: 2px solid var(--accent);
            border-radius: 16px;
            padding: 30px;
            text-align: center;
            z-index: 10000;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.3);
            animation: bounceIn 0.3s ease-out;
        }

        .game-invite-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: var(--accent);
            margin-bottom: 16px;
        }

        .game-invite-game {
            font-size: 3rem;
            margin-bottom: 8px;
        }

        .game-invite-name {
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        .game-invite-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .game-invite-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .game-invite-btn.accept {
            background: var(--accent);
            color: #000;
        }

        .game-invite-btn.decline {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .game-invite-btn:hover {
            transform: scale(1.05);
        }

        /* Join Input */
        .lobby-join {
            text-align: center;
        }

        .join-input-group {
            margin-bottom: 20px;
        }

        .join-input-group label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .join-input-group input {
            width: 200px;
            padding: 16px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        .join-input-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .lobby-back-btn {
            display: block;
            margin: 16px auto 0;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .lobby-back-btn:hover {
            color: var(--accent);
        }

        /* Connected State */
        .lobby-connected {
            text-align: center;
        }

        .connected-message {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2rem;
            color: var(--accent);
            margin-bottom: 16px;
        }

        .connected-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: var(--accent);
            color: #000;
            border-radius: 50%;
            font-size: 1.2rem;
        }

        .connected-hint {
            color: var(--text-secondary);
            margin-bottom: 24px;
        }

        /* Connecting Spinner */
        .lobby-connecting {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            color: var(--text-secondary);
        }

        .connecting-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Multiplayer indicator on game cards */
        .game-card.mp-active {
            border-color: var(--accent);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
        }

        .game-card .mp-badge {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 4px 8px;
            background: var(--accent);
            color: #000;
            font-size: 0.65rem;
            font-weight: 600;
            border-radius: 4px;
        }

        .game-card.mp-active .mp-badge {
            display: block;
        }

        /* ==================== ENHANCED ANIMATIONS ==================== */
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }

        @keyframes bounceIn {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 20px currentColor; }
            50% { box-shadow: 0 0 40px currentColor, 0 0 60px currentColor; }
        }

        @keyframes shimmer {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }

        @keyframes wobble {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }

        @keyframes scorePopIn {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); color: #ffd93d; }
            100% { transform: scale(1); }
        }

        @keyframes winCelebration {
            0% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.1) rotate(-3deg); }
            50% { transform: scale(1.2) rotate(0deg); }
            75% { transform: scale(1.1) rotate(3deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        /* Enhanced game elements */
        .game-status.winner {
            animation: winCelebration 0.5s ease-in-out;
            color: var(--accent) !important;
        }

        .score-pop {
            animation: scorePopIn 0.3s ease-out;
        }

        .ttt-cell.winning {
            animation: pulseGlow 1s infinite;
            color: var(--accent);
        }

        .c4-cell.winning {
            animation: pulseGlow 1s infinite;
            transform: scale(1.1);
        }

        /* Enhanced hover effects */
        .game-card {
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .game-card:hover {
            transform: translateY(-8px) scale(1.02);
        }

        .game-card:active {
            transform: translateY(-2px) scale(0.98);
        }

        /* Button press effect */
        .restart-btn {
            transition: all 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--accent);
        }

        .restart-btn:active {
            transform: scale(0.95);
        }

        /* Enhanced memory cards */
        .memory-card {
            transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .memory-card.matched .memory-back {
            animation: bounceIn 0.5s ease-out;
            background: linear-gradient(145deg, #00ff88, #00cc66);
        }

        /* RPS animations */
        .rps-choice.revealed {
            animation: bounceIn 0.5s ease-out;
        }

        /* Reaction button glow */
        .reaction-btn.winner {
            animation: pulseGlow 1s infinite;
        }

        /* Sound toggle button */
        .sound-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--bg-card);
            border: 2px solid var(--border);
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sound-toggle:hover {
            border-color: var(--accent);
            transform: scale(1.1);
        }

        .sound-toggle.muted {
            opacity: 0.5;
        }

        /* Footer */
        footer {
            padding: 24px 0;
            border-top: 1px solid var(--border);
            text-align: center;
        }

        footer p {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        footer a {
            color: var(--accent);
            text-decoration: none;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .ttt-board {
                grid-template-columns: repeat(3, 80px);
                grid-template-rows: repeat(3, 80px);
            }

            .ttt-cell {
                width: 80px;
                height: 80px;
            }

            .c4-board {
                grid-template-columns: repeat(7, 38px);
                grid-template-rows: repeat(6, 38px);
            }

            .c4-cell {
                width: 38px;
                height: 38px;
            }

            .c4-column-indicators {
                grid-template-columns: repeat(7, 38px);
            }

            .reaction-container {
                flex-direction: column;
                gap: 24px;
            }

            .reaction-btn {
                width: 120px;
                height: 120px;
            }

            .pong-cabinet {
                padding: 10px;
            }

            #pongCanvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <a href="index.html" class="logo">ARCADE</a>
            <div class="header-actions">
                <button class="multiplayer-btn" onclick="openLobby()">
                    <span class="mp-icon">üë•</span>
                    <span>Multiplayer</span>
                </button>
                <a href="index.html" class="back-btn">
                    <span>&larr;</span>
                    <span>Back to Resume</span>
                </a>
            </div>
        </div>
    </header>

    <section class="hero">
        <div class="container">
            <div class="secret-badge">SECRET ZONE</div>
            <h1>RYAN'S ARCADE</h1>
            <p>You found the secret games! Grab a friend and have some fun.</p>
        </div>
    </section>

    <section class="games-section">
        <div class="container">
            <div class="games-grid">
                <div class="game-card" onclick="openGame('tictactoe')">
                    <div class="game-icon">‚≠ï</div>
                    <h3>TIC TAC TOE</h3>
                    <p>The classic game of X's and O's</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('connect4')">
                    <div class="game-icon">üî¥</div>
                    <h3>CONNECT FOUR</h3>
                    <p>Get four in a row to win</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('pong')">
                    <div class="game-icon">üèì</div>
                    <h3>PONG</h3>
                    <p>Retro paddle battle</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('reaction')">
                    <div class="game-icon">‚ö°</div>
                    <h3>REACTION RACE</h3>
                    <p>Test your reflexes!</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('snake')">
                    <div class="game-icon">üêç</div>
                    <h3>SNAKE BATTLE</h3>
                    <p>Last snake alive wins!</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('memory')">
                    <div class="game-icon">üÉè</div>
                    <h3>MEMORY MATCH</h3>
                    <p>Find the matching pairs</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('rps')">
                    <div class="game-icon">‚úä</div>
                    <h3>ROCK PAPER SCISSORS</h3>
                    <p>Best of 5 showdown</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('typing')">
                    <div class="game-icon">‚å®Ô∏è</div>
                    <h3>SPEED TYPING</h3>
                    <p>Type faster than your rival</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('whack')">
                    <div class="game-icon">üî®</div>
                    <h3>WHACK-A-MOLE</h3>
                    <p>Smash the most moles!</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('airhockey')">
                    <div class="game-icon">üèí</div>
                    <h3>AIR HOCKEY</h3>
                    <p>Fast-paced puck action</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('battleship')">
                    <div class="game-icon">üö¢</div>
                    <h3>BATTLESHIP</h3>
                    <p>Sink the enemy fleet</p>
                    <span class="player-badge">2 Players</span>
                </div>

                <div class="game-card" onclick="openGame('simon')">
                    <div class="game-icon">üéµ</div>
                    <h3>SIMON SAYS</h3>
                    <p>Memory pattern challenge</p>
                    <span class="player-badge">2 Players</span>
                </div>
            </div>
        </div>
    </section>

    <!-- Tic Tac Toe Modal -->
    <div class="game-modal" id="tictactoeModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('tictactoe')">&times;</button>
            <h2 class="game-title">TIC TAC TOE</h2>
            <div class="p2-mode-toggle" id="tttP2Toggle">
                <span class="p2-mode-label">P2:</span>
                <button class="p2-toggle-btn active" onclick="setP2Mode('tictactoe', 'ai')">AI</button>
                <button class="p2-toggle-btn" onclick="setP2Mode('tictactoe', 'manual')">2P</button>
            </div>
            <div class="game-status" id="tttStatus">Player X's turn</div>
            <div class="ttt-wrapper">
                <div class="ttt-board" id="tttBoard"></div>
            </div>
            <button class="restart-btn" onclick="initTTT()">RESTART</button>
        </div>
    </div>

    <!-- Connect Four Modal -->
    <div class="game-modal" id="connect4Modal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('connect4')">&times;</button>
            <h2 class="game-title">CONNECT FOUR</h2>
            <div class="p2-mode-toggle" id="c4P2Toggle">
                <span class="p2-mode-label">P2:</span>
                <button class="p2-toggle-btn active" onclick="setP2Mode('connect4', 'ai')">AI</button>
                <button class="p2-toggle-btn" onclick="setP2Mode('connect4', 'manual')">2P</button>
            </div>
            <div class="game-status" id="c4Status">üî¥ Player 1's turn</div>
            <div class="c4-wrapper">
                <div class="c4-frame">
                    <div class="c4-column-indicators" id="c4Indicators"></div>
                    <div class="c4-board" id="c4Board"></div>
                </div>
            </div>
            <button class="restart-btn" onclick="initC4()">RESTART</button>
        </div>
    </div>

    <!-- Pong Modal -->
    <div class="game-modal" id="pongModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('pong')">&times;</button>
            <h2 class="game-title">PONG</h2>
            <div class="p2-mode-toggle" id="pongP2Toggle">
                <span class="p2-mode-label">P2:</span>
                <button class="p2-toggle-btn active" onclick="setP2Mode('pong', 'ai')">AI</button>
                <button class="p2-toggle-btn" onclick="setP2Mode('pong', 'manual')">2P</button>
            </div>
            <div class="pong-wrapper">
                <div class="pong-cabinet">
                    <div class="pong-scores">
                        <span class="pong-score p1" id="p1Score">0</span>
                        <span class="pong-score p2" id="p2Score">0</span>
                    </div>
                    <div class="pong-screen">
                        <canvas id="pongCanvas" width="480" height="280"></canvas>
                    </div>
                </div>
                <div class="pong-controls">
                    <p>Player 1: <span>W</span> / <span>S</span> &nbsp;&nbsp; Player 2: <span>‚Üë</span> / <span>‚Üì</span></p>
                </div>
            </div>
            <button class="restart-btn" onclick="resetPong()">RESTART</button>
        </div>
    </div>

    <!-- Reaction Race Modal -->
    <div class="game-modal" id="reactionModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('reaction')">&times;</button>
            <h2 class="game-title">REACTION RACE</h2>
            <div class="reaction-wrapper">
                <div class="reaction-arena">
                    <div class="reaction-status" id="reactionStatus">Press START to begin!</div>
                    <div class="reaction-container">
                        <button class="reaction-btn p1" id="reactionP1">
                            <span class="player-label">P1</span>
                            <span class="key-label">Q</span>
                        </button>
                        <button class="reaction-btn p2" id="reactionP2">
                            <span class="player-label">P2</span>
                            <span class="key-label">P</span>
                        </button>
                    </div>
                    <div class="reaction-scores">
                        <span class="reaction-score p1">P1: <span id="reactionScore1">0</span></span>
                        <span class="reaction-score p2">P2: <span id="reactionScore2">0</span></span>
                    </div>
                </div>
            </div>
            <button class="restart-btn" onclick="startReaction()">START</button>
        </div>
    </div>

    <!-- Multiplayer Lobby Modal -->
    <div class="game-modal" id="lobbyModal">
        <div class="game-container lobby-container">
            <button class="close-game" onclick="closeLobby()">&times;</button>
            <h2 class="game-title">MULTIPLAYER LOBBY</h2>

            <div class="lobby-status" id="lobbyStatus">Choose an option to play with a friend!</div>

            <!-- Name Input -->
            <div class="name-input-section" id="nameInputSection">
                <div class="name-input-group">
                    <label>Your Name</label>
                    <input type="text" id="playerNameInput" maxlength="12" placeholder="Enter name..." autocomplete="off">
                </div>
            </div>

            <div class="lobby-options" id="lobbyOptions">
                <button class="lobby-btn create" onclick="createRoom()">
                    <span class="lobby-btn-icon">üéÆ</span>
                    <span class="lobby-btn-text">Create Room</span>
                    <span class="lobby-btn-desc">Host a game for your friend to join</span>
                </button>
                <button class="lobby-btn join" onclick="showJoinInput()">
                    <span class="lobby-btn-icon">üîó</span>
                    <span class="lobby-btn-text">Join Room</span>
                    <span class="lobby-btn-desc">Enter a room code to join</span>
                </button>
            </div>

            <div class="lobby-room" id="lobbyRoom" style="display: none;">
                <div class="room-code-display">
                    <span class="room-label">Room Code</span>
                    <span class="room-code" id="roomCode">------</span>
                </div>
                <div class="room-actions">
                    <button class="room-action-btn" onclick="copyRoomCode()">
                        <span>üìã</span> Copy Code
                    </button>
                    <button class="room-action-btn" onclick="copyRoomLink()">
                        <span>üîó</span> Copy Link
                    </button>
                </div>
                <div class="connection-status">
                    <div class="player-indicator p1">
                        <span class="player-dot connected"></span>
                        <span class="player-role">P1 (Host)</span>
                        <span class="player-name" id="hostNameDisplay">You</span>
                    </div>
                    <div class="player-indicator p2" id="guestIndicator">
                        <span class="player-dot" id="guestDot"></span>
                        <span class="player-role">P2</span>
                        <span class="player-name" id="guestLabel">Waiting...</span>
                    </div>
                </div>
            </div>

            <div class="lobby-join" id="lobbyJoin" style="display: none;">
                <div class="join-input-group">
                    <label>Enter Room Code</label>
                    <input type="text" id="joinCodeInput" maxlength="6" placeholder="ABC123" autocomplete="off">
                </div>
                <button class="restart-btn" onclick="joinRoom()">JOIN</button>
                <button class="lobby-back-btn" onclick="showLobbyOptions()">‚Üê Back</button>
            </div>

            <div class="lobby-connected" id="lobbyConnected" style="display: none;">
                <div class="connected-message">
                    <span class="connected-icon">‚úì</span>
                    <span>Connected!</span>
                </div>
                <div class="connected-players">
                    <div class="connected-player p1">
                        <span class="player-badge-small">P1</span>
                        <span id="connectedP1Name">Host</span>
                    </div>
                    <span class="vs-text">VS</span>
                    <div class="connected-player p2">
                        <span class="player-badge-small">P2</span>
                        <span id="connectedP2Name">Guest</span>
                    </div>
                </div>
                <p class="connected-hint">Select a game to play together</p>
                <button class="restart-btn" onclick="closeLobby()">CHOOSE GAME</button>
            </div>

            <div class="lobby-connecting" id="lobbyConnecting" style="display: none;">
                <div class="connecting-spinner"></div>
                <span>Connecting...</span>
            </div>
        </div>
    </div>

    <!-- Sound Toggle Button -->
    <button class="sound-toggle" id="soundToggle" onclick="toggleSound()">üîä</button>

    <footer>
        <div class="container">
            <p>You found the secret! Now get back to <a href="index.html">hiring me</a> :)</p>
        </div>
    </footer>

    <script>
        // ==================== PARTICLE SYSTEM ====================
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.canvas = null;
                this.ctx = null;
            }

            init(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (this.canvas) {
                    this.ctx = this.canvas.getContext('2d');
                }
            }

            emit(x, y, options = {}) {
                const defaults = {
                    count: 10,
                    speed: 3,
                    size: 4,
                    color: '#00ff88',
                    lifetime: 60,
                    gravity: 0.1,
                    spread: Math.PI * 2,
                    type: 'circle' // circle, square, star
                };
                const opts = { ...defaults, ...options };

                for (let i = 0; i < opts.count; i++) {
                    const angle = (Math.random() - 0.5) * opts.spread;
                    const speed = opts.speed * (0.5 + Math.random() * 0.5);
                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: opts.size * (0.5 + Math.random() * 0.5),
                        color: opts.color,
                        life: opts.lifetime,
                        maxLife: opts.lifetime,
                        gravity: opts.gravity,
                        type: opts.type
                    });
                }
            }

            trail(x, y, color = '#fff', size = 3) {
                this.particles.push({
                    x, y, vx: 0, vy: 0,
                    size, color,
                    life: 15, maxLife: 15,
                    gravity: 0, type: 'circle'
                });
            }

            confetti(x, y, count = 50) {
                const colors = ['#00ff88', '#ff6b6b', '#ffd93d', '#6b9fff', '#ff6bff'];
                for (let i = 0; i < count; i++) {
                    const angle = (Math.random() - 0.5) * Math.PI;
                    const speed = 2 + Math.random() * 4;
                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: -Math.abs(Math.sin(angle) * speed) - 2,
                        size: 4 + Math.random() * 4,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        life: 120,
                        maxLife: 120,
                        gravity: 0.15,
                        type: 'square',
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.3
                    });
                }
            }

            explosion(x, y, color = '#ff6b6b', count = 20) {
                this.emit(x, y, { count, color, speed: 5, lifetime: 40, gravity: 0.05 });
            }

            update() {
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += p.gravity;
                    p.life--;
                    if (p.rotation !== undefined) {
                        p.rotation += p.rotationSpeed;
                    }
                    return p.life > 0;
                });
            }

            draw(ctx) {
                const context = ctx || this.ctx;
                if (!context) return;

                this.particles.forEach(p => {
                    const alpha = p.life / p.maxLife;
                    context.globalAlpha = alpha;
                    context.fillStyle = p.color;

                    if (p.type === 'circle') {
                        context.beginPath();
                        context.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        context.fill();
                    } else if (p.type === 'square') {
                        context.save();
                        context.translate(p.x, p.y);
                        if (p.rotation !== undefined) context.rotate(p.rotation);
                        context.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                        context.restore();
                    } else if (p.type === 'star') {
                        this.drawStar(context, p.x, p.y, 5, p.size, p.size/2);
                    }
                });
                context.globalAlpha = 1;
            }

            drawStar(ctx, x, y, points, outer, inner) {
                ctx.beginPath();
                for (let i = 0; i < points * 2; i++) {
                    const r = i % 2 === 0 ? outer : inner;
                    const angle = (i * Math.PI) / points - Math.PI / 2;
                    const px = x + Math.cos(angle) * r;
                    const py = y + Math.sin(angle) * r;
                    i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
            }

            clear() {
                this.particles = [];
            }
        }

        // Global particle systems for different canvases
        const particles = {
            pong: new ParticleSystem(),
            snake: new ParticleSystem(),
            hockey: new ParticleSystem()
        };

        // ==================== SOUND MANAGER ====================
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.enabled = true;
                this.volume = 0.3;
                this.sounds = {};
            }

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio not supported');
                    this.enabled = false;
                }
            }

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            play(type, options = {}) {
                if (!this.enabled || !this.ctx) return;
                this.resume();

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                const now = this.ctx.currentTime;
                const vol = (options.volume || 1) * this.volume;

                switch (type) {
                    case 'hit':
                        osc.frequency.setValueAtTime(300, now);
                        osc.frequency.exponentialRampToValueAtTime(150, now + 0.1);
                        osc.type = 'square';
                        gain.gain.setValueAtTime(vol, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                        break;

                    case 'score':
                        osc.frequency.setValueAtTime(523, now);
                        osc.frequency.setValueAtTime(659, now + 0.1);
                        osc.frequency.setValueAtTime(784, now + 0.2);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(vol, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;

                    case 'win':
                        const notes = [523, 659, 784, 1047];
                        notes.forEach((freq, i) => {
                            const o = this.ctx.createOscillator();
                            const g = this.ctx.createGain();
                            o.connect(g);
                            g.connect(this.ctx.destination);
                            o.frequency.setValueAtTime(freq, now + i * 0.15);
                            o.type = 'sine';
                            g.gain.setValueAtTime(vol * 0.8, now + i * 0.15);
                            g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.2);
                            o.start(now + i * 0.15);
                            o.stop(now + i * 0.15 + 0.2);
                        });
                        return;

                    case 'lose':
                        osc.frequency.setValueAtTime(400, now);
                        osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                        osc.type = 'sawtooth';
                        gain.gain.setValueAtTime(vol * 0.5, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;

                    case 'click':
                        osc.frequency.setValueAtTime(800, now);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(vol * 0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                        osc.start(now);
                        osc.stop(now + 0.05);
                        break;

                    case 'beep':
                        osc.frequency.setValueAtTime(options.freq || 440, now);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(vol, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                        osc.start(now);
                        osc.stop(now + 0.15);
                        break;

                    case 'explosion':
                        const noise = this.ctx.createBufferSource();
                        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < data.length; i++) {
                            data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
                        }
                        noise.buffer = buffer;
                        const noiseGain = this.ctx.createGain();
                        noise.connect(noiseGain);
                        noiseGain.connect(this.ctx.destination);
                        noiseGain.gain.setValueAtTime(vol, now);
                        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                        noise.start(now);
                        return;

                    case 'whoosh':
                        osc.frequency.setValueAtTime(100, now);
                        osc.frequency.exponentialRampToValueAtTime(500, now + 0.1);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(vol * 0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                        break;

                    case 'pop':
                        osc.frequency.setValueAtTime(600, now);
                        osc.frequency.exponentialRampToValueAtTime(200, now + 0.05);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(vol * 0.5, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                        osc.start(now);
                        osc.stop(now + 0.05);
                        break;

                    case 'simon':
                        const simonFreqs = { green: 392, red: 330, yellow: 262, blue: 208 };
                        osc.frequency.setValueAtTime(simonFreqs[options.color] || 440, now);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(vol, now);
                        gain.gain.setValueAtTime(vol, now + 0.2);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                }
            }
        }

        const sound = new SoundManager();

        // Initialize sound on first interaction
        document.addEventListener('click', () => sound.init(), { once: true });
        document.addEventListener('keydown', () => sound.init(), { once: true });

        // ==================== SCREEN EFFECTS ====================
        function screenShake(element, intensity = 5, duration = 200) {
            const el = typeof element === 'string' ? document.querySelector(element) : element;
            if (!el) return;

            const originalTransform = el.style.transform;
            let start = null;

            function shake(timestamp) {
                if (!start) start = timestamp;
                const elapsed = timestamp - start;

                if (elapsed < duration) {
                    const x = (Math.random() - 0.5) * intensity * (1 - elapsed/duration);
                    const y = (Math.random() - 0.5) * intensity * (1 - elapsed/duration);
                    el.style.transform = `translate(${x}px, ${y}px)`;
                    requestAnimationFrame(shake);
                } else {
                    el.style.transform = originalTransform;
                }
            }
            requestAnimationFrame(shake);
        }

        function flashElement(element, color = '#fff', duration = 100) {
            const el = typeof element === 'string' ? document.querySelector(element) : element;
            if (!el) return;

            const original = el.style.boxShadow;
            el.style.boxShadow = `0 0 30px ${color}, inset 0 0 30px ${color}`;
            el.style.transition = 'box-shadow 0.1s ease';
            setTimeout(() => {
                el.style.boxShadow = original;
            }, duration);
        }

        function popAnimation(element) {
            const el = typeof element === 'string' ? document.querySelector(element) : element;
            if (!el) return;

            el.style.transform = 'scale(1.2)';
            el.style.transition = 'transform 0.1s ease';
            setTimeout(() => {
                el.style.transform = 'scale(1)';
            }, 100);
        }

        // ==================== FLOATING TEXT ====================
        function showFloatingText(x, y, text, color = '#fff', container = document.body) {
            const el = document.createElement('div');
            el.className = 'floating-text';
            el.textContent = text;
            el.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y}px;
                color: ${color};
                font-family: 'Press Start 2P', cursive;
                font-size: 1rem;
                pointer-events: none;
                z-index: 1000;
                text-shadow: 0 0 10px ${color};
                animation: floatUp 1s ease-out forwards;
            `;
            container.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        // Game Modal Controls
        function openGame(game) {
            document.getElementById(game + 'Modal').classList.add('active');
            if (game === 'tictactoe') initTTT();
            if (game === 'pong') initPong();
            if (game === 'connect4') initC4();
            if (game === 'reaction') initReaction();
        }

        function closeGame(game) {
            document.getElementById(game + 'Modal').classList.remove('active');
            if (game === 'pong') stopPong();
        }

        // ==================== P2 MODE SYSTEM (AI vs Manual) ====================
        const p2Modes = {
            tictactoe: 'ai',
            connect4: 'ai',
            pong: 'ai',
            airhockey: 'ai',
            snake: 'ai',
            memory: 'ai'
        };

        function setP2Mode(game, mode) {
            p2Modes[game] = mode;
            // Update button styles
            const toggleId = {
                tictactoe: 'tttP2Toggle',
                connect4: 'c4P2Toggle',
                pong: 'pongP2Toggle',
                airhockey: 'hockeyP2Toggle',
                snake: 'snakeP2Toggle',
                memory: 'memoryP2Toggle'
            }[game];

            if (toggleId) {
                const toggle = document.getElementById(toggleId);
                if (toggle) {
                    toggle.querySelectorAll('.p2-toggle-btn').forEach(btn => {
                        btn.classList.remove('active');
                        if ((mode === 'ai' && btn.textContent === 'AI') ||
                            (mode === 'manual' && btn.textContent === '2P')) {
                            btn.classList.add('active');
                        }
                    });
                }
            }

            // Restart the game when mode changes
            if (game === 'tictactoe') initTTT();
            if (game === 'connect4') initC4();
            if (game === 'pong') resetPong();
            if (game === 'airhockey') resetHockey();
            if (game === 'snake') initSnake();
            if (game === 'memory') initMemory();
        }

        function hideP2TogglesInMultiplayer() {
            const toggles = document.querySelectorAll('.p2-mode-toggle');
            toggles.forEach(t => t.classList.add('hidden'));
        }

        function showP2Toggles() {
            const toggles = document.querySelectorAll('.p2-mode-toggle');
            toggles.forEach(t => t.classList.remove('hidden'));
        }

        // ==================== TIC TAC TOE ====================
        let tttBoard, tttCurrentPlayer, tttGameOver;

        function initTTT() {
            tttBoard = ['', '', '', '', '', '', '', '', ''];
            tttCurrentPlayer = 'X';
            tttGameOver = false;
            document.getElementById('tttStatus').textContent = "Player X's turn";
            document.getElementById('tttStatus').style.color = '#00ff88';
            renderTTT();
        }

        function renderTTT() {
            const board = document.getElementById('tttBoard');
            board.innerHTML = '';
            tttBoard.forEach((cell, i) => {
                const cellEl = document.createElement('button');
                cellEl.className = `ttt-cell ${cell.toLowerCase()} ${cell ? 'taken' : ''}`;
                cellEl.onclick = () => handleTTTClick(i);
                board.appendChild(cellEl);
            });
        }

        function handleTTTClick(i) {
            if (tttBoard[i] || tttGameOver) return;
            // In AI mode, only allow clicks during player's turn (X)
            if (p2Modes.tictactoe === 'ai' && tttCurrentPlayer !== 'X') return;

            makeTTTMove(i);
        }

        function makeTTTMove(i) {
            tttBoard[i] = tttCurrentPlayer;
            sound.play('pop');

            const winner = checkTTTWinner();
            if (winner) {
                document.getElementById('tttStatus').textContent = `Player ${winner} wins!`;
                document.getElementById('tttStatus').style.color = winner === 'X' ? '#00ff88' : '#ff6b6b';
                document.getElementById('tttStatus').classList.add('winner');
                sound.play('win');
                tttGameOver = true;
                // Highlight winning cells
                const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
                for (const [a,b,c] of lines) {
                    if (tttBoard[a] && tttBoard[a] === tttBoard[b] && tttBoard[a] === tttBoard[c]) {
                        setTimeout(() => {
                            document.querySelectorAll('.ttt-cell')[a]?.classList.add('winning');
                            document.querySelectorAll('.ttt-cell')[b]?.classList.add('winning');
                            document.querySelectorAll('.ttt-cell')[c]?.classList.add('winning');
                        }, 100);
                        break;
                    }
                }
            } else if (tttBoard.every(cell => cell)) {
                document.getElementById('tttStatus').textContent = "It's a draw!";
                document.getElementById('tttStatus').style.color = '#ffd93d';
                sound.play('lose');
                tttGameOver = true;
            } else {
                tttCurrentPlayer = tttCurrentPlayer === 'X' ? 'O' : 'X';
                document.getElementById('tttStatus').textContent = `Player ${tttCurrentPlayer}'s turn`;
                document.getElementById('tttStatus').style.color = tttCurrentPlayer === 'X' ? '#00ff88' : '#ff6b6b';

                // AI move
                if (p2Modes.tictactoe === 'ai' && tttCurrentPlayer === 'O' && !tttGameOver) {
                    setTimeout(() => tttAIMove(), 500);
                }
            }
            renderTTT();
        }

        function tttAIMove() {
            if (tttGameOver) return;
            const move = getTTTBestMove();
            if (move !== -1) {
                makeTTTMove(move);
            }
        }

        function getTTTBestMove() {
            // Try to win
            for (let i = 0; i < 9; i++) {
                if (!tttBoard[i]) {
                    tttBoard[i] = 'O';
                    if (checkTTTWinner() === 'O') {
                        tttBoard[i] = '';
                        return i;
                    }
                    tttBoard[i] = '';
                }
            }
            // Block player from winning
            for (let i = 0; i < 9; i++) {
                if (!tttBoard[i]) {
                    tttBoard[i] = 'X';
                    if (checkTTTWinner() === 'X') {
                        tttBoard[i] = '';
                        return i;
                    }
                    tttBoard[i] = '';
                }
            }
            // Take center
            if (!tttBoard[4]) return 4;
            // Take corner
            const corners = [0, 2, 6, 8];
            const emptyCorners = corners.filter(i => !tttBoard[i]);
            if (emptyCorners.length) return emptyCorners[Math.floor(Math.random() * emptyCorners.length)];
            // Take any empty
            const empty = tttBoard.map((c, i) => c ? -1 : i).filter(i => i !== -1);
            return empty.length ? empty[Math.floor(Math.random() * empty.length)] : -1;
        }

        function checkTTTWinner() {
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ];
            for (const [a, b, c] of lines) {
                if (tttBoard[a] && tttBoard[a] === tttBoard[b] && tttBoard[a] === tttBoard[c]) {
                    return tttBoard[a];
                }
            }
            return null;
        }

        // ==================== CONNECT FOUR ====================
        let c4Board, c4CurrentPlayer, c4GameOver;

        function initC4() {
            c4Board = Array(6).fill(null).map(() => Array(7).fill(0));
            c4CurrentPlayer = 1;
            c4GameOver = false;
            document.getElementById('c4Status').innerHTML = 'üî¥ Player 1\'s turn';
            renderC4();
            renderC4Indicators();
        }

        function renderC4Indicators() {
            const indicators = document.getElementById('c4Indicators');
            indicators.innerHTML = '';
            for (let col = 0; col < 7; col++) {
                const ind = document.createElement('div');
                ind.className = `c4-indicator p${c4CurrentPlayer}`;
                ind.onclick = () => handleC4Click(col);
                indicators.appendChild(ind);
            }
        }

        function renderC4() {
            const board = document.getElementById('c4Board');
            board.innerHTML = '';
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 7; col++) {
                    const cell = document.createElement('div');
                    cell.className = `c4-cell ${c4Board[row][col] === 1 ? 'p1' : ''} ${c4Board[row][col] === 2 ? 'p2' : ''} ${c4Board[row][col] ? 'taken' : ''}`;
                    cell.onclick = () => handleC4Click(col);
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    board.appendChild(cell);
                }
            }
        }

        function handleC4Click(col) {
            if (c4GameOver) return;
            // In AI mode, only allow clicks during player 1's turn
            if (p2Modes.connect4 === 'ai' && c4CurrentPlayer !== 1) return;

            makeC4Move(col);
        }

        function makeC4Move(col) {
            for (let row = 5; row >= 0; row--) {
                if (c4Board[row][col] === 0) {
                    c4Board[row][col] = c4CurrentPlayer;
                    sound.play('whoosh');

                    renderC4();

                    // Add drop animation
                    const cells = document.querySelectorAll('.c4-cell');
                    const cellIndex = row * 7 + col;
                    cells[cellIndex].classList.add('dropping');

                    // Play hit sound when piece lands
                    setTimeout(() => sound.play('hit'), 300);

                    if (checkC4Winner(row, col)) {
                        const emoji = c4CurrentPlayer === 1 ? 'üî¥' : 'üü°';
                        document.getElementById('c4Status').innerHTML = `${emoji} Player ${c4CurrentPlayer} wins!`;
                        document.getElementById('c4Status').classList.add('winner');
                        sound.play('win');
                        c4GameOver = true;
                    } else if (c4Board[0].every(cell => cell !== 0)) {
                        document.getElementById('c4Status').textContent = "It's a draw!";
                        sound.play('lose');
                        c4GameOver = true;
                    } else {
                        c4CurrentPlayer = c4CurrentPlayer === 1 ? 2 : 1;
                        const emoji = c4CurrentPlayer === 1 ? 'üî¥' : 'üü°';
                        document.getElementById('c4Status').innerHTML = `${emoji} Player ${c4CurrentPlayer}'s turn`;
                        renderC4Indicators();

                        // AI move
                        if (p2Modes.connect4 === 'ai' && c4CurrentPlayer === 2 && !c4GameOver) {
                            setTimeout(() => c4AIMove(), 600);
                        }
                    }
                    return;
                }
            }
        }

        function c4AIMove() {
            if (c4GameOver) return;
            const col = getC4BestMove();
            if (col !== -1) {
                makeC4Move(col);
            }
        }

        function getC4BestMove() {
            // Try to win
            for (let col = 0; col < 7; col++) {
                const row = getC4DropRow(col);
                if (row !== -1) {
                    c4Board[row][col] = 2;
                    if (checkC4Winner(row, col)) {
                        c4Board[row][col] = 0;
                        return col;
                    }
                    c4Board[row][col] = 0;
                }
            }
            // Block player from winning
            for (let col = 0; col < 7; col++) {
                const row = getC4DropRow(col);
                if (row !== -1) {
                    c4Board[row][col] = 1;
                    if (checkC4Winner(row, col)) {
                        c4Board[row][col] = 0;
                        return col;
                    }
                    c4Board[row][col] = 0;
                }
            }
            // Prefer center columns
            const centerCols = [3, 2, 4, 1, 5, 0, 6];
            for (const col of centerCols) {
                if (getC4DropRow(col) !== -1) return col;
            }
            return -1;
        }

        function getC4DropRow(col) {
            for (let row = 5; row >= 0; row--) {
                if (c4Board[row][col] === 0) return row;
            }
            return -1;
        }

        function checkC4Winner(row, col) {
            const player = c4Board[row][col];
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

            for (const [dr, dc] of directions) {
                let count = 1;
                for (let i = 1; i < 4; i++) {
                    const r = row + dr * i, c = col + dc * i;
                    if (r >= 0 && r < 6 && c >= 0 && c < 7 && c4Board[r][c] === player) count++;
                    else break;
                }
                for (let i = 1; i < 4; i++) {
                    const r = row - dr * i, c = col - dc * i;
                    if (r >= 0 && r < 6 && c >= 0 && c < 7 && c4Board[r][c] === player) count++;
                    else break;
                }
                if (count >= 4) return true;
            }
            return false;
        }

        // ==================== PONG ====================
        let pongCanvas, pongCtx, pongAnimationId;
        let pongBall, pongP1, pongP2, pongScores, pongKeys;

        function initPong() {
            pongCanvas = document.getElementById('pongCanvas');
            pongCtx = pongCanvas.getContext('2d');

            pongScores = { p1: 0, p2: 0 };
            pongKeys = {};

            resetPongBall();
            resetPongPaddles();
            updatePongScores();

            document.addEventListener('keydown', handlePongKeyDown);
            document.addEventListener('keyup', handlePongKeyUp);

            if (pongAnimationId) cancelAnimationFrame(pongAnimationId);
            pongLoop();
        }

        function handlePongKeyDown(e) {
            pongKeys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'w', 's'].includes(e.key)) {
                e.preventDefault();
            }
        }

        function handlePongKeyUp(e) {
            pongKeys[e.key] = false;
        }

        function resetPongBall() {
            pongBall = {
                x: 240,
                y: 140,
                vx: (Math.random() > 0.5 ? 1 : -1) * 2.5,
                vy: (Math.random() - 0.5) * 2,
                radius: 8
            };
        }

        function resetPongPaddles() {
            pongP1 = { x: 15, y: 115, width: 10, height: 50, vy: 0 };
            pongP2 = { x: 455, y: 115, width: 10, height: 50, vy: 0 };
        }

        function resetPong() {
            pongScores = { p1: 0, p2: 0 };
            updatePongScores();
            resetPongBall();
            resetPongPaddles();
        }

        function stopPong() {
            if (pongAnimationId) {
                cancelAnimationFrame(pongAnimationId);
                pongAnimationId = null;
            }
            document.removeEventListener('keydown', handlePongKeyDown);
            document.removeEventListener('keyup', handlePongKeyUp);
        }

        function updatePongScores() {
            document.getElementById('p1Score').textContent = pongScores.p1;
            document.getElementById('p2Score').textContent = pongScores.p2;
        }

        function pongLoop() {
            // Paddle movement with velocity (more fluid controls)
            const paddleAccel = 1.2;
            const paddleMaxSpeed = 10;
            const paddleFriction = 0.85;

            // P1 paddle (W/S)
            if (pongKeys['w']) {
                pongP1.vy -= paddleAccel;
            } else if (pongKeys['s']) {
                pongP1.vy += paddleAccel;
            } else {
                pongP1.vy *= paddleFriction;
            }
            pongP1.vy = Math.max(-paddleMaxSpeed, Math.min(paddleMaxSpeed, pongP1.vy));
            pongP1.y += pongP1.vy;
            pongP1.y = Math.max(0, Math.min(230, pongP1.y));

            // P2 paddle (Arrow keys or AI)
            if (p2Modes.pong === 'ai') {
                // AI follows the ball with some reaction delay
                const paddleCenter = pongP2.y + pongP2.height / 2;
                const targetY = pongBall.y;
                const aiSpeed = 0.08; // AI reaction speed (lower = easier)

                if (targetY < paddleCenter - 10) {
                    pongP2.vy -= paddleAccel * aiSpeed * 10;
                } else if (targetY > paddleCenter + 10) {
                    pongP2.vy += paddleAccel * aiSpeed * 10;
                } else {
                    pongP2.vy *= paddleFriction;
                }
            } else {
                if (pongKeys['ArrowUp']) {
                    pongP2.vy -= paddleAccel;
                } else if (pongKeys['ArrowDown']) {
                    pongP2.vy += paddleAccel;
                } else {
                    pongP2.vy *= paddleFriction;
                }
            }
            pongP2.vy = Math.max(-paddleMaxSpeed, Math.min(paddleMaxSpeed, pongP2.vy));
            pongP2.y += pongP2.vy;
            pongP2.y = Math.max(0, Math.min(230, pongP2.y));

            // Ball trail particles
            particles.pong.trail(pongBall.x, pongBall.y, '#ffffff', 4);

            // Move ball
            pongBall.x += pongBall.vx;
            pongBall.y += pongBall.vy;

            // Ball collision with top/bottom
            if (pongBall.y <= 8 || pongBall.y >= 272) {
                pongBall.vy *= -1;
                sound.play('hit', { volume: 0.3 });
                particles.pong.emit(pongBall.x, pongBall.y, { count: 5, color: '#fff', speed: 2, lifetime: 20 });
            }

            // Ball collision with P1 paddle
            if (pongBall.x <= pongP1.x + pongP1.width + 8 &&
                pongBall.y >= pongP1.y &&
                pongBall.y <= pongP1.y + pongP1.height &&
                pongBall.vx < 0) {
                pongBall.vx = Math.min(Math.abs(pongBall.vx) * 1.03, 6);
                pongBall.vy += (Math.random() - 0.5) * 1.5;
                sound.play('hit');
                particles.pong.emit(pongP1.x + pongP1.width, pongBall.y, { count: 15, color: '#00ff88', speed: 4, spread: Math.PI / 2 });
                screenShake('#pongCanvas', 3, 100);
            }

            // Ball collision with P2 paddle
            if (pongBall.x >= pongP2.x - 8 &&
                pongBall.y >= pongP2.y &&
                pongBall.y <= pongP2.y + pongP2.height &&
                pongBall.vx > 0) {
                pongBall.vx = -Math.min(Math.abs(pongBall.vx) * 1.03, 6);
                pongBall.vy += (Math.random() - 0.5) * 1.5;
                sound.play('hit');
                particles.pong.emit(pongP2.x, pongBall.y, { count: 15, color: '#ff6b6b', speed: 4, spread: Math.PI / 2 });
                screenShake('#pongCanvas', 3, 100);
            }

            // Score - P2 scores
            if (pongBall.x <= 0) {
                pongScores.p2++;
                updatePongScores();
                sound.play('score');
                particles.pong.explosion(pongBall.x, pongBall.y, '#ff6b6b', 30);
                screenShake('.pong-cabinet', 8, 300);
                document.getElementById('p2Score').classList.add('score-pop');
                setTimeout(() => document.getElementById('p2Score').classList.remove('score-pop'), 300);
                resetPongBall();
            }
            // Score - P1 scores
            if (pongBall.x >= 480) {
                pongScores.p1++;
                updatePongScores();
                sound.play('score');
                particles.pong.explosion(pongBall.x, pongBall.y, '#00ff88', 30);
                screenShake('.pong-cabinet', 8, 300);
                document.getElementById('p1Score').classList.add('score-pop');
                setTimeout(() => document.getElementById('p1Score').classList.remove('score-pop'), 300);
                resetPongBall();
            }

            // Update particles
            particles.pong.update();

            // Draw background
            pongCtx.fillStyle = '#000';
            pongCtx.fillRect(0, 0, 480, 280);

            // Center line
            pongCtx.setLineDash([8, 8]);
            pongCtx.strokeStyle = '#333';
            pongCtx.lineWidth = 2;
            pongCtx.beginPath();
            pongCtx.moveTo(240, 0);
            pongCtx.lineTo(240, 280);
            pongCtx.stroke();
            pongCtx.setLineDash([]);

            // Draw particles
            particles.pong.draw(pongCtx);

            // Glow effect for paddles
            pongCtx.shadowBlur = 15;

            // P1 Paddle
            pongCtx.shadowColor = '#00ff88';
            pongCtx.fillStyle = '#00ff88';
            pongCtx.fillRect(pongP1.x, pongP1.y, pongP1.width, pongP1.height);

            // P2 Paddle
            pongCtx.shadowColor = '#ff6b6b';
            pongCtx.fillStyle = '#ff6b6b';
            pongCtx.fillRect(pongP2.x, pongP2.y, pongP2.width, pongP2.height);

            // Ball with glow
            pongCtx.shadowColor = '#fff';
            pongCtx.shadowBlur = 20;
            pongCtx.fillStyle = '#ffffff';
            pongCtx.beginPath();
            pongCtx.arc(pongBall.x, pongBall.y, pongBall.radius, 0, Math.PI * 2);
            pongCtx.fill();

            pongCtx.shadowBlur = 0;

            pongAnimationId = requestAnimationFrame(pongLoop);
        }

        // ==================== REACTION RACE ====================
        let reactionTimeout, reactionReady, reactionScores, reactionActive;

        function initReaction() {
            reactionScores = { p1: 0, p2: 0 };
            reactionReady = false;
            reactionActive = false;
            document.getElementById('reactionScore1').textContent = '0';
            document.getElementById('reactionScore2').textContent = '0';
            document.getElementById('reactionStatus').textContent = 'Press START to begin!';
            document.getElementById('reactionP1').classList.remove('ready');
            document.getElementById('reactionP2').classList.remove('ready');
        }

        function startReaction() {
            if (reactionActive) return;
            reactionActive = true;
            reactionReady = false;
            document.getElementById('reactionP1').classList.remove('ready');
            document.getElementById('reactionP2').classList.remove('ready');
            document.getElementById('reactionStatus').textContent = 'Wait for it...';

            if (reactionTimeout) clearTimeout(reactionTimeout);

            const delay = 1500 + Math.random() * 3000;
            reactionTimeout = setTimeout(() => {
                reactionReady = true;
                document.getElementById('reactionP1').classList.add('ready');
                document.getElementById('reactionP2').classList.add('ready');
                document.getElementById('reactionStatus').textContent = 'GO! GO! GO!';
                sound.play('beep', { freq: 880 });
            }, delay);
        }

        document.addEventListener('keydown', (e) => {
            if (!document.getElementById('reactionModal').classList.contains('active')) return;
            if (!reactionActive) return;

            if (e.key.toLowerCase() === 'q') {
                handleReactionPress(1);
            } else if (e.key.toLowerCase() === 'p') {
                handleReactionPress(2);
            }
        });

        function handleReactionPress(player) {
            if (!reactionActive) return;
            if (reactionTimeout) clearTimeout(reactionTimeout);
            reactionActive = false;

            if (!reactionReady) {
                const otherPlayer = player === 1 ? 2 : 1;
                reactionScores[`p${otherPlayer}`]++;
                document.getElementById(`reactionScore${otherPlayer}`).textContent = reactionScores[`p${otherPlayer}`];
                document.getElementById('reactionStatus').textContent = `Too early! Point to P${otherPlayer}`;
                sound.play('lose');
                screenShake(`#reactionP${player}`, 5, 200);
            } else {
                reactionScores[`p${player}`]++;
                document.getElementById(`reactionScore${player}`).textContent = reactionScores[`p${player}`];
                document.getElementById('reactionStatus').textContent = `P${player} wins the round!`;
                sound.play('score');
                document.getElementById(`reactionP${player}`).classList.add('winner');
                setTimeout(() => document.getElementById(`reactionP${player}`).classList.remove('winner'), 1000);
            }

            document.getElementById('reactionP1').classList.remove('ready');
            document.getElementById('reactionP2').classList.remove('ready');
            reactionReady = false;
        }

        // Allow clicking the buttons on mobile
        document.getElementById('reactionP1').addEventListener('click', () => {
            if (document.getElementById('reactionModal').classList.contains('active') && reactionActive) {
                handleReactionPress(1);
            }
        });

        document.getElementById('reactionP2').addEventListener('click', () => {
            if (document.getElementById('reactionModal').classList.contains('active') && reactionActive) {
                handleReactionPress(2);
            }
        });
    </script>

    <!-- Snake Battle Modal -->
    <div class="game-modal" id="snakeModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('snake')">&times;</button>
            <h2 class="game-title">SNAKE BATTLE</h2>
            <div class="p2-mode-toggle" id="snakeP2Toggle">
                <span class="p2-mode-label">P2:</span>
                <button class="p2-toggle-btn active" onclick="setP2Mode('snake', 'ai')">AI</button>
                <button class="p2-toggle-btn" onclick="setP2Mode('snake', 'manual')">2P</button>
            </div>
            <div class="game-status" id="snakeStatus">Press START to begin!</div>
            <div class="snake-wrapper">
                <canvas id="snakeCanvas" width="400" height="400"></canvas>
            </div>
            <div class="snake-controls">
                <p>P1: <span>W</span><span>A</span><span>S</span><span>D</span> &nbsp; P2: <span>‚Üë</span><span>‚Üê</span><span>‚Üì</span><span>‚Üí</span></p>
            </div>
            <button class="restart-btn" onclick="startSnake()">START</button>
        </div>
    </div>

    <!-- Memory Match Modal -->
    <div class="game-modal" id="memoryModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('memory')">&times;</button>
            <h2 class="game-title">MEMORY MATCH</h2>
            <div class="p2-mode-toggle" id="memoryP2Toggle">
                <span class="p2-mode-label">P2:</span>
                <button class="p2-toggle-btn active" onclick="setP2Mode('memory', 'ai')">AI</button>
                <button class="p2-toggle-btn" onclick="setP2Mode('memory', 'manual')">2P</button>
            </div>
            <div class="game-status" id="memoryStatus">Player 1's turn</div>
            <div class="memory-scores">
                <span class="memory-score p1">P1: <span id="memoryScore1">0</span></span>
                <span class="memory-score p2">P2: <span id="memoryScore2">0</span></span>
            </div>
            <div class="memory-board" id="memoryBoard"></div>
            <button class="restart-btn" onclick="initMemory()">RESTART</button>
        </div>
    </div>

    <!-- Rock Paper Scissors Modal -->
    <div class="game-modal" id="rpsModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('rps')">&times;</button>
            <h2 class="game-title">ROCK PAPER SCISSORS</h2>
            <div class="game-status" id="rpsStatus">Best of 5 - Choose your weapon!</div>
            <div class="rps-scores">
                <span class="rps-score p1">P1: <span id="rpsScore1">0</span></span>
                <span class="rps-score p2">P2: <span id="rpsScore2">0</span></span>
            </div>
            <div class="rps-arena">
                <div class="rps-player" id="rpsP1Area">
                    <div class="rps-label">Player 1</div>
                    <div class="rps-choice" id="rpsP1Choice">?</div>
                    <div class="rps-buttons">
                        <button onclick="rpsSelect(1, 'rock')">ü™®</button>
                        <button onclick="rpsSelect(1, 'paper')">üìÑ</button>
                        <button onclick="rpsSelect(1, 'scissors')">‚úÇÔ∏è</button>
                    </div>
                </div>
                <div class="rps-vs">VS</div>
                <div class="rps-player" id="rpsP2Area">
                    <div class="rps-label">Player 2</div>
                    <div class="rps-choice" id="rpsP2Choice">?</div>
                    <div class="rps-buttons">
                        <button onclick="rpsSelect(2, 'rock')">ü™®</button>
                        <button onclick="rpsSelect(2, 'paper')">üìÑ</button>
                        <button onclick="rpsSelect(2, 'scissors')">‚úÇÔ∏è</button>
                    </div>
                </div>
            </div>
            <button class="restart-btn" onclick="initRPS()">RESTART</button>
        </div>
    </div>

    <!-- Speed Typing Modal -->
    <div class="game-modal" id="typingModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('typing')">&times;</button>
            <h2 class="game-title">SPEED TYPING</h2>
            <div class="game-status" id="typingStatus">First to 5 wins!</div>
            <div class="typing-scores">
                <span class="typing-score p1">P1: <span id="typingScore1">0</span></span>
                <span class="typing-score p2">P2: <span id="typingScore2">0</span></span>
            </div>
            <div class="typing-word" id="typingWord">READY</div>
            <div class="typing-inputs">
                <div class="typing-player">
                    <label>Player 1</label>
                    <input type="text" id="typingInput1" placeholder="Type here..." autocomplete="off">
                </div>
                <div class="typing-player">
                    <label>Player 2</label>
                    <input type="text" id="typingInput2" placeholder="Type here..." autocomplete="off">
                </div>
            </div>
            <button class="restart-btn" onclick="startTyping()">START</button>
        </div>
    </div>

    <!-- Whack-a-Mole Modal -->
    <div class="game-modal" id="whackModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('whack')">&times;</button>
            <h2 class="game-title">WHACK-A-MOLE</h2>
            <div class="game-status" id="whackStatus">30 seconds - Click to whack!</div>
            <div class="whack-scores">
                <span class="whack-score p1">P1: <span id="whackScore1">0</span></span>
                <span class="whack-timer" id="whackTimer">30</span>
                <span class="whack-score p2">P2: <span id="whackScore2">0</span></span>
            </div>
            <div class="whack-arena">
                <div class="whack-side p1">
                    <div class="whack-grid" id="whackGrid1"></div>
                </div>
                <div class="whack-side p2">
                    <div class="whack-grid" id="whackGrid2"></div>
                </div>
            </div>
            <button class="restart-btn" onclick="startWhack()">START</button>
        </div>
    </div>

    <!-- Air Hockey Modal -->
    <div class="game-modal" id="airhockeyModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('airhockey')">&times;</button>
            <h2 class="game-title">AIR HOCKEY</h2>
            <div class="p2-mode-toggle" id="hockeyP2Toggle">
                <span class="p2-mode-label">P2:</span>
                <button class="p2-toggle-btn active" onclick="setP2Mode('airhockey', 'ai')">AI</button>
                <button class="p2-toggle-btn" onclick="setP2Mode('airhockey', 'manual')">2P</button>
            </div>
            <div class="hockey-wrapper">
                <div class="hockey-cabinet">
                    <div class="hockey-scores">
                        <span class="hockey-score p1" id="hockeyScore1">0</span>
                        <span class="hockey-score p2" id="hockeyScore2">0</span>
                    </div>
                    <canvas id="hockeyCanvas" width="400" height="500"></canvas>
                </div>
                <div class="hockey-controls">
                    <p>P1: <span>W</span><span>A</span><span>S</span><span>D</span> &nbsp; P2: <span>‚Üë</span><span>‚Üê</span><span>‚Üì</span><span>‚Üí</span></p>
                </div>
            </div>
            <button class="restart-btn" onclick="resetHockey()">RESTART</button>
        </div>
    </div>

    <!-- Battleship Modal -->
    <div class="game-modal" id="battleshipModal">
        <div class="game-container" style="max-width: 800px;">
            <button class="close-game" onclick="closeGame('battleship')">&times;</button>
            <h2 class="game-title">BATTLESHIP</h2>
            <div class="game-status" id="battleshipStatus">Player 1: Place your ships!</div>
            <div class="battleship-arena">
                <div class="battleship-side">
                    <div class="battleship-label">Player 1</div>
                    <div class="battleship-grid" id="bsGrid1"></div>
                </div>
                <div class="battleship-side">
                    <div class="battleship-label">Player 2</div>
                    <div class="battleship-grid" id="bsGrid2"></div>
                </div>
            </div>
            <div class="battleship-info" id="bsInfo">Click cells to place 5 ships</div>
            <button class="restart-btn" onclick="initBattleship()">RESTART</button>
        </div>
    </div>

    <!-- Simon Says Modal -->
    <div class="game-modal" id="simonModal">
        <div class="game-container">
            <button class="close-game" onclick="closeGame('simon')">&times;</button>
            <h2 class="game-title">SIMON SAYS</h2>
            <div class="game-status" id="simonStatus">Watch the pattern!</div>
            <div class="simon-scores">
                <span class="simon-score p1">P1: <span id="simonScore1">0</span></span>
                <span class="simon-score p2">P2: <span id="simonScore2">0</span></span>
            </div>
            <div class="simon-board">
                <button class="simon-btn" data-color="green" id="simonGreen"></button>
                <button class="simon-btn" data-color="red" id="simonRed"></button>
                <button class="simon-btn" data-color="yellow" id="simonYellow"></button>
                <button class="simon-btn" data-color="blue" id="simonBlue"></button>
            </div>
            <div class="simon-info" id="simonInfo">Current Player: P1</div>
            <button class="restart-btn" onclick="initSimon()">START</button>
        </div>
    </div>

    <script>
        // ==================== SNAKE BATTLE ====================
        let snakeCanvas, snakeCtx, snakeAnimationId, snakeGameRunning;
        let snake1, snake2, snakeFood;
        const SNAKE_GRID = 20;
        const SNAKE_SIZE = 400 / SNAKE_GRID;

        function initSnake() {
            snakeCanvas = document.getElementById('snakeCanvas');
            snakeCtx = snakeCanvas.getContext('2d');
            snakeGameRunning = false;
            document.getElementById('snakeStatus').textContent = 'Press START to begin!';
        }

        function startSnake() {
            snake1 = {
                body: [{x: 3, y: 10}, {x: 2, y: 10}, {x: 1, y: 10}],
                dir: {x: 1, y: 0},
                nextDir: {x: 1, y: 0},
                color: '#00ff88',
                alive: true
            };
            snake2 = {
                body: [{x: 16, y: 10}, {x: 17, y: 10}, {x: 18, y: 10}],
                dir: {x: -1, y: 0},
                nextDir: {x: -1, y: 0},
                color: '#ff6b6b',
                alive: true
            };
            placeSnakeFood();
            snakeGameRunning = true;
            document.getElementById('snakeStatus').textContent = 'GO!';
            if (snakeAnimationId) cancelAnimationFrame(snakeAnimationId);
            snakeLoop();
        }

        function placeSnakeFood() {
            do {
                snakeFood = {
                    x: Math.floor(Math.random() * SNAKE_GRID),
                    y: Math.floor(Math.random() * SNAKE_GRID)
                };
            } while (isSnakeCollision(snakeFood, snake1.body) || isSnakeCollision(snakeFood, snake2.body));
        }

        function isSnakeCollision(pos, body) {
            return body.some(seg => seg.x === pos.x && seg.y === pos.y);
        }

        let snakeLastTime = 0;
        const SNAKE_SPEED = 120;

        function snakeAIMove() {
            if (!snake2.alive || p2Modes.snake !== 'ai') return;

            const head = snake2.body[0];
            const possibleDirs = [
                {x: 0, y: -1}, // up
                {x: 0, y: 1},  // down
                {x: -1, y: 0}, // left
                {x: 1, y: 0}   // right
            ].filter(dir => {
                // Can't reverse
                if (dir.x === -snake2.dir.x && dir.y === -snake2.dir.y) return false;
                // Check if safe
                const newHead = {x: head.x + dir.x, y: head.y + dir.y};
                if (newHead.x < 0 || newHead.x >= SNAKE_GRID || newHead.y < 0 || newHead.y >= SNAKE_GRID) return false;
                if (isSnakeCollision(newHead, snake2.body)) return false;
                if (isSnakeCollision(newHead, snake1.body)) return false;
                return true;
            });

            if (possibleDirs.length === 0) return; // No safe moves

            // Prefer direction toward food
            let bestDir = possibleDirs[0];
            let bestDist = Infinity;
            for (const dir of possibleDirs) {
                const newHead = {x: head.x + dir.x, y: head.y + dir.y};
                const dist = Math.abs(newHead.x - snakeFood.x) + Math.abs(newHead.y - snakeFood.y);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestDir = dir;
                }
            }
            snake2.nextDir = bestDir;
        }

        function snakeLoop(timestamp) {
            if (!snakeGameRunning) return;

            if (timestamp - snakeLastTime >= SNAKE_SPEED) {
                snakeLastTime = timestamp;
                snakeAIMove(); // AI decides next move before update
                updateSnakes();
            }

            drawSnakes();
            snakeAnimationId = requestAnimationFrame(snakeLoop);
        }

        function updateSnakes() {
            let snakeDied = false;
            [snake1, snake2].forEach(snake => {
                if (!snake.alive) return;
                snake.dir = snake.nextDir;
                const head = {x: snake.body[0].x + snake.dir.x, y: snake.body[0].y + snake.dir.y};

                // Wall collision
                if (head.x < 0 || head.x >= SNAKE_GRID || head.y < 0 || head.y >= SNAKE_GRID) {
                    snake.alive = false;
                    snakeDied = true;
                    // Death explosion particles
                    const deathX = snake.body[0].x * SNAKE_SIZE + SNAKE_SIZE/2;
                    const deathY = snake.body[0].y * SNAKE_SIZE + SNAKE_SIZE/2;
                    particles.snake.explosion(deathX, deathY, snake.color, 40);
                    sound.play('explosion');
                    screenShake('#snakeCanvas', 10, 300);
                    return;
                }

                // Self collision
                if (isSnakeCollision(head, snake.body)) {
                    snake.alive = false;
                    snakeDied = true;
                    const deathX = head.x * SNAKE_SIZE + SNAKE_SIZE/2;
                    const deathY = head.y * SNAKE_SIZE + SNAKE_SIZE/2;
                    particles.snake.explosion(deathX, deathY, snake.color, 40);
                    sound.play('explosion');
                    screenShake('#snakeCanvas', 10, 300);
                    return;
                }

                // Other snake collision
                const other = snake === snake1 ? snake2 : snake1;
                if (isSnakeCollision(head, other.body)) {
                    snake.alive = false;
                    snakeDied = true;
                    const deathX = head.x * SNAKE_SIZE + SNAKE_SIZE/2;
                    const deathY = head.y * SNAKE_SIZE + SNAKE_SIZE/2;
                    particles.snake.explosion(deathX, deathY, snake.color, 40);
                    sound.play('explosion');
                    screenShake('#snakeCanvas', 10, 300);
                    return;
                }

                snake.body.unshift(head);

                // Food
                if (head.x === snakeFood.x && head.y === snakeFood.y) {
                    // Eat effect
                    const foodX = snakeFood.x * SNAKE_SIZE + SNAKE_SIZE/2;
                    const foodY = snakeFood.y * SNAKE_SIZE + SNAKE_SIZE/2;
                    particles.snake.emit(foodX, foodY, { count: 10, color: '#ffd93d', speed: 3, lifetime: 30, type: 'star' });
                    sound.play('pop');
                    placeSnakeFood();
                } else {
                    snake.body.pop();
                }
            });

            // Check win
            if (!snake1.alive || !snake2.alive) {
                snakeGameRunning = false;
                if (!snake1.alive && !snake2.alive) {
                    document.getElementById('snakeStatus').textContent = "It's a tie!";
                } else if (!snake1.alive) {
                    document.getElementById('snakeStatus').textContent = 'Player 2 wins!';
                    sound.play('win');
                } else {
                    document.getElementById('snakeStatus').textContent = 'Player 1 wins!';
                    sound.play('win');
                }
            }
        }

        function drawSnakes() {
            // Update particles
            particles.snake.update();

            snakeCtx.fillStyle = '#0a0a15';
            snakeCtx.fillRect(0, 0, 400, 400);

            // Grid
            snakeCtx.strokeStyle = '#1a1a2a';
            for (let i = 0; i <= SNAKE_GRID; i++) {
                snakeCtx.beginPath();
                snakeCtx.moveTo(i * SNAKE_SIZE, 0);
                snakeCtx.lineTo(i * SNAKE_SIZE, 400);
                snakeCtx.stroke();
                snakeCtx.beginPath();
                snakeCtx.moveTo(0, i * SNAKE_SIZE);
                snakeCtx.lineTo(400, i * SNAKE_SIZE);
                snakeCtx.stroke();
            }

            // Food with pulsing effect
            const pulse = 1 + Math.sin(Date.now() / 200) * 0.2;
            snakeCtx.fillStyle = '#ffd93d';
            snakeCtx.shadowColor = '#ffd93d';
            snakeCtx.shadowBlur = 15 * pulse;
            snakeCtx.beginPath();
            snakeCtx.arc(snakeFood.x * SNAKE_SIZE + SNAKE_SIZE/2, snakeFood.y * SNAKE_SIZE + SNAKE_SIZE/2, (SNAKE_SIZE/2 - 2) * pulse, 0, Math.PI * 2);
            snakeCtx.fill();
            snakeCtx.shadowBlur = 0;

            // Draw particles
            particles.snake.draw(snakeCtx);

            // Snakes with gradient effect
            [snake1, snake2].forEach(snake => {
                snake.body.forEach((seg, i) => {
                    const alpha = snake.alive ? 1 - (i / snake.body.length) * 0.5 : 0.3;
                    snakeCtx.globalAlpha = alpha;
                    snakeCtx.fillStyle = snake.alive ? snake.color : '#666';
                    if (i === 0) {
                        snakeCtx.shadowColor = snake.color;
                        snakeCtx.shadowBlur = 15;
                        // Draw eyes on head
                        snakeCtx.fillRect(seg.x * SNAKE_SIZE + 1, seg.y * SNAKE_SIZE + 1, SNAKE_SIZE - 2, SNAKE_SIZE - 2);
                        snakeCtx.shadowBlur = 0;
                        // Eyes
                        snakeCtx.fillStyle = '#fff';
                        const eyeOffset = SNAKE_SIZE / 4;
                        snakeCtx.beginPath();
                        snakeCtx.arc(seg.x * SNAKE_SIZE + eyeOffset + 3, seg.y * SNAKE_SIZE + eyeOffset + 3, 2, 0, Math.PI * 2);
                        snakeCtx.arc(seg.x * SNAKE_SIZE + SNAKE_SIZE - eyeOffset - 3, seg.y * SNAKE_SIZE + eyeOffset + 3, 2, 0, Math.PI * 2);
                        snakeCtx.fill();
                    } else {
                        snakeCtx.fillRect(seg.x * SNAKE_SIZE + 2, seg.y * SNAKE_SIZE + 2, SNAKE_SIZE - 4, SNAKE_SIZE - 4);
                    }
                });
                snakeCtx.globalAlpha = 1;
            });
        }

        document.addEventListener('keydown', (e) => {
            if (!document.getElementById('snakeModal').classList.contains('active')) return;
            if (!snakeGameRunning) return;

            // P1 controls
            if (e.key.toLowerCase() === 'w' && snake1.dir.y !== 1) snake1.nextDir = {x: 0, y: -1};
            if (e.key.toLowerCase() === 's' && snake1.dir.y !== -1) snake1.nextDir = {x: 0, y: 1};
            if (e.key.toLowerCase() === 'a' && snake1.dir.x !== 1) snake1.nextDir = {x: -1, y: 0};
            if (e.key.toLowerCase() === 'd' && snake1.dir.x !== -1) snake1.nextDir = {x: 1, y: 0};

            // P2 controls (only in manual mode)
            if (p2Modes.snake === 'manual') {
                if (e.key === 'ArrowUp' && snake2.dir.y !== 1) snake2.nextDir = {x: 0, y: -1};
                if (e.key === 'ArrowDown' && snake2.dir.y !== -1) snake2.nextDir = {x: 0, y: 1};
                if (e.key === 'ArrowLeft' && snake2.dir.x !== 1) snake2.nextDir = {x: -1, y: 0};
                if (e.key === 'ArrowRight' && snake2.dir.x !== -1) snake2.nextDir = {x: 1, y: 0};
            }

            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });

        function stopSnake() {
            snakeGameRunning = false;
            if (snakeAnimationId) cancelAnimationFrame(snakeAnimationId);
        }

        // ==================== MEMORY MATCH ====================
        let memoryCards, memoryFlipped, memoryMatched, memoryCurrentPlayer, memoryScores, memoryLocked;
        const MEMORY_ICONS = ['üéÆ', 'üéØ', 'üé≤', 'üé™', 'üé®', 'üé≠', 'üé™', 'üéØ'];

        function initMemory() {
            const icons = [...MEMORY_ICONS, ...MEMORY_ICONS];
            memoryCards = icons.sort(() => Math.random() - 0.5);
            memoryFlipped = [];
            memoryMatched = new Set();
            memoryCurrentPlayer = 1;
            memoryScores = {1: 0, 2: 0};
            memoryLocked = false;
            memoryAIKnown = {}; // Reset AI memory
            document.getElementById('memoryScore1').textContent = '0';
            document.getElementById('memoryScore2').textContent = '0';
            document.getElementById('memoryStatus').textContent = "Player 1's turn";
            document.getElementById('memoryStatus').style.color = '#00ff88';
            renderMemory();
        }

        function renderMemory() {
            const board = document.getElementById('memoryBoard');
            board.innerHTML = '';
            memoryCards.forEach((icon, i) => {
                const card = document.createElement('div');
                card.className = `memory-card ${memoryFlipped.includes(i) || memoryMatched.has(i) ? 'flipped' : ''}`;
                card.innerHTML = `<div class="memory-front">?</div><div class="memory-back">${icon}</div>`;
                card.onclick = () => flipCard(i);
                board.appendChild(card);
            });
        }

        function flipCard(index) {
            if (memoryLocked || memoryFlipped.includes(index) || memoryMatched.has(index)) return;
            // In AI mode, only allow clicks during player 1's turn
            if (p2Modes.memory === 'ai' && memoryCurrentPlayer !== 1) return;

            memoryFlipped.push(index);
            renderMemory();

            if (memoryFlipped.length === 2) {
                memoryLocked = true;
                const [first, second] = memoryFlipped;

                if (memoryCards[first] === memoryCards[second]) {
                    memoryMatched.add(first);
                    memoryMatched.add(second);
                    memoryScores[memoryCurrentPlayer]++;
                    document.getElementById(`memoryScore${memoryCurrentPlayer}`).textContent = memoryScores[memoryCurrentPlayer];
                    memoryFlipped = [];
                    memoryLocked = false;

                    if (memoryMatched.size === memoryCards.length) {
                        const winner = memoryScores[1] > memoryScores[2] ? 1 : memoryScores[2] > memoryScores[1] ? 2 : 0;
                        document.getElementById('memoryStatus').textContent = winner ? `Player ${winner} wins!` : "It's a tie!";
                        document.getElementById('memoryStatus').style.color = '#ffd93d';
                    } else if (p2Modes.memory === 'ai' && memoryCurrentPlayer === 2) {
                        // AI got a match, goes again
                        setTimeout(() => memoryAITurn(), 800);
                    }
                } else {
                    setTimeout(() => {
                        memoryFlipped = [];
                        memoryCurrentPlayer = memoryCurrentPlayer === 1 ? 2 : 1;
                        document.getElementById('memoryStatus').textContent = `Player ${memoryCurrentPlayer}'s turn`;
                        document.getElementById('memoryStatus').style.color = memoryCurrentPlayer === 1 ? '#00ff88' : '#ff6b6b';
                        memoryLocked = false;
                        renderMemory();

                        // AI's turn
                        if (p2Modes.memory === 'ai' && memoryCurrentPlayer === 2) {
                            setTimeout(() => memoryAITurn(), 600);
                        }
                    }, 1000);
                }
            }
        }

        // AI memory: remembers seen cards
        let memoryAIKnown = {};

        function memoryAITurn() {
            if (memoryMatched.size === memoryCards.length) return;

            const unmatched = [];
            for (let i = 0; i < memoryCards.length; i++) {
                if (!memoryMatched.has(i)) unmatched.push(i);
            }

            // Check if AI knows a matching pair
            let firstCard = -1, secondCard = -1;
            for (let i = 0; i < unmatched.length; i++) {
                const cardI = unmatched[i];
                const iconI = memoryAIKnown[cardI];
                if (iconI) {
                    for (let j = i + 1; j < unmatched.length; j++) {
                        const cardJ = unmatched[j];
                        if (memoryAIKnown[cardJ] === iconI) {
                            firstCard = cardI;
                            secondCard = cardJ;
                            break;
                        }
                    }
                }
                if (firstCard !== -1) break;
            }

            if (firstCard === -1) {
                // Pick random cards
                const shuffled = unmatched.sort(() => Math.random() - 0.5);
                firstCard = shuffled[0];
                secondCard = shuffled[1];
            }

            // Flip first card
            memoryFlipped.push(firstCard);
            memoryAIKnown[firstCard] = memoryCards[firstCard];
            renderMemory();

            setTimeout(() => {
                // Flip second card
                memoryFlipped.push(secondCard);
                memoryAIKnown[secondCard] = memoryCards[secondCard];
                renderMemory();

                // Check match
                memoryLocked = true;
                setTimeout(() => {
                    if (memoryCards[firstCard] === memoryCards[secondCard]) {
                        memoryMatched.add(firstCard);
                        memoryMatched.add(secondCard);
                        memoryScores[2]++;
                        document.getElementById('memoryScore2').textContent = memoryScores[2];
                        memoryFlipped = [];
                        memoryLocked = false;
                        renderMemory();

                        if (memoryMatched.size === memoryCards.length) {
                            const winner = memoryScores[1] > memoryScores[2] ? 1 : memoryScores[2] > memoryScores[1] ? 2 : 0;
                            document.getElementById('memoryStatus').textContent = winner ? `Player ${winner} wins!` : "It's a tie!";
                            document.getElementById('memoryStatus').style.color = '#ffd93d';
                        } else {
                            // AI goes again
                            setTimeout(() => memoryAITurn(), 800);
                        }
                    } else {
                        memoryFlipped = [];
                        memoryCurrentPlayer = 1;
                        document.getElementById('memoryStatus').textContent = "Player 1's turn";
                        document.getElementById('memoryStatus').style.color = '#00ff88';
                        memoryLocked = false;
                        renderMemory();
                    }
                }, 800);
            }, 600);
        }

        // ==================== ROCK PAPER SCISSORS ====================
        let rpsChoices, rpsScores, rpsRound;

        function initRPS() {
            rpsChoices = {1: null, 2: null};
            rpsScores = {1: 0, 2: 0};
            rpsRound = 1;
            document.getElementById('rpsScore1').textContent = '0';
            document.getElementById('rpsScore2').textContent = '0';
            document.getElementById('rpsP1Choice').textContent = '?';
            document.getElementById('rpsP2Choice').textContent = '?';
            document.getElementById('rpsStatus').textContent = 'Round 1 - Choose your weapon!';
            document.querySelectorAll('.rps-buttons button').forEach(b => b.disabled = false);
        }

        function rpsSelect(player, choice) {
            rpsChoices[player] = choice;
            const emoji = choice === 'rock' ? 'ü™®' : choice === 'paper' ? 'üìÑ' : '‚úÇÔ∏è';
            document.getElementById(`rpsP${player}Choice`).textContent = '‚úì';

            if (rpsChoices[1] && rpsChoices[2]) {
                setTimeout(rpsReveal, 500);
            }
        }

        function rpsReveal() {
            const emojis = {rock: 'ü™®', paper: 'üìÑ', scissors: '‚úÇÔ∏è'};
            document.getElementById('rpsP1Choice').textContent = emojis[rpsChoices[1]];
            document.getElementById('rpsP2Choice').textContent = emojis[rpsChoices[2]];

            const c1 = rpsChoices[1], c2 = rpsChoices[2];
            let winner = 0;
            if (c1 !== c2) {
                if ((c1 === 'rock' && c2 === 'scissors') || (c1 === 'paper' && c2 === 'rock') || (c1 === 'scissors' && c2 === 'paper')) {
                    winner = 1;
                } else {
                    winner = 2;
                }
                rpsScores[winner]++;
                document.getElementById(`rpsScore${winner}`).textContent = rpsScores[winner];
            }

            if (rpsScores[1] >= 3 || rpsScores[2] >= 3) {
                const champ = rpsScores[1] >= 3 ? 1 : 2;
                document.getElementById('rpsStatus').textContent = `Player ${champ} wins the match!`;
                document.querySelectorAll('.rps-buttons button').forEach(b => b.disabled = true);
            } else {
                document.getElementById('rpsStatus').textContent = winner ? `P${winner} wins round ${rpsRound}!` : 'Tie round!';
                setTimeout(() => {
                    rpsRound++;
                    rpsChoices = {1: null, 2: null};
                    document.getElementById('rpsP1Choice').textContent = '?';
                    document.getElementById('rpsP2Choice').textContent = '?';
                    document.getElementById('rpsStatus').textContent = `Round ${rpsRound} - Choose your weapon!`;
                }, 1500);
            }
        }

        // ==================== SPEED TYPING ====================
        let typingScores, typingCurrentWord, typingActive;
        const TYPING_WORDS = ['CYBER', 'HACK', 'CODE', 'DEBUG', 'SCRIPT', 'PIXEL', 'BINARY', 'STACK', 'ARRAY', 'LOOP', 'CACHE', 'QUEUE', 'SHELL', 'VIRUS', 'PROXY', 'REGEX', 'PARSE', 'LOGIC', 'PATCH', 'SUDO'];

        function initTyping() {
            typingScores = {1: 0, 2: 0};
            typingActive = false;
            document.getElementById('typingScore1').textContent = '0';
            document.getElementById('typingScore2').textContent = '0';
            document.getElementById('typingWord').textContent = 'READY';
            document.getElementById('typingInput1').value = '';
            document.getElementById('typingInput2').value = '';
            document.getElementById('typingStatus').textContent = 'First to 5 wins!';
        }

        function startTyping() {
            initTyping();
            typingActive = true;
            nextTypingWord();
        }

        function nextTypingWord() {
            typingCurrentWord = TYPING_WORDS[Math.floor(Math.random() * TYPING_WORDS.length)];
            document.getElementById('typingWord').textContent = typingCurrentWord;
            document.getElementById('typingInput1').value = '';
            document.getElementById('typingInput2').value = '';
            document.getElementById('typingInput1').focus();
        }

        document.getElementById('typingInput1')?.addEventListener('input', (e) => checkTyping(1, e.target.value));
        document.getElementById('typingInput2')?.addEventListener('input', (e) => checkTyping(2, e.target.value));

        function checkTyping(player, value) {
            if (!typingActive) return;
            if (value.toUpperCase() === typingCurrentWord) {
                typingScores[player]++;
                document.getElementById(`typingScore${player}`).textContent = typingScores[player];

                if (typingScores[player] >= 5) {
                    typingActive = false;
                    document.getElementById('typingWord').textContent = 'üèÜ';
                    document.getElementById('typingStatus').textContent = `Player ${player} wins!`;
                } else {
                    nextTypingWord();
                }
            }
        }

        // ==================== WHACK-A-MOLE ====================
        let whackScores, whackTimer, whackInterval, whackMoleIntervals, whackActive;

        function initWhack() {
            whackScores = {1: 0, 2: 0};
            whackActive = false;
            document.getElementById('whackScore1').textContent = '0';
            document.getElementById('whackScore2').textContent = '0';
            document.getElementById('whackTimer').textContent = '30';
            document.getElementById('whackStatus').textContent = 'Press START!';
            renderWhackGrids();
        }

        function renderWhackGrids() {
            [1, 2].forEach(p => {
                const grid = document.getElementById(`whackGrid${p}`);
                grid.innerHTML = '';
                for (let i = 0; i < 9; i++) {
                    const hole = document.createElement('div');
                    hole.className = 'whack-hole';
                    hole.dataset.player = p;
                    hole.dataset.index = i;
                    hole.onclick = () => whackMole(p, i);
                    grid.appendChild(hole);
                }
            });
        }

        function startWhack() {
            initWhack();
            whackActive = true;
            let timeLeft = 30;
            document.getElementById('whackStatus').textContent = 'WHACK!';

            whackInterval = setInterval(() => {
                timeLeft--;
                document.getElementById('whackTimer').textContent = timeLeft;
                if (timeLeft <= 0) {
                    endWhack();
                }
            }, 1000);

            whackMoleIntervals = [1, 2].map(p => setInterval(() => spawnMole(p), 800));
        }

        function spawnMole(player) {
            if (!whackActive) return;
            const grid = document.getElementById(`whackGrid${player}`);
            const holes = grid.querySelectorAll('.whack-hole');
            const emptyHoles = Array.from(holes).filter(h => !h.classList.contains('mole'));
            if (emptyHoles.length) {
                const hole = emptyHoles[Math.floor(Math.random() * emptyHoles.length)];
                hole.classList.add('mole');
                setTimeout(() => hole.classList.remove('mole'), 1000);
            }
        }

        function whackMole(player, index) {
            if (!whackActive) return;
            const hole = document.querySelector(`.whack-hole[data-player="${player}"][data-index="${index}"]`);
            if (hole.classList.contains('mole')) {
                hole.classList.remove('mole');
                hole.classList.add('hit');
                setTimeout(() => hole.classList.remove('hit'), 200);
                whackScores[player]++;
                document.getElementById(`whackScore${player}`).textContent = whackScores[player];
            }
        }

        function endWhack() {
            whackActive = false;
            clearInterval(whackInterval);
            whackMoleIntervals.forEach(i => clearInterval(i));
            const winner = whackScores[1] > whackScores[2] ? 1 : whackScores[2] > whackScores[1] ? 2 : 0;
            document.getElementById('whackStatus').textContent = winner ? `Player ${winner} wins!` : "It's a tie!";
        }

        function stopWhack() {
            whackActive = false;
            if (whackInterval) clearInterval(whackInterval);
            if (whackMoleIntervals) whackMoleIntervals.forEach(i => clearInterval(i));
        }

        // ==================== AIR HOCKEY ====================
        let hockeyCanvas, hockeyCtx, hockeyAnimationId;
        let hockeyPuck, hockeyP1, hockeyP2, hockeyScores, hockeyKeys;

        function initHockey() {
            hockeyCanvas = document.getElementById('hockeyCanvas');
            hockeyCtx = hockeyCanvas.getContext('2d');
            hockeyScores = {1: 0, 2: 0};
            hockeyKeys = {};
            resetHockeyPositions();
            updateHockeyScores();

            document.addEventListener('keydown', handleHockeyKeyDown);
            document.addEventListener('keyup', handleHockeyKeyUp);

            if (hockeyAnimationId) cancelAnimationFrame(hockeyAnimationId);
            hockeyLoop();
        }

        function handleHockeyKeyDown(e) {
            hockeyKeys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
        }

        function handleHockeyKeyUp(e) {
            hockeyKeys[e.key] = false;
        }

        function resetHockeyPositions() {
            hockeyPuck = {x: 200, y: 250, vx: 0, vy: 2, radius: 12};
            hockeyP1 = {x: 200, y: 430, radius: 25, vx: 0, vy: 0};
            hockeyP2 = {x: 200, y: 70, radius: 25, vx: 0, vy: 0};
        }

        function resetHockey() {
            hockeyScores = {1: 0, 2: 0};
            updateHockeyScores();
            resetHockeyPositions();
        }

        function updateHockeyScores() {
            document.getElementById('hockeyScore1').textContent = hockeyScores[1];
            document.getElementById('hockeyScore2').textContent = hockeyScores[2];
        }

        function stopHockey() {
            if (hockeyAnimationId) cancelAnimationFrame(hockeyAnimationId);
            document.removeEventListener('keydown', handleHockeyKeyDown);
            document.removeEventListener('keyup', handleHockeyKeyUp);
        }

        function hockeyLoop() {
            // Velocity-based movement for fluid controls
            const accel = 0.8;
            const maxSpeed = 8;
            const friction = 0.88;

            // P1 movement (bottom half) - WASD
            if (hockeyKeys['a']) hockeyP1.vx -= accel;
            else if (hockeyKeys['d']) hockeyP1.vx += accel;
            else hockeyP1.vx *= friction;

            if (hockeyKeys['w']) hockeyP1.vy -= accel;
            else if (hockeyKeys['s']) hockeyP1.vy += accel;
            else hockeyP1.vy *= friction;

            // Clamp P1 velocity
            hockeyP1.vx = Math.max(-maxSpeed, Math.min(maxSpeed, hockeyP1.vx));
            hockeyP1.vy = Math.max(-maxSpeed, Math.min(maxSpeed, hockeyP1.vy));

            // Apply P1 movement with bounds
            hockeyP1.x += hockeyP1.vx;
            hockeyP1.y += hockeyP1.vy;
            hockeyP1.x = Math.max(30, Math.min(370, hockeyP1.x));
            hockeyP1.y = Math.max(270, Math.min(470, hockeyP1.y));

            // P2 movement (top half) - Arrow keys or AI
            if (p2Modes.airhockey === 'ai') {
                // AI follows the puck
                const aiReaction = 0.15;
                const targetX = hockeyPuck.x;
                const targetY = Math.min(hockeyPuck.y, 180); // Stay in top half

                if (targetX < hockeyP2.x - 15) hockeyP2.vx -= accel * aiReaction * 8;
                else if (targetX > hockeyP2.x + 15) hockeyP2.vx += accel * aiReaction * 8;
                else hockeyP2.vx *= friction;

                if (targetY < hockeyP2.y - 15) hockeyP2.vy -= accel * aiReaction * 8;
                else if (targetY > hockeyP2.y + 15) hockeyP2.vy += accel * aiReaction * 8;
                else hockeyP2.vy *= friction;
            } else {
                if (hockeyKeys['ArrowLeft']) hockeyP2.vx -= accel;
                else if (hockeyKeys['ArrowRight']) hockeyP2.vx += accel;
                else hockeyP2.vx *= friction;

                if (hockeyKeys['ArrowUp']) hockeyP2.vy -= accel;
                else if (hockeyKeys['ArrowDown']) hockeyP2.vy += accel;
                else hockeyP2.vy *= friction;
            }

            // Clamp P2 velocity
            hockeyP2.vx = Math.max(-maxSpeed, Math.min(maxSpeed, hockeyP2.vx));
            hockeyP2.vy = Math.max(-maxSpeed, Math.min(maxSpeed, hockeyP2.vy));

            // Apply P2 movement with bounds
            hockeyP2.x += hockeyP2.vx;
            hockeyP2.y += hockeyP2.vy;
            hockeyP2.x = Math.max(30, Math.min(370, hockeyP2.x));
            hockeyP2.y = Math.max(30, Math.min(230, hockeyP2.y));

            // Puck physics
            hockeyPuck.x += hockeyPuck.vx;
            hockeyPuck.y += hockeyPuck.vy;

            // Wall bounce
            if (hockeyPuck.x <= 15 || hockeyPuck.x >= 385) hockeyPuck.vx *= -0.9;
            hockeyPuck.x = Math.max(15, Math.min(385, hockeyPuck.x));

            // Goal check
            if (hockeyPuck.y <= 10) {
                if (hockeyPuck.x > 140 && hockeyPuck.x < 260) {
                    hockeyScores[1]++;
                    updateHockeyScores();
                    resetHockeyPositions();
                } else {
                    hockeyPuck.vy *= -0.9;
                    hockeyPuck.y = 15;
                }
            }
            if (hockeyPuck.y >= 490) {
                if (hockeyPuck.x > 140 && hockeyPuck.x < 260) {
                    hockeyScores[2]++;
                    updateHockeyScores();
                    resetHockeyPositions();
                } else {
                    hockeyPuck.vy *= -0.9;
                    hockeyPuck.y = 485;
                }
            }

            // Paddle collision
            [hockeyP1, hockeyP2].forEach(paddle => {
                const dx = hockeyPuck.x - paddle.x;
                const dy = hockeyPuck.y - paddle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < hockeyPuck.radius + paddle.radius) {
                    const angle = Math.atan2(dy, dx);
                    const speed = Math.sqrt(hockeyPuck.vx ** 2 + hockeyPuck.vy ** 2) + 1;
                    hockeyPuck.vx = Math.cos(angle) * speed;
                    hockeyPuck.vy = Math.sin(angle) * speed;
                    hockeyPuck.x = paddle.x + Math.cos(angle) * (hockeyPuck.radius + paddle.radius + 1);
                    hockeyPuck.y = paddle.y + Math.sin(angle) * (hockeyPuck.radius + paddle.radius + 1);
                }
            });

            // Friction
            hockeyPuck.vx *= 0.99;
            hockeyPuck.vy *= 0.99;

            // Draw
            hockeyCtx.fillStyle = '#1a3d1a';
            hockeyCtx.fillRect(0, 0, 400, 500);

            // Center line
            hockeyCtx.strokeStyle = '#2a5a2a';
            hockeyCtx.lineWidth = 2;
            hockeyCtx.beginPath();
            hockeyCtx.moveTo(0, 250);
            hockeyCtx.lineTo(400, 250);
            hockeyCtx.stroke();

            // Center circle
            hockeyCtx.beginPath();
            hockeyCtx.arc(200, 250, 50, 0, Math.PI * 2);
            hockeyCtx.stroke();

            // Goals
            hockeyCtx.fillStyle = '#333';
            hockeyCtx.fillRect(140, 0, 120, 10);
            hockeyCtx.fillRect(140, 490, 120, 10);

            // Paddles
            hockeyCtx.shadowBlur = 15;
            hockeyCtx.shadowColor = '#00ff88';
            hockeyCtx.fillStyle = '#00ff88';
            hockeyCtx.beginPath();
            hockeyCtx.arc(hockeyP1.x, hockeyP1.y, hockeyP1.radius, 0, Math.PI * 2);
            hockeyCtx.fill();

            hockeyCtx.shadowColor = '#ff6b6b';
            hockeyCtx.fillStyle = '#ff6b6b';
            hockeyCtx.beginPath();
            hockeyCtx.arc(hockeyP2.x, hockeyP2.y, hockeyP2.radius, 0, Math.PI * 2);
            hockeyCtx.fill();

            // Puck
            hockeyCtx.shadowColor = '#fff';
            hockeyCtx.fillStyle = '#111';
            hockeyCtx.beginPath();
            hockeyCtx.arc(hockeyPuck.x, hockeyPuck.y, hockeyPuck.radius, 0, Math.PI * 2);
            hockeyCtx.fill();
            hockeyCtx.strokeStyle = '#fff';
            hockeyCtx.lineWidth = 2;
            hockeyCtx.stroke();

            hockeyCtx.shadowBlur = 0;

            hockeyAnimationId = requestAnimationFrame(hockeyLoop);
        }

        // ==================== BATTLESHIP ====================
        let bsGrids, bsShips, bsCurrentPlayer, bsPhase, bsShipsPlaced;

        function initBattleship() {
            bsGrids = {1: Array(10).fill(null).map(() => Array(10).fill(0)), 2: Array(10).fill(null).map(() => Array(10).fill(0))};
            bsShips = {1: [], 2: []};
            bsCurrentPlayer = 1;
            bsPhase = 'placing';
            bsShipsPlaced = {1: 0, 2: 0};
            document.getElementById('battleshipStatus').textContent = 'Player 1: Place 5 ships!';
            document.getElementById('bsInfo').textContent = 'Click cells to place ships';
            renderBattleshipGrids();
        }

        function renderBattleshipGrids() {
            [1, 2].forEach(p => {
                const grid = document.getElementById(`bsGrid${p}`);
                grid.innerHTML = '';
                for (let row = 0; row < 10; row++) {
                    for (let col = 0; col < 10; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'bs-cell';
                        const val = bsGrids[p][row][col];
                        if (val === 1 && (bsPhase === 'placing' && bsCurrentPlayer === p || bsPhase === 'gameover')) cell.classList.add('ship');
                        if (val === 2) cell.classList.add('hit');
                        if (val === 3) cell.classList.add('miss');
                        cell.onclick = () => handleBsClick(p, row, col);
                        grid.appendChild(cell);
                    }
                }
            });
        }

        function handleBsClick(player, row, col) {
            if (bsPhase === 'placing') {
                if (player !== bsCurrentPlayer) return;
                if (bsGrids[player][row][col] === 1) return;
                bsGrids[player][row][col] = 1;
                bsShipsPlaced[player]++;
                renderBattleshipGrids();

                if (bsShipsPlaced[player] >= 5) {
                    if (bsCurrentPlayer === 1) {
                        bsCurrentPlayer = 2;
                        document.getElementById('battleshipStatus').textContent = 'Player 2: Place 5 ships!';
                    } else {
                        bsPhase = 'playing';
                        bsCurrentPlayer = 1;
                        document.getElementById('battleshipStatus').textContent = "Player 1's turn to attack!";
                        document.getElementById('bsInfo').textContent = 'Click enemy grid to fire';
                    }
                }
            } else if (bsPhase === 'playing') {
                if (player === bsCurrentPlayer) return;
                if (bsGrids[player][row][col] >= 2) return;

                if (bsGrids[player][row][col] === 1) {
                    bsGrids[player][row][col] = 2;
                    document.getElementById('bsInfo').textContent = 'HIT!';
                } else {
                    bsGrids[player][row][col] = 3;
                    document.getElementById('bsInfo').textContent = 'Miss...';
                }
                renderBattleshipGrids();

                // Check win
                const enemy = bsCurrentPlayer === 1 ? 2 : 1;
                const shipsLeft = bsGrids[enemy].flat().filter(c => c === 1).length;
                if (shipsLeft === 0) {
                    bsPhase = 'gameover';
                    document.getElementById('battleshipStatus').textContent = `Player ${bsCurrentPlayer} wins!`;
                    document.getElementById('bsInfo').textContent = 'All ships sunk!';
                } else {
                    bsCurrentPlayer = bsCurrentPlayer === 1 ? 2 : 1;
                    document.getElementById('battleshipStatus').textContent = `Player ${bsCurrentPlayer}'s turn to attack!`;
                }
            }
        }

        // ==================== SIMON SAYS ====================
        let simonSequence, simonPlayerSequence, simonCurrentPlayer, simonScores, simonPlaying, simonShowingPattern;
        const SIMON_COLORS = ['green', 'red', 'yellow', 'blue'];

        function initSimon() {
            simonSequence = [];
            simonPlayerSequence = [];
            simonCurrentPlayer = 1;
            simonScores = {1: 0, 2: 0};
            simonPlaying = true;
            simonShowingPattern = false;
            document.getElementById('simonScore1').textContent = '0';
            document.getElementById('simonScore2').textContent = '0';
            document.getElementById('simonInfo').textContent = 'Current Player: P1';
            addSimonColor();
            setTimeout(() => playSimonSequence(), 500);
        }

        function addSimonColor() {
            simonSequence.push(SIMON_COLORS[Math.floor(Math.random() * 4)]);
        }

        function playSimonSequence() {
            simonShowingPattern = true;
            document.getElementById('simonStatus').textContent = 'Watch the pattern!';
            let i = 0;
            const interval = setInterval(() => {
                if (i >= simonSequence.length) {
                    clearInterval(interval);
                    simonShowingPattern = false;
                    document.getElementById('simonStatus').textContent = 'Your turn!';
                    return;
                }
                flashSimonButton(simonSequence[i]);
                i++;
            }, 600);
        }

        function flashSimonButton(color) {
            const btn = document.getElementById(`simon${color.charAt(0).toUpperCase() + color.slice(1)}`);
            btn.classList.add('active');
            sound.play('simon', { color });
            setTimeout(() => btn.classList.remove('active'), 400);
        }

        document.querySelectorAll('.simon-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (!simonPlaying || simonShowingPattern) return;
                const color = btn.dataset.color;
                flashSimonButton(color);
                simonPlayerSequence.push(color);

                const idx = simonPlayerSequence.length - 1;
                if (simonPlayerSequence[idx] !== simonSequence[idx]) {
                    // Wrong!
                    simonScores[simonCurrentPlayer === 1 ? 2 : 1]++;
                    document.getElementById(`simonScore${simonCurrentPlayer === 1 ? 2 : 1}`).textContent = simonScores[simonCurrentPlayer === 1 ? 2 : 1];
                    document.getElementById('simonStatus').textContent = `P${simonCurrentPlayer} made a mistake!`;

                    if (simonScores[1] >= 3 || simonScores[2] >= 3) {
                        simonPlaying = false;
                        document.getElementById('simonStatus').textContent = `Player ${simonScores[1] >= 3 ? 1 : 2} wins!`;
                    } else {
                        simonCurrentPlayer = simonCurrentPlayer === 1 ? 2 : 1;
                        simonSequence = [];
                        simonPlayerSequence = [];
                        addSimonColor();
                        document.getElementById('simonInfo').textContent = `Current Player: P${simonCurrentPlayer}`;
                        setTimeout(() => playSimonSequence(), 1000);
                    }
                } else if (simonPlayerSequence.length === simonSequence.length) {
                    // Completed sequence
                    document.getElementById('simonStatus').textContent = 'Correct! Watch next...';
                    simonPlayerSequence = [];
                    addSimonColor();
                    setTimeout(() => playSimonSequence(), 1000);
                }
            });
        });

        // Game name mappings for display
        const gameNames = {
            tictactoe: 'Tic Tac Toe',
            connect4: 'Connect Four',
            pong: 'Pong',
            reaction: 'Reaction Race',
            snake: 'Snake Battle',
            memory: 'Memory Match',
            rps: 'Rock Paper Scissors',
            typing: 'Speed Typing',
            whack: 'Whack-a-Mole',
            airhockey: 'Air Hockey',
            battleship: 'Battleship',
            simon: 'Simon Says'
        };

        // Update openGame function
        const originalOpenGame = openGame;
        openGame = function(game, fromInvite = false) {
            document.getElementById(game + 'Modal').classList.add('active');
            if (game === 'tictactoe') initTTT();
            if (game === 'pong') initPong();
            if (game === 'connect4') initC4();
            if (game === 'reaction') initReaction();
            if (game === 'snake') initSnake();
            if (game === 'memory') initMemory();
            if (game === 'rps') initRPS();
            if (game === 'typing') initTyping();
            if (game === 'whack') initWhack();
            if (game === 'airhockey') initHockey();
            if (game === 'battleship') initBattleship();
            if (game === 'simon') initSimon();

            // Send game invite to connected player (if not already from an invite)
            if (mp && mp.connected && !fromInvite) {
                mp.inviteToGame(game, gameNames[game] || game);
            }
        }

        // Update closeGame function
        const originalCloseGame = closeGame;
        closeGame = function(game) {
            document.getElementById(game + 'Modal').classList.remove('active');
            if (game === 'pong') stopPong();
            if (game === 'snake') stopSnake();
            if (game === 'whack') stopWhack();
            if (game === 'airhockey') stopHockey();
        }

        // ==================== MULTIPLAYER MANAGER ====================
        class MultiplayerManager {
            constructor() {
                this.peer = null;
                this.conn = null;
                this.isHost = false;
                this.roomCode = null;
                this.connected = false;
                this.onDataCallback = null;
                this.myName = 'Player';
                this.opponentName = 'Player';
            }

            generateRoomCode() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let code = '';
                for (let i = 0; i < 6; i++) {
                    code += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return code;
            }

            getMyName() {
                const input = document.getElementById('playerNameInput');
                return (input && input.value.trim()) || 'Player';
            }

            async createRoom() {
                return new Promise((resolve, reject) => {
                    this.roomCode = this.generateRoomCode();
                    this.isHost = true;
                    this.myName = this.getMyName();

                    this.peer = new Peer('ryans-arcade-' + this.roomCode, {
                        debug: 0
                    });

                    this.peer.on('open', (id) => {
                        console.log('Room created with code:', this.roomCode);
                        document.getElementById('hostNameDisplay').textContent = this.myName;
                        resolve(this.roomCode);
                    });

                    this.peer.on('connection', (conn) => {
                        console.log('Guest connected!');
                        this.conn = conn;
                        this.setupConnection();
                    });

                    this.peer.on('error', (err) => {
                        console.error('Peer error:', err);
                        if (err.type === 'unavailable-id') {
                            this.peer.destroy();
                            this.createRoom().then(resolve).catch(reject);
                        } else {
                            reject(err);
                        }
                    });
                });
            }

            async joinRoom(code) {
                return new Promise((resolve, reject) => {
                    this.roomCode = code.toUpperCase();
                    this.isHost = false;
                    this.myName = this.getMyName();

                    this.peer = new Peer({
                        debug: 0
                    });

                    this.peer.on('open', () => {
                        console.log('Connecting to room:', this.roomCode);
                        this.conn = this.peer.connect('ryans-arcade-' + this.roomCode, {
                            reliable: true
                        });

                        this.conn.on('open', () => {
                            console.log('Connected to host!');
                            this.setupConnection();
                            resolve();
                        });

                        this.conn.on('error', (err) => {
                            console.error('Connection error:', err);
                            reject(err);
                        });
                    });

                    this.peer.on('error', (err) => {
                        console.error('Peer error:', err);
                        reject(err);
                    });

                    setTimeout(() => {
                        if (!this.connected) {
                            reject(new Error('Connection timeout'));
                        }
                    }, 10000);
                });
            }

            setupConnection() {
                this.connected = true;
                hideP2TogglesInMultiplayer();

                this.conn.on('data', (data) => {
                    // Handle system messages
                    if (data.type === 'playerInfo') {
                        this.opponentName = data.name;
                        this.updatePlayerDisplay();
                    } else if (data.type === 'gameInvite') {
                        showGameInvite(data.game, data.gameName, data.playerName);
                    } else if (data.type === 'gameAccept') {
                        openGame(data.game);
                    } else if (this.onDataCallback) {
                        this.onDataCallback(data);
                    }
                });

                this.conn.on('close', () => {
                    console.log('Connection closed');
                    this.connected = false;
                    this.onDisconnect();
                });

                // Send our name to the other player
                setTimeout(() => {
                    this.send({ type: 'playerInfo', name: this.myName });
                }, 100);

                this.onConnect();
            }

            updatePlayerDisplay() {
                const p1Name = this.isHost ? this.myName : this.opponentName;
                const p2Name = this.isHost ? this.opponentName : this.myName;

                document.getElementById('connectedP1Name').textContent = p1Name;
                document.getElementById('connectedP2Name').textContent = p2Name;

                if (this.isHost) {
                    document.getElementById('hostNameDisplay').textContent = this.myName;
                    document.getElementById('guestLabel').textContent = this.opponentName;
                }
            }

            send(data) {
                if (this.conn && this.connected) {
                    this.conn.send(data);
                }
            }

            onData(callback) {
                this.onDataCallback = callback;
            }

            inviteToGame(game, gameName) {
                this.send({
                    type: 'gameInvite',
                    game: game,
                    gameName: gameName,
                    playerName: this.myName
                });
            }

            acceptGameInvite(game) {
                this.send({ type: 'gameAccept', game: game });
                openGame(game, true); // true = from invite, don't send invite back
            }

            onConnect() {
                document.querySelector('.multiplayer-btn').classList.add('connected');
                document.querySelector('.multiplayer-btn span:last-child').textContent = 'Connected';
                document.querySelectorAll('.game-card').forEach(card => {
                    card.classList.add('mp-active');
                });

                if (this.isHost) {
                    document.getElementById('guestDot').classList.add('connected');
                    document.getElementById('guestLabel').textContent = 'Connected!';
                }

                this.updatePlayerDisplay();

                document.getElementById('lobbyOptions').style.display = 'none';
                document.getElementById('lobbyRoom').style.display = 'none';
                document.getElementById('lobbyJoin').style.display = 'none';
                document.getElementById('lobbyConnecting').style.display = 'none';
                document.getElementById('nameInputSection').style.display = 'none';
                document.getElementById('lobbyConnected').style.display = 'block';
                document.getElementById('lobbyStatus').textContent = 'Connected! Ready to play.';

                sound.play('score');
            }

            onDisconnect() {
                document.querySelector('.multiplayer-btn').classList.remove('connected');
                document.querySelector('.multiplayer-btn span:last-child').textContent = 'Multiplayer';
                document.querySelectorAll('.game-card').forEach(card => {
                    card.classList.remove('mp-active');
                });

                if (this.isHost) {
                    document.getElementById('guestDot').classList.remove('connected');
                    document.getElementById('guestLabel').textContent = 'Disconnected';
                }

                showP2Toggles(); // Show AI/2P toggles again
                sound.play('lose');
                alert('Player disconnected!');
            }

            disconnect() {
                if (this.conn) {
                    this.conn.close();
                }
                if (this.peer) {
                    this.peer.destroy();
                }
                this.connected = false;
                this.peer = null;
                this.conn = null;
                this.roomCode = null;
            }
        }

        // Global multiplayer instance
        const mp = new MultiplayerManager();

        // Game invite popup
        let currentInvite = null;

        function showGameInvite(game, gameName, playerName) {
            // Remove existing invite
            const existing = document.querySelector('.game-invite');
            if (existing) existing.remove();

            const gameIcons = {
                tictactoe: '‚≠ï', connect4: 'üî¥', pong: 'üèì', reaction: '‚ö°',
                snake: 'üêç', memory: 'üÉè', rps: '‚úä', typing: '‚å®Ô∏è',
                whack: 'üî®', airhockey: 'üèí', battleship: 'üö¢', simon: 'üéµ'
            };

            const invite = document.createElement('div');
            invite.className = 'game-invite';
            invite.innerHTML = `
                <div class="game-invite-title">GAME INVITE</div>
                <div class="game-invite-game">${gameIcons[game] || 'üéÆ'}</div>
                <div class="game-invite-name">${playerName} wants to play ${gameName}!</div>
                <div class="game-invite-buttons">
                    <button class="game-invite-btn accept" onclick="acceptInvite('${game}')">JOIN</button>
                    <button class="game-invite-btn decline" onclick="declineInvite()">LATER</button>
                </div>
            `;
            document.body.appendChild(invite);
            sound.play('beep', { freq: 660 });
            currentInvite = game;
        }

        function acceptInvite(game) {
            const invite = document.querySelector('.game-invite');
            if (invite) invite.remove();
            mp.acceptGameInvite(game);
            currentInvite = null;
        }

        function declineInvite() {
            const invite = document.querySelector('.game-invite');
            if (invite) invite.remove();
            currentInvite = null;
        }

        // ==================== LOBBY FUNCTIONS ====================
        function openLobby() {
            document.getElementById('lobbyModal').classList.add('active');
            showLobbyOptions();
        }

        function closeLobby() {
            document.getElementById('lobbyModal').classList.remove('active');
        }

        function showLobbyOptions() {
            document.getElementById('lobbyOptions').style.display = 'flex';
            document.getElementById('lobbyRoom').style.display = 'none';
            document.getElementById('lobbyJoin').style.display = 'none';
            document.getElementById('lobbyConnecting').style.display = 'none';
            document.getElementById('lobbyConnected').style.display = 'none';
            document.getElementById('lobbyStatus').textContent = 'Choose an option to play with a friend!';
        }

        function showJoinInput() {
            document.getElementById('lobbyOptions').style.display = 'none';
            document.getElementById('lobbyJoin').style.display = 'block';
            document.getElementById('lobbyStatus').textContent = 'Enter the room code from your friend';
            document.getElementById('joinCodeInput').value = '';
            document.getElementById('joinCodeInput').focus();
        }

        async function createRoom() {
            document.getElementById('lobbyOptions').style.display = 'none';
            document.getElementById('lobbyConnecting').style.display = 'flex';
            document.getElementById('lobbyStatus').textContent = 'Creating room...';

            try {
                const code = await mp.createRoom();
                document.getElementById('roomCode').textContent = code;
                document.getElementById('lobbyConnecting').style.display = 'none';
                document.getElementById('lobbyRoom').style.display = 'block';
                document.getElementById('lobbyStatus').textContent = 'Share this code with your friend!';
            } catch (error) {
                console.error('Failed to create room:', error);
                document.getElementById('lobbyStatus').textContent = 'Failed to create room. Try again.';
                showLobbyOptions();
            }
        }

        async function joinRoom() {
            const code = document.getElementById('joinCodeInput').value.trim();
            if (code.length !== 6) {
                document.getElementById('lobbyStatus').textContent = 'Please enter a 6-character code';
                return;
            }

            document.getElementById('lobbyJoin').style.display = 'none';
            document.getElementById('lobbyConnecting').style.display = 'flex';
            document.getElementById('lobbyStatus').textContent = 'Connecting to room...';

            try {
                await mp.joinRoom(code);
            } catch (error) {
                console.error('Failed to join room:', error);
                document.getElementById('lobbyStatus').textContent = 'Failed to connect. Check the code and try again.';
                showJoinInput();
            }
        }

        function copyRoomCode() {
            navigator.clipboard.writeText(mp.roomCode).then(() => {
                const btn = event.target.closest('.room-action-btn');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<span>‚úì</span> Copied!';
                setTimeout(() => btn.innerHTML = originalText, 2000);
            });
        }

        function copyRoomLink() {
            const url = window.location.origin + window.location.pathname + '?room=' + mp.roomCode;
            navigator.clipboard.writeText(url).then(() => {
                const btn = event.target.closest('.room-action-btn');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<span>‚úì</span> Copied!';
                setTimeout(() => btn.innerHTML = originalText, 2000);
            });
        }

        // Check for room code in URL on page load
        function checkUrlForRoom() {
            const params = new URLSearchParams(window.location.search);
            const roomCode = params.get('room');
            if (roomCode) {
                openLobby();
                document.getElementById('joinCodeInput').value = roomCode;
                joinRoom();
            }
        }

        // ==================== GAME SYNC HANDLERS ====================
        mp.onData((data) => {
            switch (data.game) {
                case 'tictactoe':
                    handleTTTSync(data);
                    break;
                case 'connect4':
                    handleC4Sync(data);
                    break;
                case 'pong':
                    handlePongSync(data);
                    break;
                case 'reaction':
                    handleReactionSync(data);
                    break;
                case 'snake':
                    handleSnakeSync(data);
                    break;
                case 'memory':
                    handleMemorySync(data);
                    break;
                case 'rps':
                    handleRPSSync(data);
                    break;
                case 'typing':
                    handleTypingSync(data);
                    break;
                case 'whack':
                    handleWhackSync(data);
                    break;
                case 'airhockey':
                    handleHockeySync(data);
                    break;
                case 'battleship':
                    handleBattleshipSync(data);
                    break;
                case 'simon':
                    handleSimonSync(data);
                    break;
            }
        });

        // ==================== TIC TAC TOE SYNC ====================
        function handleTTTSync(data) {
            if (data.type === 'move') {
                tttBoard = data.board;
                tttCurrentPlayer = data.currentPlayer;
                tttGameOver = data.gameOver;
                document.getElementById('tttStatus').textContent = data.status;
                document.getElementById('tttStatus').style.color = data.statusColor;
                renderTTT();
            } else if (data.type === 'restart') {
                initTTT();
            }
        }

        // Modify TTT click handler for multiplayer
        const originalHandleTTTClick = handleTTTClick;
        handleTTTClick = function(i) {
            if (!mp.connected) {
                originalHandleTTTClick(i);
                return;
            }

            // In multiplayer: Host is X, Guest is O
            const myPlayer = mp.isHost ? 'X' : 'O';
            if (tttCurrentPlayer !== myPlayer || tttBoard[i] || tttGameOver) return;

            originalHandleTTTClick(i);

            // Sync state
            mp.send({
                game: 'tictactoe',
                type: 'move',
                board: tttBoard,
                currentPlayer: tttCurrentPlayer,
                gameOver: tttGameOver,
                status: document.getElementById('tttStatus').textContent,
                statusColor: document.getElementById('tttStatus').style.color
            });
        };

        // ==================== CONNECT FOUR SYNC ====================
        function handleC4Sync(data) {
            if (data.type === 'move') {
                c4Board = data.board;
                c4CurrentPlayer = data.currentPlayer;
                c4GameOver = data.gameOver;
                document.getElementById('c4Status').innerHTML = data.status;
                renderC4();
                renderC4Indicators();
            } else if (data.type === 'restart') {
                initC4();
            }
        }

        const originalHandleC4Click = handleC4Click;
        handleC4Click = function(col) {
            if (!mp.connected) {
                originalHandleC4Click(col);
                return;
            }

            const myPlayer = mp.isHost ? 1 : 2;
            if (c4CurrentPlayer !== myPlayer || c4GameOver) return;

            originalHandleC4Click(col);

            mp.send({
                game: 'connect4',
                type: 'move',
                board: c4Board,
                currentPlayer: c4CurrentPlayer,
                gameOver: c4GameOver,
                status: document.getElementById('c4Status').innerHTML
            });
        };

        // ==================== PONG SYNC ====================
        function handlePongSync(data) {
            if (data.type === 'state') {
                // Guest receives game state from host
                if (!mp.isHost) {
                    pongBall = data.ball;
                    pongP1 = data.p1;
                    pongP2 = data.p2;
                    pongScores = data.scores;
                    updatePongScores();
                }
            } else if (data.type === 'input') {
                // Host receives guest input
                if (mp.isHost) {
                    if (data.key === 'up') pongP2.y = Math.max(0, pongP2.y - 6);
                    if (data.key === 'down') pongP2.y = Math.min(230, pongP2.y + 6);
                }
            }
        }

        // Modify pong loop for multiplayer sync
        const originalPongLoop = pongLoop;
        pongLoop = function() {
            if (mp.connected && mp.isHost) {
                // Host runs the game and syncs state
                originalPongLoop.call(this);
                mp.send({
                    game: 'pong',
                    type: 'state',
                    ball: pongBall,
                    p1: pongP1,
                    p2: pongP2,
                    scores: pongScores
                });
            } else if (mp.connected && !mp.isHost) {
                // Guest only renders, doesn't run physics
                pongCtx.fillStyle = '#000';
                pongCtx.fillRect(0, 0, 480, 280);
                pongCtx.setLineDash([8, 8]);
                pongCtx.strokeStyle = '#333';
                pongCtx.lineWidth = 2;
                pongCtx.beginPath();
                pongCtx.moveTo(240, 0);
                pongCtx.lineTo(240, 280);
                pongCtx.stroke();
                pongCtx.setLineDash([]);
                pongCtx.shadowBlur = 15;
                pongCtx.shadowColor = '#00ff88';
                pongCtx.fillStyle = '#00ff88';
                pongCtx.fillRect(pongP1.x, pongP1.y, pongP1.width, pongP1.height);
                pongCtx.shadowColor = '#ff6b6b';
                pongCtx.fillStyle = '#ff6b6b';
                pongCtx.fillRect(pongP2.x, pongP2.y, pongP2.width, pongP2.height);
                pongCtx.shadowColor = '#fff';
                pongCtx.shadowBlur = 20;
                pongCtx.fillStyle = '#ffffff';
                pongCtx.beginPath();
                pongCtx.arc(pongBall.x, pongBall.y, pongBall.radius, 0, Math.PI * 2);
                pongCtx.fill();
                pongCtx.shadowBlur = 0;
                pongAnimationId = requestAnimationFrame(pongLoop);
            } else {
                originalPongLoop.call(this);
            }
        };

        // Send guest input to host
        const originalHandlePongKeyDown = handlePongKeyDown;
        handlePongKeyDown = function(e) {
            originalHandlePongKeyDown(e);
            if (mp.connected && !mp.isHost) {
                if (e.key === 'ArrowUp') mp.send({ game: 'pong', type: 'input', key: 'up' });
                if (e.key === 'ArrowDown') mp.send({ game: 'pong', type: 'input', key: 'down' });
            }
        };

        // ==================== SNAKE SYNC ====================
        function handleSnakeSync(data) {
            if (data.type === 'state') {
                if (!mp.isHost) {
                    snake1 = data.snake1;
                    snake2 = data.snake2;
                    snakeFood = data.food;
                    snakeGameRunning = data.running;
                    document.getElementById('snakeStatus').textContent = data.status;
                }
            } else if (data.type === 'input') {
                if (mp.isHost) {
                    const dir = data.dir;
                    if (dir.x !== -snake2.dir.x && dir.y !== -snake2.dir.y) {
                        snake2.nextDir = dir;
                    }
                }
            } else if (data.type === 'start') {
                startSnake();
            }
        }

        // Modify snake loop for multiplayer
        const originalSnakeLoop = snakeLoop;
        snakeLoop = function(timestamp) {
            if (mp.connected && mp.isHost) {
                originalSnakeLoop.call(this, timestamp);
                mp.send({
                    game: 'snake',
                    type: 'state',
                    snake1: snake1,
                    snake2: snake2,
                    food: snakeFood,
                    running: snakeGameRunning,
                    status: document.getElementById('snakeStatus').textContent
                });
            } else if (mp.connected && !mp.isHost) {
                drawSnakes();
                if (snakeGameRunning) {
                    snakeAnimationId = requestAnimationFrame(snakeLoop);
                }
            } else {
                originalSnakeLoop.call(this, timestamp);
            }
        };

        // ==================== MEMORY SYNC ====================
        function handleMemorySync(data) {
            if (data.type === 'state') {
                memoryCards = data.cards;
                memoryFlipped = data.flipped;
                memoryMatched = new Set(data.matched);
                memoryCurrentPlayer = data.currentPlayer;
                memoryScores = data.scores;
                memoryLocked = data.locked;
                document.getElementById('memoryScore1').textContent = memoryScores[1];
                document.getElementById('memoryScore2').textContent = memoryScores[2];
                document.getElementById('memoryStatus').textContent = data.status;
                document.getElementById('memoryStatus').style.color = data.statusColor;
                renderMemory();
            }
        }

        const originalFlipCard = flipCard;
        flipCard = function(index) {
            if (!mp.connected) {
                originalFlipCard(index);
                return;
            }

            const myPlayer = mp.isHost ? 1 : 2;
            if (memoryCurrentPlayer !== myPlayer) return;

            originalFlipCard(index);

            mp.send({
                game: 'memory',
                type: 'state',
                cards: memoryCards,
                flipped: memoryFlipped,
                matched: Array.from(memoryMatched),
                currentPlayer: memoryCurrentPlayer,
                scores: memoryScores,
                locked: memoryLocked,
                status: document.getElementById('memoryStatus').textContent,
                statusColor: document.getElementById('memoryStatus').style.color
            });
        };

        // ==================== ROCK PAPER SCISSORS SYNC ====================
        function handleRPSSync(data) {
            if (data.type === 'select') {
                const otherPlayer = mp.isHost ? 2 : 1;
                rpsChoices[otherPlayer] = data.choice;
                document.getElementById(`rpsP${otherPlayer}Choice`).textContent = '‚úì';
                if (rpsChoices[1] && rpsChoices[2]) {
                    setTimeout(rpsReveal, 500);
                }
            } else if (data.type === 'state') {
                rpsScores = data.scores;
                rpsRound = data.round;
                document.getElementById('rpsScore1').textContent = rpsScores[1];
                document.getElementById('rpsScore2').textContent = rpsScores[2];
                document.getElementById('rpsP1Choice').textContent = data.p1Choice;
                document.getElementById('rpsP2Choice').textContent = data.p2Choice;
                document.getElementById('rpsStatus').textContent = data.status;
            } else if (data.type === 'restart') {
                initRPS();
            }
        }

        const originalRpsSelect = rpsSelect;
        rpsSelect = function(player, choice) {
            if (!mp.connected) {
                originalRpsSelect(player, choice);
                return;
            }

            const myPlayer = mp.isHost ? 1 : 2;
            if (player !== myPlayer) return;

            originalRpsSelect(player, choice);

            mp.send({
                game: 'rps',
                type: 'select',
                choice: choice
            });
        };

        // ==================== TYPING SYNC ====================
        function handleTypingSync(data) {
            if (data.type === 'word') {
                typingCurrentWord = data.word;
                document.getElementById('typingWord').textContent = data.word;
                document.getElementById('typingInput1').value = '';
                document.getElementById('typingInput2').value = '';
            } else if (data.type === 'score') {
                typingScores = data.scores;
                document.getElementById('typingScore1').textContent = typingScores[1];
                document.getElementById('typingScore2').textContent = typingScores[2];
                if (data.winner) {
                    typingActive = false;
                    document.getElementById('typingWord').textContent = 'üèÜ';
                    document.getElementById('typingStatus').textContent = `Player ${data.winner} wins!`;
                }
            }
        }

        const originalCheckTyping = checkTyping;
        checkTyping = function(player, value) {
            if (!mp.connected) {
                originalCheckTyping(player, value);
                return;
            }

            const myPlayer = mp.isHost ? 1 : 2;
            if (player !== myPlayer) return;

            if (!typingActive) return;
            if (value.toUpperCase() === typingCurrentWord) {
                typingScores[player]++;
                document.getElementById(`typingScore${player}`).textContent = typingScores[player];

                if (typingScores[player] >= 5) {
                    typingActive = false;
                    document.getElementById('typingWord').textContent = 'üèÜ';
                    document.getElementById('typingStatus').textContent = `Player ${player} wins!`;
                    mp.send({ game: 'typing', type: 'score', scores: typingScores, winner: player });
                } else {
                    const newWord = TYPING_WORDS[Math.floor(Math.random() * TYPING_WORDS.length)];
                    typingCurrentWord = newWord;
                    document.getElementById('typingWord').textContent = newWord;
                    document.getElementById('typingInput1').value = '';
                    document.getElementById('typingInput2').value = '';
                    mp.send({ game: 'typing', type: 'word', word: newWord });
                    mp.send({ game: 'typing', type: 'score', scores: typingScores, winner: null });
                }
            }
        };

        // ==================== WHACK-A-MOLE SYNC ====================
        function handleWhackSync(data) {
            if (data.type === 'score') {
                whackScores = data.scores;
                document.getElementById('whackScore1').textContent = whackScores[1];
                document.getElementById('whackScore2').textContent = whackScores[2];
            } else if (data.type === 'end') {
                document.getElementById('whackStatus').textContent = data.status;
            }
        }

        const originalWhackMole = whackMole;
        whackMole = function(player, index) {
            if (!mp.connected) {
                originalWhackMole(player, index);
                return;
            }

            const myPlayer = mp.isHost ? 1 : 2;
            if (player !== myPlayer) return;

            originalWhackMole(player, index);

            mp.send({
                game: 'whack',
                type: 'score',
                scores: whackScores
            });
        };

        // ==================== AIR HOCKEY SYNC ====================
        function handleHockeySync(data) {
            if (data.type === 'state') {
                if (!mp.isHost) {
                    hockeyPuck = data.puck;
                    hockeyP1 = data.p1;
                    hockeyP2 = data.p2;
                    hockeyScores = data.scores;
                    updateHockeyScores();
                }
            } else if (data.type === 'input') {
                if (mp.isHost) {
                    const speed = 5;
                    if (data.keys.left && hockeyP2.x > 30) hockeyP2.x -= speed;
                    if (data.keys.right && hockeyP2.x < 370) hockeyP2.x += speed;
                    if (data.keys.up && hockeyP2.y > 30) hockeyP2.y -= speed;
                    if (data.keys.down && hockeyP2.y < 230) hockeyP2.y += speed;
                }
            }
        }

        const originalHockeyLoop = hockeyLoop;
        hockeyLoop = function() {
            if (mp.connected && mp.isHost) {
                originalHockeyLoop.call(this);
                mp.send({
                    game: 'airhockey',
                    type: 'state',
                    puck: hockeyPuck,
                    p1: hockeyP1,
                    p2: hockeyP2,
                    scores: hockeyScores
                });
            } else if (mp.connected && !mp.isHost) {
                // Guest sends input and renders
                mp.send({
                    game: 'airhockey',
                    type: 'input',
                    keys: {
                        left: hockeyKeys['ArrowLeft'],
                        right: hockeyKeys['ArrowRight'],
                        up: hockeyKeys['ArrowUp'],
                        down: hockeyKeys['ArrowDown']
                    }
                });
                // Render
                hockeyCtx.fillStyle = '#1a3d1a';
                hockeyCtx.fillRect(0, 0, 400, 500);
                hockeyCtx.strokeStyle = '#2a5a2a';
                hockeyCtx.lineWidth = 2;
                hockeyCtx.beginPath();
                hockeyCtx.moveTo(0, 250);
                hockeyCtx.lineTo(400, 250);
                hockeyCtx.stroke();
                hockeyCtx.beginPath();
                hockeyCtx.arc(200, 250, 50, 0, Math.PI * 2);
                hockeyCtx.stroke();
                hockeyCtx.fillStyle = '#333';
                hockeyCtx.fillRect(140, 0, 120, 10);
                hockeyCtx.fillRect(140, 490, 120, 10);
                hockeyCtx.shadowBlur = 15;
                hockeyCtx.shadowColor = '#00ff88';
                hockeyCtx.fillStyle = '#00ff88';
                hockeyCtx.beginPath();
                hockeyCtx.arc(hockeyP1.x, hockeyP1.y, hockeyP1.radius, 0, Math.PI * 2);
                hockeyCtx.fill();
                hockeyCtx.shadowColor = '#ff6b6b';
                hockeyCtx.fillStyle = '#ff6b6b';
                hockeyCtx.beginPath();
                hockeyCtx.arc(hockeyP2.x, hockeyP2.y, hockeyP2.radius, 0, Math.PI * 2);
                hockeyCtx.fill();
                hockeyCtx.shadowColor = '#fff';
                hockeyCtx.fillStyle = '#111';
                hockeyCtx.beginPath();
                hockeyCtx.arc(hockeyPuck.x, hockeyPuck.y, hockeyPuck.radius, 0, Math.PI * 2);
                hockeyCtx.fill();
                hockeyCtx.strokeStyle = '#fff';
                hockeyCtx.lineWidth = 2;
                hockeyCtx.stroke();
                hockeyCtx.shadowBlur = 0;
                hockeyAnimationId = requestAnimationFrame(hockeyLoop);
            } else {
                originalHockeyLoop.call(this);
            }
        };

        // ==================== BATTLESHIP SYNC ====================
        function handleBattleshipSync(data) {
            if (data.type === 'state') {
                // Only show your ships and attacks on enemy
                const myPlayer = mp.isHost ? 1 : 2;
                const enemyPlayer = mp.isHost ? 2 : 1;

                bsGrids[myPlayer] = data.myGrid;
                // Only show hits/misses on enemy grid, not their ships
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        if (data.enemyGrid[r][c] >= 2) {
                            bsGrids[enemyPlayer][r][c] = data.enemyGrid[r][c];
                        }
                    }
                }
                bsPhase = data.phase;
                bsCurrentPlayer = data.currentPlayer;
                bsShipsPlaced = data.shipsPlaced;
                document.getElementById('battleshipStatus').textContent = data.status;
                document.getElementById('bsInfo').textContent = data.info;
                renderBattleshipGrids();
            }
        }

        const originalHandleBsClick = handleBsClick;
        handleBsClick = function(player, row, col) {
            if (!mp.connected) {
                originalHandleBsClick(player, row, col);
                return;
            }

            const myPlayer = mp.isHost ? 1 : 2;
            const enemyPlayer = mp.isHost ? 2 : 1;

            if (bsPhase === 'placing' && player === myPlayer) {
                originalHandleBsClick(player, row, col);
                mp.send({
                    game: 'battleship',
                    type: 'state',
                    myGrid: bsGrids[myPlayer],
                    enemyGrid: bsGrids[enemyPlayer],
                    phase: bsPhase,
                    currentPlayer: bsCurrentPlayer,
                    shipsPlaced: bsShipsPlaced,
                    status: document.getElementById('battleshipStatus').textContent,
                    info: document.getElementById('bsInfo').textContent
                });
            } else if (bsPhase === 'playing' && player === enemyPlayer && bsCurrentPlayer === myPlayer) {
                originalHandleBsClick(player, row, col);
                mp.send({
                    game: 'battleship',
                    type: 'state',
                    myGrid: bsGrids[myPlayer],
                    enemyGrid: bsGrids[enemyPlayer],
                    phase: bsPhase,
                    currentPlayer: bsCurrentPlayer,
                    shipsPlaced: bsShipsPlaced,
                    status: document.getElementById('battleshipStatus').textContent,
                    info: document.getElementById('bsInfo').textContent
                });
            }
        };

        // ==================== SIMON SYNC ====================
        function handleSimonSync(data) {
            if (data.type === 'state') {
                simonSequence = data.sequence;
                simonPlayerSequence = data.playerSequence;
                simonCurrentPlayer = data.currentPlayer;
                simonScores = data.scores;
                simonPlaying = data.playing;
                simonShowingPattern = data.showingPattern;
                document.getElementById('simonScore1').textContent = simonScores[1];
                document.getElementById('simonScore2').textContent = simonScores[2];
                document.getElementById('simonStatus').textContent = data.status;
                document.getElementById('simonInfo').textContent = data.info;
            } else if (data.type === 'flash') {
                flashSimonButton(data.color);
            }
        }

        // ==================== SOUND TOGGLE ====================
        function toggleSound() {
            sound.enabled = !sound.enabled;
            const btn = document.getElementById('soundToggle');
            btn.textContent = sound.enabled ? 'üîä' : 'üîá';
            btn.classList.toggle('muted', !sound.enabled);
            if (sound.enabled) sound.play('click');
        }

        // ==================== ENHANCED GAME SOUNDS ====================
        // Add click sounds to game cards
        document.querySelectorAll('.game-card').forEach(card => {
            card.addEventListener('click', () => sound.play('click'));
        });

        // Add click sounds to restart buttons
        document.querySelectorAll('.restart-btn').forEach(btn => {
            btn.addEventListener('click', () => sound.play('click'));
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            checkUrlForRoom();
            // Initialize particle systems
            particles.pong.init('pongCanvas');
            particles.snake.init('snakeCanvas');
            particles.hockey.init('hockeyCanvas');
        });
    </script>
</body>
</html>
